<!DOCTYPE html>
<html lang="en" Cross-Origin-Embedder-Policy: require-corp>
<head>
  <meta charset="UTF-8">
  <title>Chess Repertoire</title>
<style>
.piece { position: absolute; width: 95px; height: 95px; margin: 0px 0px 0px 0px }
.xpiece { position: absolute; width: 62px; height: 62px; margin: 0px 0px 0px 0px }
.p_a8 { left: 33px;  top: 33px; } .p_b8 { left: 130px;  top: 33px; } .p_c8 { left: 227px; top: 33px; } .p_d8 { left: 324px; top: 33px; }
.p_e8 { left: 421px; top: 33px; } .p_f8 { left: 518px; top: 33px; } .p_g8 { left: 615px; top: 33px; } .p_h8 { left: 710px; top: 33px; }

.p_a7 { left: 33px;  top: 130px; } .p_b7 { left: 130px;  top: 130px; } .p_c7 { left: 227px; top: 130px; } .p_d7 { left: 324px; top: 130px; }
.p_e7 { left: 421px; top: 130px; } .p_f7 { left: 518px; top: 130px; } .p_g7 { left: 615px; top: 130px; } .p_h7 { left: 710px; top: 130px; }

.p_a6 { left: 33px;  top: 227px; } .p_b6 { left: 130px;  top: 227px; } .p_c6 { left: 227px; top: 227px; } .p_d6 { left: 324px; top: 227px; }
.p_e6 { left: 421px; top: 227px; } .p_f6 { left: 518px; top: 227px; } .p_g6 { left: 615px; top: 227px; } .p_h6 { left: 710px; top: 227px; }

.p_a5 { left: 33px;  top: 324px; } .p_b5 { left: 130px;  top: 324px; } .p_c5 { left: 227px; top: 324px; } .p_d5 { left: 324px; top: 324px; }
.p_e5 { left: 421px; top: 324px; } .p_f5 { left: 518px; top: 324px; } .p_g5 { left: 615px; top: 324px; } .p_h5 { left: 710px; top: 324px; }

.p_a4 { left: 33px;  top: 421px; } .p_b4 { left: 130px;  top: 421px; } .p_c4 { left: 227px; top: 421px; } .p_d4 { left: 324px; top: 421px; }
.p_e4 { left: 421px; top: 421px; } .p_f4 { left: 518px; top: 421px; } .p_g4 { left: 615px; top: 421px; } .p_h4 { left: 710px; top: 421px; }

.p_a3 { left: 33px;  top: 518px; } .p_b3 { left: 130px;  top: 518px; } .p_c3 { left: 227px; top: 518px; } .p_d3 { left: 324px; top: 518px; }
.p_e3 { left: 421px; top: 518px; } .p_f3 { left: 518px; top: 518px; } .p_g3 { left: 615px; top: 518px; } .p_h3 { left: 710px; top: 518px; }

.p_a2 { left: 33px;  top: 615px; } .p_b2 { left: 130px;  top: 615px; } .p_c2 { left: 227px; top: 615px; } .p_d2 { left: 324px; top: 615px; }
.p_e2 { left: 421px; top: 615px; } .p_f2 { left: 518px; top: 615px; } .p_g2 { left: 615px; top: 615px; } .p_h2 { left: 710px; top: 615px; }

.p_a1 { left: 33px;  top: 710px; } .p_b1 { left: 130px;  top: 710px; } .p_c1 { left: 227px; top: 710px; } .p_d1 { left: 324px; top: 710px; }
.p_e1 { left: 421px; top: 710px; } .p_f1 { left: 518px; top: 710px; } .p_g1 { left: 615px; top: 710px; } .p_h1 { left: 710px; top: 710px; }

.px_a8 { left: 22px;  top: 22px; } .px_b8 { left: 86px;  top: 22px; } .px_c8 { left: 150px; top: 22px; } .px_d8 { left: 214px; top: 22px; }
.px_e8 { left: 276px; top: 22px; } .px_f8 { left: 340px; top: 22px; } .px_g8 { left: 404px; top: 22px; } .px_h8 { left: 466px; top: 22px; }

.px_a7 { left: 22px;  top: 86px; } .px_b7 { left: 86px;  top: 86px; } .px_c7 { left: 150px; top: 86px; } .px_d7 { left: 214px; top: 86px; }
.px_e7 { left: 276px; top: 86px; } .px_f7 { left: 340px; top: 86px; } .px_g7 { left: 404px; top: 86px; } .px_h7 { left: 466px; top: 86px; }

.px_a6 { left: 22px;  top: 150px; } .px_b6 { left: 86px;  top: 150px; } .px_c6 { left: 150px; top: 150px; } .px_d6 { left: 214px; top: 150px; }
.px_e6 { left: 276px; top: 150px; } .px_f6 { left: 340px; top: 150px; } .px_g6 { left: 404px; top: 150px; } .px_h6 { left: 466px; top: 150px; }

.px_a5 { left: 22px;  top: 214px; } .px_b5 { left: 86px;  top: 214px; } .px_c5 { left: 150px; top: 214px; } .px_d5 { left: 214px; top: 214px; }
.px_e5 { left: 276px; top: 214px; } .px_f5 { left: 340px; top: 214px; } .px_g5 { left: 404px; top: 214px; } .px_h5 { left: 466px; top: 214px; }

.px_a4 { left: 22px;  top: 276px; } .px_b4 { left: 86px;  top: 276px; } .px_c4 { left: 150px; top: 276px; } .px_d4 { left: 214px; top: 276px; }
.px_e4 { left: 276px; top: 276px; } .px_f4 { left: 340px; top: 276px; } .px_g4 { left: 404px; top: 276px; } .px_h4 { left: 466px; top: 276px; }

.px_a3 { left: 22px;  top: 340px; } .px_b3 { left: 86px;  top: 340px; } .px_c3 { left: 150px; top: 340px; } .px_d3 { left: 214px; top: 340px; }
.px_e3 { left: 276px; top: 340px; } .px_f3 { left: 340px; top: 340px; } .px_g3 { left: 404px; top: 340px; } .px_h3 { left: 466px; top: 340px; }

.px_a2 { left: 22px;  top: 404px; } .px_b2 { left: 86px;  top: 404px; } .px_c2 { left: 150px; top: 404px; } .px_d2 { left: 214px; top: 404px; }
.px_e2 { left: 276px; top: 404px; } .px_f2 { left: 340px; top: 404px; } .px_g2 { left: 404px; top: 404px; } .px_h2 { left: 466px; top: 404px; }

.px_a1 { left: 22px;  top: 466px; } .px_b1 { left: 86px;  top: 466px; } .px_c1 { left: 150px; top: 466px; } .px_d1 { left: 214px; top: 466px; }
.px_e1 { left: 276px; top: 466px; } .px_f1 { left: 340px; top: 466px; } .px_g1 { left: 404px; top: 466px; } .px_h1 { left: 466px; top: 466px; }

.chessdiv { position: absolute; top: 10px; left: 240px; width: 850px; height: 1180px; background-color: #FFFFFF }
.chessboard { position: absolute; top: 90px; left: 0px;  margin: 2px 2px 2px 2px; }
.chessxboard { position: absolute; top: 90px; left: 0px; width: 551px; height: 551px;  margin: 2px 2px 2px 2px}
.chessboardimg { position: absolute; top: 0px; left: 0px; width: 840px; height: 840px;  }
.chessxboardimg { position: absolute; top: 0px; left: 0px; width: 551px; height: 551px; }
.chessheader { position: absolute; top: 0px; left: 0px; border: 1px solid #ABABAB; width: 840px; height: 85px;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; }
.chessxside0 { position: absolute; top: 90px; left: 842px; border: 1px solid #848484; width: 2px; height: 838px }
.chessside0 { position: absolute; top: 91px; left: 553px; border: 1px solid #848484; width: 2px; height: 549px }
.chessrate  { position: absolute; top: 0px; left: 0px; width: 100%; height: 50%; background-color: #404040 }
.chessside1 { position: absolute; top: 90px; left: 580px; border: 1px solid #ABABAB; width: 190px; height: 200px }
.chessside2 { position: absolute; top: 300px; left: 580px; border: 1px solid #ABABAB; width: 190px; height: 180px }
.chessside3 { position: absolute; top: 500px; left: 580px; border: 1px solid #ABABAB; width: 190px; height: 110px }
.chesslisting { position: absolute; top: 650px; left: 0px; border: 1px solid #ABABAB; width: 840px; height: 275px }
.chessfooter { position: absolute; top: 935px; left: 0px; border: 1px solid #ABABAB; width: 840px; height: 240px; 
               font-family: Helvetica, Sans-Serif; font-size: 10pt; font-weight: bold }
.chesspiece  { font-weight: bold; font-size: 14pt; margin: 5px 5px 5px 5px; }
.chesspiecestep { color: #00AA44; font-weight: normal }
.chesspiecemove { color: #FFFFFF; background-color: #288BA8;  cursor: pointer }
.chesspiecenomove { color: #440000; cursor: pointer }
.chesscmt { color: #FF0000; font-weight: normal }
.chesstrcurrent { background-color: #afafaf; width: 840px; }
.chesstr { margin: 0px 0px 0px 0px; border: 2px solid #ff00ff; width: 840px; }
.chesstdp { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 180px; }
.chesstde { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 220px; }
.chesstce { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 20px; }
.chesstdr { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 60px; }
.chesstdl { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 20px; }
.chesstdb { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 10px; }
.chessbutton { margin: 5px 5px 5px 5px }
.chessbutton1 { margin: 1px 0px 1px 0px }
.player { font-weight: bold; color: #1255b3;  }
.playerelo { font-weight: bold; color: #E83845;  }
.gresult { color: #880000; font-weight: bold }
.opening { font-weight: normal; color: #000000;  }
.variation { font-weight: normal; color: #000000;  }
</style>
<link rel="shortcut icon" href="images/favicon.ico">
</head>
<body style="background-color: #000000">
<div id="chessdiv" class="chessdiv"> <div id="chessboard" class="chessboard"></div> 
<div id="chessheader" class="chessheader"><div style="margin: 5px 5px 5px 5px">
 <div style="position: absolute;  width: 830px; height: 75px; top: 5px; left: 5px">
 <span id="currentgameid" class="player" style="cursor: pointer" onclick="showGame(this)"></span>
  <span id="whiteplayer" class="player">White Player</span> <span id="whiteelo" class="playerelo">(1800)</span></span> - <span id="blackplayer" class="player">Black Player</span> <span id="blackelo" class="playerelo">(1800)</span> <span id="resultid" class="gresult">1-0</span> <br>
  <span style="font-weight: bold"></span> <span id="eventid" class="variation">Event</span> (<span id="dateid" class="player">Date</span>)<br>
  <span style="font-weight: bold"></span><span id="ecoid" class="player">ECO</span>: <span id="openingid" class="opening">Opening</span> 
  <span style="font-weight: bold"></span> - <span id="variationid" class="variation">Variation</span><br>
 </div>
 <div style="position:absolute; top: -10px; left: 820px;" ><span style="font-size: 24pt; font-weight: bold; color: #000000" id="sidetomoveid" >&#9675;</span></div>
 <div style="position:absolute; top: 55px; left: 654px;" ><button onclick="newGame()" id="newgameid" style="font-size: 12pt" alt="New Game" title="New Game">n</button></div>
 <div style="position:absolute; top: 55px; left: 682px;" ><button onclick="analyzePosition()" id="newgameid" style="font-size: 12pt" alt="Analyze Position" title="Analyze Position">a</button></div>
 <div style="position:absolute; top: 55px; left: 710px;" ><button onclick="resignGame()" id="resignid" style="font-size: 12pt" alt="Resign" title="Resign">r</button></div>
 <div style="position:absolute; top: 55px; left: 735px;" ><button onclick="undoMove()" id="undoid" style="font-size: 12pt" alt="Undo" title="Undo">&#8592;</button></div>
 <div style="position:absolute; top: 55px; left: 770px;" ><button onclick="redoMove()" id="redoid" style="font-size: 12pt" alt="Redo" title="Redo">&#8594;</button></div>
 <div style="position:absolute; top: 55px; left: 805px;" ><button onclick="expandBoard()" id="expandbtid" style="font-size: 9pt" alt="Expand" title="Expand">&#x2921;</button></div>
</div>
<div id="chesslisting" class="chesslisting">
 <div id="chesslistid" style="margin: 0px 0px 0px 0px; overflow-y:scroll; 
         width: 840px; height: 275px; border-collapse: collapse">
          <table style="display: block; table-layout: fixed; width: 840px" id="chesstableid"></table>
 </div>
</div>
<div id="chessfooter" class="chessfooter"><div id="chessgame" style="margin: 5px 5px 5px 5px; overflow-y:scroll;
			 width: 825px; height: 225px;"></div></div>
<div id="chessside0" class="chessside0">
  <div class="chessrate" id="chessrate"></div>
</div>
<div id="chessside1" class="chessside1"> 
 <div style="margin: 5px 5px 5px 5px">
 <select id="boardselection" onchange="changeBoard();">
 <option value="Green">Green</option>
 <option value="Light Green">Light Green</option>
 <option value="Dark Green">Dark Green</option>
 <option value="Brown">Brown</option>
 <option value="Blue">Blue</option>
 <option value="Dark Blue">Dark Blue</option>
 <option value="Grey">Grey</option>
 <option value="Cyan">Cyan</option>
 <option value="Purple">Purple</option>
 </select>
 <select id="databases" onchange="changeDatabase();">
 <option value="">Databases</option>
 <option value="demo2">demo2.pgn</option>
 <option value="demo4">demo4.pgn</option>
 <option value="demo5">demo5.pgn</option>
 <option value="mygames">mygames.pgn</option>
 <option value="alek">Alek</option>
 <option value="AlekhineExchange">Alekhine Exchange</option>
 <option value="Alekhine2Nc3-d5">Alekhine (2.Nc3 d5)</option>
 <option value="BenkoGambit">Benko Gambit</option>
 <option value="CatalanClosed">Catalan Closed</option>
 <option value="CatalanOpen">Catalan Open</option>
 <option value="FrenchAdvance">French Advance</option>
 <option value="FrenchExachange">French Exchange</option>
 <option value="FrenchRubinstein">French Rubinstein</option>
 <option value="FrTarrasch3c5">French Tarrasch (3.c5)</option>
 <option value="FrTarrasch3Nf6">French Tarrasch (3.Nf6)</option>
 <option value="FrTarraschOther3">French Tarrasch (3.Other)</option>
 <option value="FrWinawerMain">French Winawer (Main)</option>
 <option value="GiuocoPiano">Giuoco Piano</option>
 <option value="KIDClassical">King's Indian (Classic)</option>
 <option value="KIDFianchetto">King's Indian (Fianchetto)</option>
 <option value="KIDSaemisch">King's Indian (Saemisch)</option>
 <option value="KIDPetrosian">King's Indian (Petrosian)</option>
 <option value="QID4a3">Queen's Indian (4.a3)</option>
 <option value="QID4e3">Queen's Indian (4.e3)</option>
 <option value="QID4g3-Ba6">Queen's Indian (4.g3 Ba6)</option>
 <option value="QID4Nc3">Queen's Indian (4.Nc3)</option>
 <option value="RuyLopezBerlin">Ruy Lopez (Berlin)</option>
 <option value="RuyLopezBreyer">Ruy Lopez (Breyer)</option>
 <option value="RuyLopezChigorin">Ruy Lopez (Chigorin)</option>
 <option value="RuyLopezMarshall">Ruy Lopez (Marshall)</option>
 <option value="RuyLopezAntiMarshall">Ruy Lopez (AntiMarshall)</option>
 <option value="PetroffMain">Petroff Main</option>
 <option value="PetroffOther3">Petroff Other 3.</option>
 <option value="Scotch4Bc5">Scotch (4.Bc5)</option>
 <option value="Scotch4Nf6">Scotch (4.Nf6)</option>
 <option value="SicilianAlapin2Nf6">Sicilian Alapin (2.Nf6)</option>
 <option value="SicilianAlapin2d5">Sicilian Alapin (2.d5)</option>
 <option value="SicilianLowenthal">Sicilian Lowenthal</option>
 <option value="SicilianNajdorf6f3">Sicilian Najdorf (f6 f3)</option>
 <option value="SicilianNajdorf6f4">Sicilian Najdorf (f6 f4)</option>
 <option value="SicilianNajdorf6Bg5">Sicilian Najdorf (f6 Bg5)</option>
 <option value="SicilianNajdorf6Be3">Sicilian Najdorf (f6 Be3)</option>
 <option value="SicilianNajdorf6Be2">Sicilian Najdorf (f6 Be2)</option>
 <option value="SicilianNajdorf6Bc4">Sicilian Najdorf (f6 Bc4)</option>
 <option value="SicilianRossolimo">Sicilian Rossolimo</option>
 <option value="SicilianScheveningen">Sicilian Scheveningen</option>
 <option value="SicilianSveshnikov">Sicilian Sveshnikov</option>
 <option value="SicilianTaimanov5Nb5">Sicilian Talmanov (5.Nb5)</option>
 <option value="SicilianTaimanovMain">Sicilian Talmanov (Main)</option>
 </select>
 <input class="chessbutton" type="button" value="Play Move" onclick="playmove()">
 <input class="chessbutton" type="button" value="Play Castle" onclick="playcastle()">
 <input class="chessbutton" type="button" value="Play Capture" onclick="playcapture()">
 </div>
</div>
<div id="chessside2" class="chessside2"> 
<br>
White elo:
<select id="filter_welo_ops">
<option>=</option>
<option selected>>=</option>
<option><=</option>
<option>not =</option>
</select>
<input value="1500" placeholder="1500" maxlength="4" size="4" type="text" id="filter_welo" />
Black elo:
<select id="filter_belo_ops">
<option>=</option>
<option selected>>=</option>
<option><=</option>
<option>not =</option>
</select>
<input value="1500" placeholder="1500" maxlength="4" size="4" type="text" id="filter_belo" />
Moves:
<select id="filter_moves_ops">
<option>=</option>
<option selected>>=</option>
<option><=</option>
<option>not =</option>
</select>
<input value="5" placeholder="5" maxlength="3" size="3" type="text" id="filter_moves" /><br>
Result:<br>
<input type="checkbox" id="filter_res1" value="1-0" checked>1-0
<input type="checkbox" id="filter_res2" value="0-1" checked>0-1
<input type="checkbox" id="filter_res3" value="1/2-1/2" checked>1/2-1/2
</div>
<div id="chessside3" class="chessside3"> 
 <div style="margin: 5px 5px 5px 5px; width=50px"> Total: <span id="totalid">0</span><br> Timer: <span id="timerid">00:00</span></div>
 <div style="margin: 3px 1px 1px 3px"> <input class="chessbutton1" type="button" value="<<" onclick="resetGame()">
 <input class="chessbutton1" type="button" value="<" onclick="backwardPlay()">
 <input class="chessbutton1" type="button" value=">" onclick="forwardPlay()">
 <input class="chessbutton1" type="button" value=">>" onclick="endGame()">
 <input class="chessbutton1" type="button" value="&#8634;" onclick="reverseBoard()"><br>
 <button class="chessbutton1" type="button" value="&#9654;" onclick="repeatPlay()" id="repeatid">&#9654;</button>
 <input type="text" value="25" id="limitmoveid" size=3 maxlength=3/>
 <button class="chessbutton1" type="button" value="&#9632;" onclick="playAW()" id="musicid">&#9632;</button>
 <input type="text" value="330.924" id="musictimeid" size=6 maxlength=6 onchange="MUSIC_TIME=this.value"/>
 </div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pegjs/0.9.0/peg.min.js"></script>
<script type="text/javascript">


    var   REVERSE      = false;
    const WHITE        =  97;
    const BLACK        =  98;
    const UNMOVE       = 100;
    const GOODMOVE     = 101;
    const ENPASSANT    = 102;
    const EATPIECE     = 103;
    const CASTLESHORT  = 104;
    const CASTLELONG   = 105;
    const horiz = [ "a", "b", "c", "d", "e", "f", "g", "h" ];
    const chessdiv   = document.getElementById("chessdiv");
    const chessboard = document.getElementById("chessboard");
    const chessgame = document.getElementById("chessgame");
    const chessrate = document.getElementById("chessrate");
    const chessside0 = document.getElementById("chessside0");
    const img = document.createElement("img");
    img.id = "thegreatboard";
    img.src = "/images/chessboardgreen.png";
    img.style.display = "none"; // Turns off displaying it
    chessboard.appendChild(img); // Puts the image in the image container
    img.style.display = "block";

    // log
    function log(msg) { console.log(msg); } 

    // Position:
    img.className = "chessxboardimg"; 


    // Board Selection
    function changeBoard() {
        const board = document.getElementById("boardselection");
        const selected_board= board.options[board.selectedIndex].value;
      var img_ = null;
      if (selected_board == "Dark Blue") {
         const chessboard = document.getElementById("thegreatboard");
         if (!REVERSE) {
           img_ = "/images/chessboarddarkblue.png";
         } else {
           img_ = "/images/chessboarddarkblueb.png";
         }
         chessboard.src = img_;
      } else
      if (selected_board == "Light Green") {
         const chessboard = document.getElementById("thegreatboard");
         if (!REVERSE) {
           img_ = "/images/chessboardlightgreen.png";
         } else {
           img_ = "/images/chessboardlightgreenb.png";
         }
         chessboard.src = img_;
      } else
      if (selected_board == "Dark Green") {
         const chessboard = document.getElementById("thegreatboard");
         if (!REVERSE) {
           img_ = "/images/chessboarddarkgreen.png";
         } else {
           img_ = "/images/chessboarddarkgreenb.png";
         }
         chessboard.src = img_;
      } else
      if (selected_board == "Green") {
         const chessboard = document.getElementById("thegreatboard");
         if (!REVERSE) {
           img_ = "/images/chessboardgreen.png";
         } else {
           img_ = "/images/chessboardgreenb.png";
         }
         chessboard.src = img_;
      } else
      if (selected_board == "Brown") {
         const chessboard = document.getElementById("thegreatboard");
         if (!REVERSE) {
           img_ = "/images/chessboardbrown.png";
         } else {
           img_ = "/images/chessboardbrownb.png";
         }
         chessboard.src = img_;
      } else
      if (selected_board == "Blue") {
         const chessboard = document.getElementById("thegreatboard");
         if (!REVERSE) {
           img_ = "/images/chessboardblue.png";
         } else {
           img_ = "/images/chessboardblueb.png";
         }
         chessboard.src = img_;
         
      } else
      if (selected_board == "Grey") {
         const chessboard = document.getElementById("thegreatboard");
         if (!REVERSE) {
           img_ = "/images/chessboardgrey.png";
         } else {
           img_ = "/images/chessboardgreyb.png";
         }          
         chessboard.src = img_;
      } else
      if (selected_board == "Cyan") {
         const chessboard = document.getElementById("thegreatboard");
         if (!REVERSE) {
           img_ = "/images/chessboardcyan.png";
         } else {
           img_ = "/images/chessboardcyanb.png";
         }          
         chessboard.src = img_;
      } else
      if (selected_board == "Purple") {
         const chessboard = document.getElementById("thegreatboard");
         if (!REVERSE) {
           img_ = "/images/chessboardpurple.png";
         } else {
           img_ = "/images/chessboardpurpleb.png";
         }          
         chessboard.src = img_;
      } 
    }

    // Reverse Board
    var reverse_ =  { a:"h", b:"g", c:"f", d:"e", e:"d", f:"c", g:"b", h:"a",
                      1:8, 2:7, 3:6, 4:5, 5:4, 6:3, 7:2, 8:1 }
    function reverseLoc(location) {
        if (REVERSE) {
             return reverse_[location[0]] + reverse_[location[1]];
        } 
        return location;
    }

    /* Remove - obsolete */
    function reverseBoard() {
         const chessboard = document.getElementById("thegreatboard");
         chessboard.style.visibility = "hidden";
         REVERSE = !REVERSE;
         changeBoard();
         for (var p in Board) {
            var board = Board[p];
            if (board != null) {
               if (EXPAND_) {
                  board.piece.className = "piece " + "p_" + reverseLoc(board.location);
               } else {
                  board.piece.className = "xpiece " + "px_" + reverseLoc(board.location);
               }
            }
         }
         for (var p in Benched) {
            var board = Benched[p], loc_ = null;
            if (board != null) {
               if (EXPAND_) {
                 board.piece.className = "piece " + "p_" + reverseLoc(board.location);
               } else {
                 board.piece.className = "xpiece " + "px_" + reverseLoc(board.location);
               }
            }
         }
         chessboard.style.visibility = "visible";
         if (ENGINEGAME_) {
            play1Engine((SIDETOMOVE_ == WHITE) ? "w" : "b", "-");
         }
    }

    // expandBoard
    var EXPAND_ = false;
    function expandBoard() {
         const expandbt = document.getElementById("expandbtid");
         const chessboardimg = document.getElementById("thegreatboard");
         const chessboard = document.getElementById("chessboard");
         const chesslisting = document.getElementById("chesslisting");
         const chessside1 = document.getElementById("chessside1");
         const chessside2 = document.getElementById("chessside2");
         const chessside3 = document.getElementById("chessside3");
         chessboard.style.visibility = "hidden";
         EXPAND_ = (EXPAND_) ? false : true;
         if (EXPAND_) {
            expandbt.innerHTML = '&#x29C5;';
            for (var p in Board) {
               var board = Board[p];
               if (board != null) {
                   board.piece.className = "piece " + "p_" + reverseLoc(board.location);
               }
            }
            for (var p in Benched) {
               var board = Benched[p], loc_ = null;
               if (board != null) {
                  board.piece.className = "piece " + "p_" + reverseLoc(board.location);
               }
            } 
            chessboard.className = 'chessboard'
            chessboardimg.className = 'chessboardimg'
            chesslisting.style.visibility = 'hidden';
            chessside1.style.visibility = 'hidden';
            chessside2.style.visibility = 'hidden';
            chessside3.style.visibility = 'hidden';
            chessside0.className = "chessxside0";
         } else {
             expandbt.innerHTML = '&#x2921;';
            for (var p in Board) {
               var board = Board[p];
               if (board != null) {
                   board.piece.className = "xpiece " + "px_" + reverseLoc(board.location);
               }
            }
            for (var p in Benched) {
               var board = Benched[p], loc_ = null;
               if (board != null) {
                  board.piece.className = "xpiece " + "px_" + reverseLoc(board.location);
               }
            }
            chessboard.className = 'chessxboard'
            chessboardimg.className = 'chessxboardimg'
            chesslisting.style.visibility = 'visible';
            chessside1.style.visibility = 'visible';
            chessside2.style.visibility = 'visible';
            chessside3.style.visibility = 'visible';
            chessside0.className = "chessside0";
         }
         chessboard.style.visibility = "visible";
    }


    // Board Selection
    function changeDatabase() {
        const chessdb = document.getElementById("databases");
        const selected_db= chessdb.options[chessdb.selectedIndex].value;
        changePGN();
    }

    function changePGN() {
        const chessdb = document.getElementById("databases");
        const selected_db= chessdb.options[chessdb.selectedIndex].value;
        if (selected_db != null && selected_db != "") {
            const _pgn = "/pgn/" + selected_db + ".pgn";
            log("Loading: " +  _pgn);
            loadPGN(_pgn);
        }
    }

    function illegal_move(msg) { throw msg; }

    const rules = document.styleSheets[0].rules || document.styleSheets[0].cssRules;
    function getCSS(cls) {
       for (p in rules) {
         var rule = rules[p];
         if (rule.selectorText == cls) {
            return { left: parseInt(rule.style.left.replace(/px/, "")),
                     top: parseInt(rule.style.top.replace(/px/, "")) }
         }
       }
       return null;
    }

    var SIDETOMOVE_ = WHITE, MOVECOUNT_ = 0;
    var sidetoid = document.getElementById("sidetomoveid");
    function TurnToPlay() {
        SIDETOMOVE_ = (SIDETOMOVE_ == WHITE) ? BLACK: WHITE;
        MOVECOUNT_ = MOVECOUNT_ + ((SIDETOMOVE_ == WHITE ) ? 1 : 0);
        sidetoid.innerHTML = (SIDETOMOVE_ == WHITE) ? '&#9675;' : '&#9679;';
    }

    function mouseDown(e)  {
         e.preventDefault();
         if (FETCHEDGAME_) return;
         offsetLeft = chessdiv.offsetLeft + chessboard.offsetLeft + ((EXPAND_) ? (20 + 28) : (15 + 16));
         offsetTop = chessdiv.offsetTop + chessboard.offsetTop + ((EXPAND_) ? (20 + 28) : (15 + 16));
         this.startPosX = offsetLeft + this.offsetLeft;
         this.startPosY = offsetTop + this.offsetTop ;
         chessboard.targetmove_ = this;
         chessboard.addEventListener('mousemove', mouseMove);
    }

    const engineGames = [];
    function saveGame() {
         const game = {}
         if (ecoGame_.length > 0) {
          var moves_ = 0;
          game.wp = (REVERSE) ? "Stockfish 15" : "Smart Me"; 
          game.bp = (REVERSE) ? "Smart Me" : "Stockfish 15"; 
          game.we = String((REVERSE) ? 1800 : 2800);
          game.be = String((REVERSE) ? 2800 : 1800); 
          game.dt = new Date(Date.now()).toLocaleString();
          game.ev = "Man vs Machine";
          game.si = "Home";
          game.rt = (REVERSE) ? "0-1" : "1-0"; 
          game.moves = ecoGame_.join(" ") + " " + game.rt + " ";
          moves_ = game.moves.split(' ').length; moves_ = Math.floor(moves_ / 2); 
          game.ct = moves_;
          game.eco = ecoid.innerHTML;
          game.round = String(engineGames.length + 1);
          engineGames.push(game); 
          Games = engineGames;
          refreshGames(false, null);
         }
    }

    /* Remove - obsolete */
    const ecoGame_ = [];
    var  ENGINEGAME_ = false;
    function newGame() {
        reloadBoard();
        MOVECOUNT_ = 0; SIDETOMOVE_ = WHITE; ENGINEGAME_ = true; FETCHEDGAME_ = false;
        chessgame.innerHTML = "";  Games = [];
        saveGame();
        while (ecoGame_.length > 0)  ecoGame_.pop();
        if (REVERSE) {
            play1Engine("w", "-" );
        }
    }

    /* Remove - obsolete */
    function resignGame() {
       newGame();
    }

    function generateFEN(nextmove, enpassant = "-") {
      var piece = null;
      var fen = "", spc = 0, cmp = "";
      var castling = [0,0,0,0,0,0], cst = "";
      for (var v=8; v>=1; v--) {
         spc = 0;
         for (p in horiz) {
            piece = Board[horiz[p] + v];
            if (piece != null) {
                cmp =  (piece.color_.match(/dt$/)) ? piece.role_.toLowerCase() : piece.role_;
                fen = fen + ((spc > 0) ? (spc + cmp) : cmp);
                spc = 0;
                // check for castling availability
                if (cmp == 'K' && piece.location_ == 'e1' && piece.oldlocation_ == null) castling[0] =  1;
                if (cmp == 'k' && piece.location_ == 'e8' && piece.oldlocation_ == null) castling[1] =  1;
                if (cmp == 'R' && piece.location_ == 'h1' && piece.oldlocation_ == null) castling[2] =  1;
                if (cmp == 'R' && piece.location_ == 'a1' && piece.oldlocation_ == null) castling[3] =  1;
                if (cmp == 'r' && piece.location_ == 'h8' && piece.oldlocation_ == null) castling[4] =  1;
                if (cmp == 'r' && piece.location_ == 'a8' && piece.oldlocation_ == null) castling[5] =  1;
            } else { spc ++; }
         }
         fen = fen + ((spc > 0) ? spc : "");
         if (v > 1) fen = fen + "/";
       } 
       if (castling[0] == 1 && castling[2] == 1) cst = cst + "K";
       if (castling[0] == 1 && castling[3] == 1) cst = cst + "Q";
       if (castling[1] == 1 && castling[4] == 1) cst = cst + "K";
       if (castling[1] == 1 && castling[5] == 1) cst = cst + "q";
       fen = fen + " " + nextmove + " " + cst + " " + enpassant + " " + "0 1";
       log(fen);
       return fen;
    }

    var ENGINEMOVE_ = null, PONDER_ = null, int_engine = 0, enginetime = null;
    var ENGINE_ = null, ANALYZE_ = []
    function post(msg) { ENGINE_.postMessage(msg); }

    var wscore = 0, bscore=0, wcp = 0, bcp = 0, chessdata_ = null;
    async function loadStockfish() {
       ENGINE_ = await new Worker('/wasm/stockfish.js');
       ENGINE_.onmessage = function(event) {
             var load = event.data ? event.data : event;
             var sdata = load.split(' ');
             var mate = sdata[8];
             var xcp   = parseInt(sdata[9]);
             var draw = Math.floor(parseInt(sdata[12]) / 2); 
             var win = ( parseInt(sdata[11])) / 1000;
             var draw = (parseInt(sdata[12])) / 1000;
             var loss = (parseInt(sdata[13])) / 1000;
             var wscore = (parseInt(sdata[11]) + parseInt(sdata[12])/2) / 1000;
             var bscore = (parseInt(sdata[13]) + parseInt(sdata[12])/2) / 1000;
             var srate = 1 / (1 + Math.exp(-0.004*xcp)); // formula from Landon Lehman blog site.
             var pv = load.lastIndexOf("pv");
             if (!isNaN(srate)) 
             ANALYZE_.push({ srate: srate, mt: mate, wscore: wscore, bscore: bscore, cp: xcp, 
					win: win, draw: draw, loss: loss, moves: load.slice(pv+3) } );
             if (load.includes('bestmove')) {
                ENGINEMOVE_ = sdata[1];
                PONDER_ = sdata[3];
                log(ENGINEMOVE_);
                log(PONDER_);
             }
       };
    }

    function searchGame() {
        return ecoGame_.join(' ');
    }

    var BOOK_ = null;
    function searchECO() {
       var randmove = 0, book_ = "";
       var game_ = searchGame();
       const ecoran_ = [];
       BOOK_ = null;
       for (p in ECO_) {
          var eco = ECO_[p][2];
          if (typeof(eco) != "undefined") {
            if (eco.match(game_)) {
               ecoran_.push(ECO_[p]);
            } 
          }
       }
       randmove = Math.floor(Math.random() * ecoran_.length)
       if (ecoran_.length > 0 ) {
         var idx = (SIDETOMOVE_ == WHITE) ? (MOVECOUNT_ * 2): (MOVECOUNT_ * 2 + 1) , 
             move_ = null;
         BOOK_ = ecoran_[randmove]
         ecoid.innerHTML = BOOK_[0] 
         openingid.innerHTML = BOOK_[1] 
         variationid.innerHTML = BOOK_[2].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, ''); 
         move_ = BOOK_[2].split(' ')[idx]
         if (typeof(move_) != "undefined") { 
           move_ = move_.replace(/^[0-9]+\./g, "");
         } else BOOK_ = null; 
         if (BOOK_ != null && BOOK_[2].lastIndexOf("(") >=0 ) BOOK_ = null;
         return move_;
       }
       return null;
    }

    function searchBest() {
        var ponder_ = (typeof(PONDER_) == "undefined") ? "" : " " + PONDER_;
        var move_ = ENGINEMOVE_ + ponder_, load_, found = 0, score = 0, moveit_ = null;
        var analyze = 50;
        for (p in ANALYZE_) {
          const l_ = ANALYZE_[p]; 
          found = l_.moves.lastIndexOf(move_); 
          if (found == 0) {
            if (l_.srate > score ) {
              load_ = l_;
              score = load_.srate
            }
          }
        }
        moveit_ = searchECO();
        if (load_.mt == "mate") { analyze = 100; } else
        if (moveit_ != null) { analyze = 50; } else { analyze = (load_.srate * 100) }
        chessrate.style.height = analyze + "%"; 
        chessside0.style.backgroundColor = (!REVERSE) ? "#FFFFFF" : "#404040";
        chessrate.style.backgroundColor = (!REVERSE) ? "#404040" : "#FFFFFF";
        if (moveit_ != null) return moveit_;
        return null;
    }
 
    function captureEngineMove() {
        if (int_engine > 20) { int_engine = 0; clearInterval(enginetime)  }
        if (ENGINEMOVE_ != null) {
            clearInterval(enginetime);
            var oloc_ = ENGINEMOVE_.slice(0,2), nloc_ = ENGINEMOVE_.slice(-2);
            var piece = Board[oloc_];
            if (piece != null) {
                var move_ = null, role;
                move_ = searchBest();
                if (move_ != null) { // Book moves
                   movePiece(((SIDETOMOVE_ == WHITE) ? 'lt' : 'dt'), { white: move_, black: move_ });  
                } else {
                   piece.move = { location: nloc_, promote: null }
                   chess_move.play();
                   if (piece.restype_ == CASTLELONG) move_ = "O-O-O"; else
                   if (piece.restype_ == CASTLESHORT) move_ = "O-O"; else
                   if (piece.restype_ == EATPIECE) {
                   if (piece.role_ == 'P') 
                         move_ = piece.oldlocation_[0] + "x" + nloc_; 
                        else 
                        move_ = piece.role_ + "x" + nloc_; 
                    } else {
                         move_ = piece.role_.replace(/P/g,'') + nloc_;
                    }
                }
                moveIt(((SIDETOMOVE_ == WHITE) ? (MOVECOUNT_ + 1): null), 
                     typeof(PONDER_) == "undefined" ? move_ + "#" : move_);
         
                if (typeof(PONDER_) == "undefined" || PONDER_ == null) {
                    log("Game done ...");
                    log(chessgame.innerHTML);
                }
                TurnToPlay();
            } 
        }
    }

    function analyzePosition() {
       var fen = "R7/8/5ppk/1p2p3/5n2/1B3PK1/1PP4r/8 b  - 0 1"
    }

    /* Remove - obsolete */
    async function play1Engine(nextmove, enpassant) {
       var fen = generateFEN(nextmove, enpassant);
       var movetime =  Math.floor(Math.random() * 200 + 500)
       var depth =  Math.floor(Math.random() * 5 + 15)
       ENGINEMOVE_ = null;
       ANALYZE_ = [];
       post("setoption name UCI_ShowWDL value true");
    //   post("setoption name UCI_AnalyseMode value true");
       post("setoption name MultiPV value 5");
       post("setoption name Slow Mover type spin default 84 min 10 max 1000");
       post("isready");
       post("ucinewgame");
       post("position fen " + fen);
       await post("go movetime " + movetime + " depth " + depth);
       enginetime = setInterval(captureEngineMove, 50);
    }

    var zindex_ = 0;
    function mouseMove(e) {
           piece = this.targetmove_;
           x = e.clientX; y = e.clientY;
           piece.newPosX   = piece.startPosX - x;
           piece.newPosY   = piece.startPosY - y;
           piece.startPosX = x;
           piece.startPosY = y;
           piece.style.top  = (piece.offsetTop - piece.newPosY) + "px";
           piece.style.left = (piece.offsetLeft - piece.newPosX) + "px";
           piece.style.zIndex = zindex_++;
    }
    
    chessboard.addEventListener('mouseup', function(){
      if (typeof(this.targetmove_) != 'undefined') {
               ENGINEGAME_ = true; 
               var piece = this.targetmove_, loc_ = null;
               var offset = ((EXPAND_) ? (20 + 28) : (15 + 16));
               var x = piece.offsetLeft + offset; var y = piece.offsetTop + offset;
               var cls_ = null, clsp_ = null, loc_ = null, woffs = (EXPAND_) ? 95 : 62;
               var BRK = false;
               for (h in horiz) {
                 for (var v=1; v<=8; v++) {
                     loc_ = horiz[h] + v; 
                     clsp_ =  (EXPAND_) ? ( "p_" + reverseLoc(loc_)) : ("px_" + reverseLoc(loc_));
                     cls_ = getCSS("." + clsp_);
                  
                     if (cls_.left < x && cls_.left + woffs > x && cls_.top < y && cls_.top + woffs > y) {
                        try {
		            var promote = null, move_ = null, pclass = piece.pclass;
                            if (pclass.role == 'P') {
                               if (!REVERSE) {
                                 if (pclass.color == 'plt' && v == 8) promote = 'Q'; 
                                 if (pclass.color == 'pdt' && v == 1) promote = 'Q'; 
                               } else {
                                 if (pclass.color == 'plt' && v == 1) promote = 'Q'; 
                                 if (pclass.color == 'pdt' && v == 8) promote = 'Q'; 
                               }
                            } 
                            if (SIDETOMOVE_ == WHITE && pclass.color_.match(/dt$/)) break;
                            if (SIDETOMOVE_ == BLACK && pclass.color_.match(/lt$/)) break;
                            pclass.move = { location: loc_, promote: promote };
                            chess_move.play();
                            if (pclass.restype_ == CASTLELONG) move_ = "O-O-O"; else
                            if (pclass.restype_ == CASTLESHORT) move_ = "O-O"; else
                            if (pclass.restype_ == EATPIECE) { 
                                    if (pclass.role_ == 'P') 
                                      move_ = pclass.oldlocation_[0] + "x" + loc_; 
                                     else 
                                      move_ = pclass.role_ + "x" + loc_; 
                            } else move_ = pclass.role_.replace(/P/g,'') + loc_;
                            moveIt(((SIDETOMOVE_ == WHITE) ? ( MOVECOUNT_ + 1) : null), move_);
                            TurnToPlay();
                            play1Engine((SIDETOMOVE_ == WHITE) ? "w" : "b", "-");
                            BRK = true; break;
                        } catch(e) { 
                            var s = e.lastIndexOf('endangering its own king');
                            if (s >= 0) { 
                             undoitMove(false);
                            } else { 
                             log(e); 
                            }
                        }
                     } 
                 }
                 if (BRK) break;
               }
               piece.style.top = ""; piece.style.left = "";
               this.removeEventListener('mousemove', mouseMove);
      }
    });


    function getImgSrc(tag) {
      const piece_path = "/images/Chess_";
      return piece_path + tag + "45.svg";
    }

    var LastPiece = null;
    // Piece class
    class Piece {
       constructor(role, tag, location) {
          this.image(role, tag, location);              
       }

       image(role, tag, location, ol = 0, img = 0) { 
           this.role_ = role;
           this.color_ = tag;
           this.location_ = location;
           if (ol == 0) this.oldlocation_ = null;
           this.active_ = 1;
           if (img == 0) this.piece = document.createElement("img");
           this.piece.id   = role + location;
           this.piece.src = getImgSrc(tag);
           if (EXPAND_) {
              this.piece.className = "piece " + "p_" + reverseLoc(location);
           } else {
              this.piece.className = "xpiece " + "px_" + reverseLoc(location);
           }
           this.piece.display = "block";
           this.piece.style = "cursor: pointer";
           this.piece.addEventListener('mousedown', mouseDown);
           this.piece.pclass = this;
           this._CHECK_KING_ = false;
        }

       get role() { return this.role_; }
       get location() { return this.location_; }
       get oldlocation() { return this.oldlocation_; }
       get getpiece() { return this.piece; }
       get color() { return this.color_; }
  
       set active(s) {
          if (s == 0) {
             this.piece.style.visibility = "hidden";
             this.active_ = s;
          }
       }

       set promote_piece(what) {
         if (what == "=Q" || what == "(Q)" || what == "Q") {
          if (this.color_ == 'plt' && this.location_[1] == '7' ) { this.image('Q', 'qlt', this.location_, 1, 1); return } 
          if (this.color_ == 'pdt' && this.location_[1] == '2' ) { this.image('Q', 'qdt', this.location_, 1, 1); return } 
         } else
         if (what == "=R" || what == "(R)" || what == "R") {
          if (this.color_ == 'plt' && this.location_[1] == '7') { this.image('R', 'rlt', this.location_, 1, 1); return } 
          if (this.color_ == 'pdt' && this.location_[1] == '2') { this.image('R', 'rdt', this.location_, 1, 1); return } 
         } else
         if (what == "=B" || what == "(B)" || what == "B") {
          if (this.color_ == 'plt' && this.location_[1] == '7') { this.image('B', 'blt', this.location_, 1, 1); return } 
          if (this.color_ == 'pdt' && this.location_[1] == '2') { this.image('B', 'bdt', this.location_, 1, 1); return } 
         } else
         if (what == "=N" || what == "(N)" || what == "N") {
          if (this.color_ == 'plt' && this.location_[1] == '7') { this.image('N', 'nlt', this.location_, 1, 1); return } 
          if (this.color_ == 'pdt' && this.location_[1] == '2') { this.image('N', 'ndt', this.location_, 1, 1); return } 
         } 
         illegal_move("Illegal move (81)!"); 
       }
    
       set move(what) {
           const location = what.location;
           const promote = what.promote;
           const RES = this.assertMove(location);
           if (RES == ENPASSANT) { 
                  var len = Benched.length;
                  this.restype_ = RES;
                  LastPiece.active = 0;
                  Benched.push ( LastPiece );
                  Board[location] = this;
                  Board[this.location_] =  null;
                  Board[LastPiece.location_] =  null;
                  Undo.push( { type: RES, color: this.color_, piece: this, benched: LastPiece,
                                oloc: this.location_, nloc: location, ooloc: this.oldlocation_ } )
           } else
           if (RES == EATPIECE) { 
                  var len = Benched.length;
                  this.restype_ = RES;
                  Board[location].active = 0;
                  Benched.push ( Board[location]);
                  if (promote != null && promote != "") this.promote_piece = promote;
                  Board[location] = this;
                  Board[this.location_] =  null;
                  Undo.push( { type: RES, color: this.color_, piece: this, benched: Benched[Benched.length - 1],
                                oloc: this.location_, nloc: location, ooloc: this.oldlocation_, promote: promote } )
           } else
           if (RES == CASTLELONG) { 
                      for (var p in Board) { 
                         const Piece = Board[p];
                         if (Piece != null && Piece.oldlocation_ == null && this.oldlocation_ == null) {
                                              // Rook and King have not moved before
                             if (this.color_ == "klt") { 
                                 if (location == "c1") {
                                   if (Piece.location_ == "a1" && Piece.color == "rlt") {
                                     if (EXPAND_) {
                                        Piece.piece.className = "piece p_" + reverseLoc("d1");
                                     } else {
                                        Piece.piece.className = "xpiece px_" + reverseLoc("d1");
                                     }
                                     this.restype_ = RES;
                                     Piece.piece.display = "block";
                                     Piece.oldlocation_ = "a1";
                                     Piece.location_ = "d1";
                                     Board[location] = this;
                                     Board[this.location_] =  null;
                                     Board["d1"] = Piece;
                                     Board["a1"] = null;
                                     Undo.push( { type: RES, color: this.color_, piece: this, rook: Piece,
                                                 oloc: this.location_, nloc: location, ooloc: this.oldlocation_ } )
                                   }
                                 }
                              } else 
                              if (this.color_ == "kdt") { // dark
                                 if (location == "c8") {
                                   if (Piece.location_ == "a8" && Piece.color == "rdt") {
                                     if (EXPAND_) {
                                        Piece.piece.className = "piece p_" + reverseLoc("d8");
                                     } else {
                                        Piece.piece.className = "xpiece px_" + reverseLoc("d8");
                                     }
                                     this.restype_ = RES;
                                     Piece.piece.display = "block";
                                     Piece.oldlocation_ = "a8";
                                     Piece.location_ = "d8";
                                     Board[location] = this;
                                     Board[this.location_] =  null;
                                     Board["d8"] = Piece;
                                     Board["a8"] = null;
                                     Undo.push( { type: RES, color: this.color_, piece: this, rook: Piece,
                                                 oloc: this.location_, nloc: location, ooloc: this.oldlocation_ } )
                                   }
                                 }
                              }     
                          }
                       }
           } else
           if (RES == CASTLESHORT) { 
                      for (var p in Board) {
                         const Piece = Board[p];    
                         if (Piece != null && Piece.oldlocation_ == null && this.oldlocation_ == null) {
                                              // Rook and King have not moved before
                             if (this.color_ == "klt") {
                                 if (location == "g1") {
                                   if (Piece.location_ == "h1" && Piece.color == "rlt") {
                                     if (EXPAND_) {
                                        Piece.piece.className = "piece p_" + reverseLoc("f1");
                                     } else {
                                        Piece.piece.className = "xpiece px_" + reverseLoc("f1");
                                     }
                                     this.restype_ = RES;
                                     Piece.piece.display = "block";
                                     Piece.oldlocation_ = "h1";
                                     Piece.location_ = "f1";
                                     Board[location] = this;
                                     Board[this.location_] =  null;
                                     Board["f1"] = Piece;
                                     Board["h1"] = null;
                                     Undo.push( { type: RES, color: this.color_, piece: this, rook: Piece,
                                                 oloc: this.location_, nloc: location, ooloc: this.oldlocation_ } )
                                   }
                                 }
                              } else
                              if (this.color_ == "kdt") { // dark
                                 if (location == "g8") {
                                   if (Piece.location_ == "h8" && Piece.color == "rdt") {
                                     if (EXPAND_) {
                                       Piece.piece.className = "piece p_" + reverseLoc("f8");
                                     } else {
                                       Piece.piece.className = "xpiece px_" + reverseLoc("f8");
                                     }
                                     this.restype_ = RES;
                                     Piece.piece.display = "block";
                                     Piece.oldlocation_ = "h8";
                                     Piece.location_ = "f8";
                                     Board[location] = this;
                                     Board[this.location_] =  null;
                                     Board["f8"] = Piece;
                                     Board["h8"] = null;
                                     Undo.push( { type: RES, color: this.color_, piece: this, rook: Piece,
                                                 oloc: this.location_, nloc: location, ooloc: this.oldlocation_ } )
                                   }
                                 }
                              }
                          }
                       }
           } else
           if (RES == GOODMOVE) { 
                  if (promote != null && promote != "") this.promote_piece = promote;
                  this.restype_ = RES;
                  Board[location] = this; 
                  Board[this.location_] =  null;
                  Undo.push( { type: RES, color: this.color_, piece: this, oloc: this.location_, nloc: location, ooloc: this.oldlocation_ } )
           } else {
                 illegal_move("No result from assertion!");
           }
           if (EXPAND_) {
              this.piece.className = "piece " + "p_" + reverseLoc(location);
           } else {
              this.piece.className = "xpiece " + "px_" + reverseLoc(location);
           }
           this.piece.display = "block";
           this.oldlocation_ = this.location_;
           this.location_ = location;
           LastPiece = this;
           const threat = this.evaluate_king_threat(RES);
           if (threat) { log( "King is in danger (" + threat + ")!"); }
           return RES;
       }

       get_location(obj) {
         const oldlocation = obj.oldlocation;
         const oh = (oldlocation != null) ? oldlocation[0].charCodeAt(0) : null;
         const ov = (oldlocation != null) ? oldlocation[1] : null;
         return { nh: obj.location[0].charCodeAt(0 ), nv: parseInt(obj.location[1]), oh: oh, ov: ov };
       }

       threat_by_bishop(Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, Queen = 0) {
            var threat = 0;
            var colorl = (Queen) ? 'qlt' : 'blt';
            var colord = (Queen) ? 'qdt' : 'bdt';
            if (diff_kdh == diff_kdv && Piece.color_ == colorl) {  var bthreat = 1;
                 for (var v = 1; v < diff_kdv; v++) {
                     const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + v) : (KD_loc.nv - v);
                     const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + v) : (KD_loc.nh - v);
                     const nh = String.fromCharCode(dist);
                     if (Board[nh + nv]  != null)  { bthreat = 0; break }
                 }
                 threat = bthreat;
             }
             if (diff_klh == diff_klv && Piece.color_ == colord) {  var bthreat = 1;
                 for (var v = 1; v < diff_klv; v++) {
                     const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + v) : (KL_loc.nv - v);
                     const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + v) : (KL_loc.nh - v);
                     const nh = String.fromCharCode(dist);
                     if (Board[nh + nv]  != null)  { bthreat = 0; break }
                 }
                 threat = bthreat;
             }
             this._CHECK_KING_ = (threat && this.color_.slice(-2) == Piece.color_.slice(-2)) 
             threat = this._CHECK_KING_ ? 0 : threat; // not endangering itself
             return  threat;
       }

       threat_by_rook(Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, Queen = 0) {
             var nh = null, nv = null, threat = 0;
             var colorl = (Queen) ? 'qlt' : 'rlt';
             var colord = (Queen) ? 'qdt' : 'rdt';
             if (diff_kdh == 0 && diff_kdv > 0 && Piece.color_ == colorl ) { var rthreat = 1;
                 for (var v = 1; v < diff_kdv; v++) {
                     const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + v) : (KD_loc.nv - v);
                     const nh = String.fromCharCode(KD_loc.nh);
                     if (Board[nh + nv]  != null)  { rthreat = 0; break }
                 }
             } else
             if (diff_kdv == 0 && diff_kdh > 0 && Piece.color_ == colorl) { var rthreat = 1;
                 for (var h = 1; h < diff_kdh; h++) {
                     const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + h) : (KD_loc.nh - h);
                     const  nh = String.fromCharCode(dist);
                     if (Board[nh + KD_loc.nv]  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             }
             if (diff_klh == 0 && diff_klv > 0 && Piece.color_ == colord) { var rthreat = 1; 
                 for (var v = 1; v < diff_klv; v++) {
                     const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + v) : (KL_loc.nv - v);
                     const nh = String.fromCharCode(KL_loc.nh);
                     if (Board[nh + nv]  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             }  else
             if (diff_klv == 0 && diff_klh > 0 && Piece.color_ == colord) { var rthreat = 1;
                 for (var h = 1; h < diff_klh; h++) {
                     const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + h) : (KL_loc.nh - h);
                     const  nh = String.fromCharCode(dist); 
                     if (Board[nh  + KL_loc.nv]  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             }
             this._CHECK_KING_ = (threat && this.color_.slice(-2) == Piece.color_.slice(-2)) 
             threat = this._CHECK_KING_ ? 0 : threat; // not endangering itself
             return threat;
       }

       threat_by_knight(Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv) {
             var nthreat = 0;
             if (diff_kdv == 2 && diff_kdh == 1 && Piece.color_ == 'nlt') {
                 const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + 1) : (KD_loc.nh - 1);
                 const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + 2) : (KD_loc.nv - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv]  != null)  { nthreat = 1; }
             } else
             if (diff_kdh == 2 && diff_kdv == 1 && Piece.color_ == 'nlt') {
                 const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + 1) : (KD_loc.nv - 1);
                 const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + 2) : (KD_loc.nh - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv]  != null)  { nthreat = 1; }
             }
             if (diff_klv == 2 && diff_klh == 1 && Piece.color_ == 'ndt') {
                 const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + 1) : (KL_loc.nh - 1);
                 const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + 2) : (KL_loc.nv - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv]  != null)  { nthreat = 1; }
             } else
             if (diff_klh == 2 && diff_klv == 1 && Piece.color_ == 'ndt') {
                 const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + 1) : (KL_loc.nv - 1);
                 const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + 2) : (KL_loc.nh - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv]  != null)  { nthreat = 1; }
             }
             this._CHECK_KING_ = (nthreat && this.color_.slice(-2) == Piece.color_.slice(-2)) 
             nthreat = this._CHECK_KING_ ? 0 : nthreat; // not endangering itself
             return nthreat;
       }

       evaluate_king_threat(RES) {
          var KD = null, KL = null;
          // find the kings
          for (var p in Board) {
               const Piece = Board[p];
               if (Piece != null) {
                  if (Piece.role == 'K') {
                     if (Piece.color_ == 'klt') {
                         KL = Piece; 
                     } else
                     if (Piece.color_ == 'kdt') {
                         KD = Piece; 
                     }
                  } 
               }   
          } 
          var KDR_loc = null,  KLR_loc = null;
          if (RES == CASTLESHORT) {
              const KDR = new Piece("K", "kdt", "f8");
              const KLR = new Piece("K", "klt", "f1");
              KDR_loc = this.get_location(KDR); 
              KLR_loc = this.get_location(KLR);
          } else
          if (RES == CASTLELONG) {
              const KDR = new Piece("K", "kdt", "d8");
              const KLR = new Piece("K", "klt", "d1");
              KDR_loc = this.get_location(KDR); 
              KLR_loc = this.get_location(KLR);
          }
          const KD_loc = this.get_location(KD); const KL_loc = this.get_location(KL);
          // evaluate the pieces
          var threat = 0;
          this._CHECK_KING_ = false;
          for (var p in Board) {
               const Piece = Board[p];
               if (Piece === this) continue;
               if (Piece != null) {
                  const ploc = this.get_location(Piece);
                  const diff_kdh = Math.abs(KD_loc.nh - ploc.nh); const diff_kdv = Math.abs(KD_loc.nv - ploc.nv);
                  const diff_klh = Math.abs(KL_loc.nh - ploc.nh); const diff_klv = Math.abs(KL_loc.nv - ploc.nv);
                  var diff_kdrh = 0, diff_kdrv = 0, diff_klrh = 0, diff_klrv = 0;
                  if (KDR_loc != null && KLR_loc != null) {
                    diff_kdrh = Math.abs(KDR_loc.nh - ploc.nh); diff_kdrv = Math.abs(KDR_loc.nv - ploc.nv);
                    diff_klrh = Math.abs(KLR_loc.nh - ploc.nh); diff_klrv = Math.abs(KLR_loc.nv - ploc.nv);
                  }
                  if (Piece.role == 'K') {
                      if (Piece.color_ == 'nlt') {
                         if ((diff_kdh == 0 && diff_kdv == 1) || (diff_kdv == 0 && diff_kdh == 1)) { threat = 1; }
                         if ((diff_kdh ==  diff_kdv && diff_kdv == 1)) { threat = 1; }
                      } else {
                         if ((diff_klh == 0 && diff_klv == 1) || (diff_klv == 0 && diff_klh == 1)) { threat = 1; }
                         if ((diff_klh ==  diff_klv && diff_klv == 1)) { threat = 1; }
                      } 
                      this._CHECK_KING_ = (threat && this.color_.slice(-2) == Piece.color_.slice(-2)) 
                      threat = this._CHECK_KING ? 0 : threat; // not endangering itself
                  } else
                  if (Piece.role == 'Q') {
                      const bthreat = this.threat_by_bishop(Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, 1);
                      const rthreat = this.threat_by_rook(Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, 1);
                      threat = (bthreat || rthreat) ? 2 : threat;
                      if (KDR_loc != null && KLR_loc != null) { // check castle threat
                        if (this.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const bthreat1 = this.threat_by_bishop(Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv, 1);
                        const rthreat1 = this.threat_by_rook(Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv, 1);
                        threat = (bthreat1 || rthreat1) ? -2 : threat;
                      }
                  } else
                  if (Piece.role == 'B') {
                      const bthreat = this.threat_by_bishop(Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv);
                      threat = (bthreat) ? 3 : threat;
                      if (KDR_loc != null && KLR_loc != null) { // check castle threat
                        if (this.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const bthreat1 = this.threat_by_bishop(Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv);
                        threat = (bthreat1) ? -3 : threat;
                      }
                  } else
                  if (Piece.role == 'R') {
                      const rthreat = this.threat_by_rook(Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv);
                      threat = (rthreat) ? 4 : threat;
                      if (KDR_loc != null && KLR_loc != null) {  // check castle threat
                        if (this.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const rthreat1 = this.threat_by_rook(Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv);
                        threat = (rthreat1) ? -4 : threat;
                      }
                  } else
                  if (Piece.role == 'N') {
                      const nthreat = this.threat_by_knight(Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv);
                      threat = (nthreat) ? 5 : threat;
                      if (KDR_loc != null && KLR_loc != null) {  // check castle threat
                        if (this.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const nthreat1 = this.threat_by_knight(Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv);
                        threat = (nthreat1) ? -5 : threat;
                      }
                  } else
                  if (Piece.role == 'P') {
                     var pthreat = 0, pthreat1 = 0;
                     if (diff_klh == 1 && diff_klv == 1) {
                       if (KL_loc.nv < ploc.nv && Piece.color_ == 'pdt') { pthreat = 1; }
                     }
                     if (diff_kdh == 1 && diff_kdv == 1) {
                       if (KD_loc.nv > ploc.nv && Piece.color_ == 'plt') { pthreat = 1; }
                     }
                     this._CHECK_KING_ = (pthreat && this.color_.slice(-2) == Piece.color_.slice(-2)) 
                     pthreat = this._CHECK_KING_ ? 0 : threat; // not endangering itself
                     threat = (pthreat) ? 6 : threat;
                     if (KDR_loc != null && KLR_loc != null) {  // check castle threat
                        if (this.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                       if (diff_klrh == 1 && diff_klrv == 1) {
                         if (KLR_loc.nv < ploc.nv && Piece.color_ == 'pdt') { pthreat1 = 1; }
                       }
                       if (diff_kdrh == 1 && diff_kdrv == 1) {
                         if (KDR_loc.nv > ploc.nv && Piece.color_ == 'plt') { pthreat1 = 1; }
                       }
                       threat = (pthreat1) ? -6 : threat;
                     }
                  } 
                  if (threat) { illegal_move("Move is endangering its own king (" + threat + ")!"); }
               }
          }
          return threat;
       }

       take_piece(location, color, code) {
           if (Board[location] != null ) { // Check if something to eat!
                 var board_ = Board[location];
                 if (board_.color_.match(color)) {
                     if (board_.role == 'K') {
                       illegal_move("Cannot eat king!");
                     } else
                     return EATPIECE;
                 } 
           }
           illegal_move("Illegal move " + code + "!");  
       }

       assertMove(location) {
         const locations = { oh: this.location_[0], ov: parseInt(this.location_[1]), 
                             nh: location[0],       nv: parseInt(location[1]) }
         if (this.role_ == "K") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h == 1) ||
                (diff_h == 0 && diff_v == 1) ||
                (diff_v == diff_h && diff_v == 1)) {
                if (Board[location] != null ) { // Check if something to eat!
                      if (this.color_ == "klt") {
                         return this.take_piece(location, /dt$/, '22');
                      } else
                      if (this.color_ == "kdt") {
                         return this.take_piece(location, /lt$/, '21');
                      }
                } else { return GOODMOVE; }
            } else // consider castling
            if (diff_v == 0 && diff_h == 2) {
                const this_nh = locations.nh.charCodeAt(0);
                const this_oh = locations.oh.charCodeAt(0);
                 if (this_oh < this_nh) {
                     const oh1 = String.fromCharCode(this_oh + 1);
                     const oh2 = String.fromCharCode(this_oh + 2);
                     if ((Board[oh1 + locations.nv] == null) &&
                         (Board[oh2 + locations.nv] == null) &&
                           this.oldlocation_ == null ) {
                        return CASTLESHORT;
                     } else { illegal_move("Illegal move (50)!"); }
                 } else {
                     const oh1 = String.fromCharCode(this_oh - 1);
                     const oh2 = String.fromCharCode(this_oh - 2);
                     if ((Board[oh1 + locations.nv] == null) &&
                         (Board[oh2 + locations.nv] == null) &&
                          this.oldlocation_ == null) {
                       return CASTLELONG;
                     } else { illegal_move("Illegal move (51)!"); }
                 }
            }
            else { illegal_move("Illegal move (20)!"); }
         } else // Queen
         if (this.role_ == "Q") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h > 0) ||
                (diff_h == 0 && diff_v > 0) || 
                (diff_v == diff_h && diff_v != 0)) {

                // check bishop-like obstruction
                if (diff_v == diff_h && diff_v != 0)
                for (let i=1; i < diff_v; i++) {
                  var oh = null, ov = null;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else {
                     oh = String.fromCharCode(this_oh - i);
                  }
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else {
                     ov = locations.ov - i;
                  }
                  if (Board[oh + ov] != null) {
                     illegal_move("Illegal move (33)!");
                  }
                }

                // check root-like obstruction
                if ((diff_v == 0 && diff_h > 0) ||
                   (diff_h == 0 && diff_v > 0))
                for (let i=1; i < ( (diff_v < diff_h) ? diff_h : diff_v ); i++) {
                  var oh = String.fromCharCode(this_oh), ov = locations.ov;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else
                  if (this_oh >this_nh) {
                     oh = String.fromCharCode(this_oh - i);
                  } else
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else
                  if (locations.ov > locations.nv) {
                     ov = locations.ov - i;
                  } else {
                     illegal_move("Illegal move (34)!");
                  }
                  if (Board[oh + ov] != null) {
                     illegal_move("Illegal move (35)!");
                  }
                }


                if (Board[location] != null ) { // Check if something to eat!
                      if (this.color_ == "qlt") {
                         return this.take_piece(location, /dt$/, '18');
                      } else
                      if (this.color_ == "qdt") {
                         return this.take_piece(location, /lt$/, '19');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (17)!"); }
         } else // Rook
         if (this.role_ == "R") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h > 0) ||
                (diff_h == 0 && diff_v > 0)) {

                // check rook obstruction
                for (let i=1; i < ( (diff_v < diff_h) ? diff_h : diff_v ); i++) {
                  var oh = String.fromCharCode(this_oh), ov = locations.ov;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else 
                  if (this_oh >this_nh) {
                     oh = String.fromCharCode(this_oh - i);
                  } else
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else
                  if (locations.ov > locations.nv) {
                     ov = locations.ov - i;
                  } else {
                     illegal_move("Illegal move (31)!");
                  }
                  if (Board[oh + ov] != null) {
                     illegal_move("Illegal move (32)!");
                  }
                }
                if (Board[location] != null ) { // Check if something to eat!
                      if (this.color_ == "rlt") {
                         return this.take_piece(location, /dt$/, '15');
                      } else
                      if (this.color_ == "rdt") {
                         return this.take_piece(location, /lt$/, '16');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (14)!"); }
         } else // Bishop
         if (this.role_ == "B") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const aha1 = String.fromCharCode(this_oh);
            const aha2 = String.fromCharCode(this_nh);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if (diff_v == diff_h && diff_v != 0) {
                // check bishop obstruction
                for (let i=1; i < diff_v; i++) {
                  var oh = null, ov = null;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else {
                     oh = String.fromCharCode(this_oh - i);
                  }
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else {
                     ov = locations.ov - i;
                  }
                  if (Board[oh + ov] != null) {
                     illegal_move("Illegal move (31)!"); 
                  }
                }
                if (Board[location] != null ) { // Check if something to eat!
                      if (this.color_ == "blt") {
                         return this.take_piece(location, /dt$/, '12');
                      } else
                      if (this.color_ == "bdt") {
                         return this.take_piece(location, /lt$/, '13');
                      }
                } else {
                       return GOODMOVE;
                }
            } 
            else { illegal_move("Illegal move (11)!"); }

         } else // if Knight
         if (this.role_ == "N") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            if (locations.ov + 2 == locations.nv || 
                locations.ov == locations.nv + 2) {
                if (this_nh == this_oh + 1 || this_nh + 1 == this_oh) {
                   if (Board[location] != null ) { // Check if something to eat!
                      if (this.color_ == "nlt") {
                         return this.take_piece(location, /dt$/, '8');
                      } else 
                      if (this.color_ == "ndt") {
                         return this.take_piece(location, /lt$/, '9');
                      }
                   } else {
                       return GOODMOVE;
                   }
                } else { return this.take_piece(location, "na", "5"); }
            } else
            if (this_nh + 2 == this_oh || 
                this_nh == this_oh + 2) {
                if (locations.nv == locations.ov + 1 || locations.nv + 1 == locations.ov) {
                   if (Board[location] != null ) { // Check if something to eat!
                      if (this.color_ == "nlt") {
                         return this.take_piece(location, /dt$/, '10');
                      } else 
                      if (this.color_ == "ndt") {
                         return this.take_piece(location, /lt$/, '11');
                      }
                   } else {
                       return GOODMOVE;
                   }
                } else { return this.take_piece(location, "na", "6"); }
            } 
            else { return this.take_piece(location, "na", "7"); }

         } else // if Pawn
         if (this.role_ == "P") {

             if (locations.oh == locations.nh) {
               if (this.color_ == "plt") {
                  if (( locations.ov == 2 && ( locations.nv == 3 || locations.nv == 4 ))) {
                     // check obstruction
                     if (locations.nv == 3 && Board[locations.oh + 3] != null) {
                          illegal_move("Illegal move (40)!");
                     } else
                     if (locations.nv == 4 && ( Board[locations.oh + 3] != null ||
                                                Board[locations.oh + 4] != null )) {
                          illegal_move("Illegal move (41)!");
                     }
                     return GOODMOVE;
                  } else if (locations.ov >= 3 && locations.ov + 1 == locations.nv && locations.nv <= 8) {
                     if ( Board[locations.oh + locations.nv] != null) {
                          illegal_move("Illegal move (42)!");
                     }
                     return GOODMOVE;
                  } else { 
                     illegal_move("Illegal pawn move (42a)!"); 
                  }
                } else {
                  if (( locations.ov == 7 && ( locations.nv == 6 || locations.nv == 5 ))) {
                     // check obstruction
                     if (locations.nv == 6 && Board[locations.oh + 6] != null) {
                          illegal_move("Illegal move (43)!");
                     } else
                     if (locations.nv == 5 && ( Board[locations.oh + 6] != null ||
                                                Board[locations.oh + 5] != null )) {
                          illegal_move("Illegal move (44)!");
                     }
                     return GOODMOVE;
                  } else if (locations.ov <= 6 && locations.ov - 1 == locations.nv && locations.nv >= 1) {
                     if ( Board[locations.oh + locations.nv] != null) {
                          illegal_move("Illegal move (45)!");
                     }
                     return GOODMOVE;
                  } else { 
                    illegal_move("Illegal pawn move (46)!"); 
                  }
                }
             } else { // (locations.oh != locations.nh) -- diagonal means eat
                 const this_nh = locations.nh.charCodeAt(0);
                 const this_oh = locations.oh.charCodeAt(0);
                 const diff_h = Math.abs(this_nh - this_oh); 
                 const diff_v = Math.abs(locations.ov - locations.nv);
                 if (diff_h > 1 || diff_v > 1) { illegal_move("Illegl pawn move (47)!"); }
                 if (Board[location] != null) { // something to eat?
                   if (this.color_ == "plt") {
                      if (locations.ov < locations.nv) { 
                        return this.take_piece(location, /dt$/,'48');
                      } else { illegal_move("Illegal move(54)"); }
                    } else {
                      if (locations.ov > locations.nv) { 
                         return this.take_piece(location, /lt$/,'49');
                      } else { illegal_move("Illegal move(55)"); }
                 
                    }
                 } else { // en passant?
                    log("en passant!!!");
                    if (LastPiece != null) {
                        const that = LastPiece;
                        const that_location = { nh: that.location_[0], nv: parseInt(that.location[1]),
                                                oh: that.oldlocation[0], ov: parseInt(that.oldlocation[1]) }
                        const this_nh = locations.nh.charCodeAt(0);
                        const this_oh = locations.oh.charCodeAt(0);
                        const that_nh = that_location.nh.charCodeAt(0);
                        const that_oh = that_location.oh.charCodeAt(0);
                        const diff_v = Math.abs(that_location.ov - that_location.nv);
                        const diff_h = Math.abs(that_nh - this_nh);
                        if (that_oh != that_nh || that.role != 'P' || 
                            diff_v != 2 || diff_h != 0 || that_location.nv != locations.ov )
                                { illegal_move("Illegal move(53)"); }
                
                        if (this.color_ == "plt") {
                            if (locations.ov < locations.nv) { 
                                return ENPASSANT;
                            } else { illegal_move("Illegal move(56)"); }
                        } else {
                            if (locations.ov > locations.nv) { 
                                return ENPASSANT;
                             } else { illegal_move("Illegal move(57)"); }
                        }
                    } else {
                       illegal_move("Illegal pawn move (52)!"); 
                    }
                 }
             }
         }
         return UNMOVE; 
        }
    }  // end Piece class

    // Get King pieces
    var Board = {}, Benched = [], Undo = [];

    function undoMove() {
      if (FETCHEDGAME_) return;
      undoitMove(); // for black
      undoitMove(); // for white
      --MOVECOUNT_;
      var span = 8
      for (var s = 1; s <=10; s++) {
         if (chessgame.lastChild) {
            chessgame.removeChild(chessgame.lastChild);
         }
      } 
    }

    function undoitMove(switchside = true) {
       if (Undo.length ==0 ) return;
       var move = Undo[Undo.length - 1], undone = false; 
       if (move.type == GOODMOVE) {
            piece = move.piece;
            Board[move.oloc] =  piece;
            Board[move.nloc] =  null;
            piece.piece.className = (EXPAND_) ? "piece p_" + reverseLoc(move.oloc) : "xpiece px_" + reverseLoc(move.oloc);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            if (move.promote) { const color = piece.color_.match(/lt$/);
                                piece.role_ = 'P'; 
                                piece.color_ = (color) ? 'plt' : 'pdt' ;
                                piece.piece.src = getImgSrc(piece.color_);
                              }
            undone = true; 
       } else
       if (move.type == EATPIECE) {
            piece = move.piece;
            bpiece = Benched.pop();
            bpiece.active_ = 1;
            bpiece.piece.style.visibility = ""
            bpiece.piece.display = "block"
            Board[move.oloc] =  piece;
            Board[bpiece.location_] =  bpiece;
            piece.piece.className = (EXPAND_) ? "piece p_" + reverseLoc(move.oloc) : "xpiece px_" + reverseLoc(move.oloc);
            bpiece.piece.className = (EXPAND_) ? "piece p_" + reverseLoc(bpiece.location) : "xpiece px_" + reverseLoc(bpiece.location);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            if (move.promote) { const color = piece.color_.match(/lt$/);
                                piece.role_ = 'P'; 
                                piece.color_ = (color) ? 'plt' : 'pdt' ;
                                piece.piece.src = getImgSrc(piece.color_);
                              }
            undone = true; 
       } else
       if (move.type == ENPASSANT) {
            piece = move.piece;
            bpiece = Benched.pop();
            bpiece.active_ = 1;
            bpiece.piece.style.visibility = ""
            bpiece.piece.display = "block"
            Board[move.oloc] =  piece;
            Board[move.nloc] = null;
            Board[bpiece.location_] =  bpiece;
            piece.piece.className = (EXPAND_) ? "piece p_" + reverseLoc(move.oloc) : "xpiece px_" + reverseLoc(move.oloc);
            bpiece.piece.className = (EXPAND_) ? "piece p_" + reverseLoc(bpiece.location) : "xpiece px_" + reverseLoc(bpiece.location);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            undone = true; 
       } else
       if (move.type == CASTLESHORT) {
            piece = move.piece;
            // king
            Board[move.oloc] =  piece;
            Board[move.nloc] =  null;
            piece.piece.className = (EXPAND_) ? "piece p_" + reverseLoc(move.oloc) : "xpiece px_" + reverseLoc(move.oloc);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            // rook
            var oloc_ = null, nloc_ = null;
            if (piece.color_.match(/lt$/)) {
                var oloc_ = "h1", nloc_ = "f1";
            } else {
                var oloc_ = "h8", nloc_ = "f8";
            }
            piece = Board[nloc_];
            Board[oloc_] =  piece;
            Board[nloc_] = null;
            Board[oloc_].piece.className = (EXPAND_) ? "piece p_" +  reverseLoc(oloc_) : "xpiece px_" + reverseLoc(oloc_);
            Board[oloc_].location_ = oloc_;
            Board[oloc_].oldlocation_ = null;
            undone = true; 
       } else
       if (move.type == CASTLELONG) {
           piece = move.piece;
            // king
            Board[move.oloc] =  piece;
            Board[move.nloc] =  null;
            piece.piece.className = (EXPAND_) ? "piece p_" + reverseLoc(move.oloc) : "xpiece px_" + reverseLoc(move.oloc);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            // rook
            var oloc_ = null, nloc_ = null;
            if (piece.color_.match(/lt$/)) {
                var oloc_ = "a1", nloc_ = "d1";
            } else {
                var oloc_ = "a8", nloc_ = "d8";
            }
            piece = Board[nloc_];
            Board[oloc_] =  piece;
            Board[nloc_] = null;
            Board[oloc_].piece.className = (EXPAND_) ? "piece p_" +  reverseLoc(oloc_) : "xpiece px_" + reverseLoc(oloc_);
            Board[oloc_].location_ = oloc_;
            Board[oloc_].oldlocation_ = null;
            undone = true; 
       }
       if (undone) {
            if (switchside) SIDETOMOVE_ = (SIDETOMOVE_ == WHITE) ? BLACK: WHITE; 
            ecoGame_.pop(); 
            Undo.pop();
       }
    }


    function reloadBoard() {

      // Initialize Board
      for (let v=1; v <= 8; v++) { 
        for (let h=0; h < 8; h++) { 
           const board = Board[horiz[h] + v];
           if (board != null) {
              const elem = board.piece;
              try {
               elem.parentNode.removeChild(elem); 
              } catch(e) { log(e) }
           }
           Board[horiz[h] + v] = null;
        }
      }

      for (var p in Benched) {
          const board = Benched[p];
          if (board != null) {
             const elem = board.piece;
             try {
               elem.parentNode.removeChild(elem); 
             } catch(e) { log(e) }
          }
          
      }

      const chessboard = document.getElementById("chessboard");
      // Dark placements
      const DKing    = new Piece("K", "kdt", "e8"); chessboard.appendChild(DKing.getpiece);    Board["e8"] = DKing;
      const DQueen   = new Piece("Q", "qdt", "d8"); chessboard.appendChild(DQueen.getpiece);   Board["d8"] = DQueen; 
      const DDBishop = new Piece("B", "bdt", "c8"); chessboard.appendChild(DDBishop.getpiece); Board["c8"] = DDBishop;
      const DLBishop = new Piece("B", "bdt", "f8"); chessboard.appendChild(DLBishop.getpiece); Board["f8"] = DLBishop;
      const DDKnight = new Piece("N", "ndt", "b8"); chessboard.appendChild(DDKnight.getpiece); Board["b8"] = DDKnight;
      const DLKnight = new Piece("N", "ndt", "g8"); chessboard.appendChild(DLKnight.getpiece); Board["g8"] = DLKnight;
      const DDRook   = new Piece("R", "rdt", "a8"); chessboard.appendChild(DDRook.getpiece);   Board["a8"] = DDRook;
      const DLRook   = new Piece("R", "rdt", "h8"); chessboard.appendChild(DLRook.getpiece);   Board["h8"] = DLRook;
      for (let i=0; i < 8; i++) { 
         const location = horiz[i] + "7";
         const pawn   = new Piece("P", "pdt", location); 
         chessboard.appendChild(pawn.getpiece); 
         Board[location] = pawn;
      }

      // Light placements
      const LKing    = new Piece("K", "klt", "e1"); chessboard.appendChild(LKing.getpiece);    Board["e1"] = LKing;
      const LQueen   = new Piece("Q", "qlt", "d1"); chessboard.appendChild(LQueen.getpiece);   Board["d1"] = LQueen;
      const LDBishop = new Piece("B", "blt", "c1"); chessboard.appendChild(LDBishop.getpiece); Board["c1"] = LDBishop;
      const LLBishop = new Piece("B", "blt", "f1"); chessboard.appendChild(LLBishop.getpiece); Board["f1"] = LLBishop;
      const LDKnight = new Piece("N", "nlt", "b1"); chessboard.appendChild(LDKnight.getpiece); Board["b1"] = LDKnight;
      const LLKnight = new Piece("N", "nlt", "g1"); chessboard.appendChild(LLKnight.getpiece); Board["g1"] = LLKnight; 
      const LDRook   = new Piece("R", "rlt", "a1"); chessboard.appendChild(LDRook.getpiece);   Board["a1"] = LDRook;
      const LLRook   = new Piece("R", "rlt", "h1"); chessboard.appendChild(LLRook.getpiece);   Board["h1"] = LLRook;
      for (let i=0; i < 8; i++) { 
        const location = horiz[i] + "2";
        const pawn   = new Piece("P", "plt", horiz[i] + "2"); 
        chessboard.appendChild(pawn.getpiece); 
        Board[location] = pawn;
      }
      
    }


    function find_bishop(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       for (var i = 1; i <= diff_nh; i++) {
          const h = (oh < nh) ? String.fromCharCode(oh + i) : String.fromCharCode(oh - i);
          const v = (ov < nv) ? (ov + i) : (ov - i);
          const apiece = Board[h + v];
          if ( i == diff_nh ) {  // same destination
              if (apiece != null && apiece.color_.slice(-2) == color) {
                    blocked = 1; _loc = null;
              } else { // eat or move
                    if (h + v == location)  { // found the target
                        if (src != null) { // now select piece, assuming multiple sources
                          if (loc == src || _oh == src || ov == src) { _loc = loc }
                        } else { _loc = loc } // otherwise, choose the only one source
                    }
             }
          } else { if (apiece != null)   { blocked = 1; _loc = null; } }
       }
       if (!blocked) {return _loc; }
       return null;
    }

    function find_rook(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       if (diff_nv == 0 && diff_nh > 0) {
            for (var i = 1; i <= diff_nh; i++) {
                const h = (oh < nh) ? String.fromCharCode(oh + i) : String.fromCharCode(oh - i);
                const apiece = Board[h + nv];
                  if ( i == diff_nh ) {  // same destination
                      if (apiece != null && apiece.color_.slice(-2) == color) {
                          blocked = 1; _loc = loc;
                      } else { // eat or move
                        if (h + nv == location)  { 
                           if (src != null) { // now select piece, assuming multiple sources
                              if (loc == src || _oh == src || ov == src) { _loc = loc }
                           } else { _loc = loc } // otherwise, choose the only one source
                        }
                      }
                  } else {
                      if (apiece != null) { blocked = 1; _loc = null; } 
                  }
            }
            if (!blocked) {return _loc; }
       } else
       if (diff_nh == 0 && diff_nv > 0) {
            const h = String.fromCharCode(nh);
            for (var i = 1; i <= diff_nv; i++) {
                const v = (ov < nv) ? (ov + i) : (ov - i);
                const apiece = Board[_oh + v];
                if ( i == diff_nv ) {  // same destination
                      if (apiece != null && apiece.color_.slice(-2) == color) {
                          blocked = 1; _loc = null;
                      } else { // eat or move
                        if (h + v == location)  { 
                           if (src != null) { // now select piece, assuming multiple sources
                              if (loc == src || _oh == src || ov == src) { _loc = loc }
                           } else { _loc = loc } // otherwise, choose the only one source
                        }
                      }
                } else { if (apiece != null) { blocked = 1; _loc = null; } }
            }
            if (!blocked) {return _loc; }
       }
       return null;
    }

    function find_knight(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       if ((diff_nh == 1 && diff_nv == 2) || 
           (diff_nh == 2 && diff_nv == 1)) {
         if (bpiece.color_.slice(-2) != color) {
            blocked = 1;
         } else {
            if (src != null) { // now select piece, assuming multiple sources
              if (loc == src || _oh == src || ov == src) { _loc = loc }
            } else { _loc = loc } // otherwise, choose the only one source
         } 
       }
       if (!blocked) { return _loc; }
       return null;
    }

    function find_location(color, role, location, hint = null, src = null) {
      const locs = [];
      for (var p in Board) {
        const bpiece = Board[p];
        if (bpiece != null) {
            const loc = bpiece.location;
            const oh    = loc[0].charCodeAt(0), ov = parseInt(loc[1]);
            const nh    = location[0].charCodeAt(0), nv = parseInt(location[1]);
            diff_nh = Math.abs(nh - oh); diff_nv = Math.abs(nv - ov);
            if ((color == 'lt' && bpiece.color.match(/lt$/)) || (color == 'dt' && bpiece.color.match(/dt$/)))  {
               if (bpiece.role == "K" && role == "K") {
                  locs.push(loc);
                } else 
                if (bpiece.role == "N" && role == "N") {
                  const floc = find_knight(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "B" && role == "B") {
                  const floc = find_bishop(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "R" && role == "R") {
                  const floc = find_rook(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "Q" && role == "Q") {
                  const floc1 = find_bishop(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc1 != null) locs.push(floc1);
                  const floc2 = find_rook(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc2 != null) locs.push(floc2);
                } else 
                if (bpiece.role == "P" && role.match(/[a-h]/) != null) {
                  if (diff_nh == 0 && (diff_nv == 1 || diff_nv == 2)) {
                     const bpiece1 = Board[String.fromCharCode(oh) + ((color == 'lt') ? (ov + 1) : (ov - 1))];
                     if (bpiece1 != null) { continue }; // there is a block.
                     if (hint == null) { // moving
                       if (color == 'dt' && ov > nv) { locs.push(loc); }
                       if (color == 'lt' && ov < nv) { locs.push(loc); }
                    }
                  } else
                  if (diff_nh == 1 && diff_nv == 1) {
                     if (hint != null && hint == "x") { // eating
                        const loc1 = loc[0];
                        if (loc[0] == role) {
                           if (color == 'dt' && ov > nv) { locs.push(loc); }
                           if (color == 'lt' && ov < nv) { locs.push(loc); }
                        }
                     }
                  } 
                }
            }
        }
      }
      return locs;
    }

    // Audio
    function playawalker() {
       // const audio = new Audio("/audio/AlanWalker.mp3");
       const audio = new Audio("/audio/shortawalker.mp3");
       audio.volume = 0.5;
       return audio;
    }

    function chessreset() {
       const audio = new Audio("/audio/chessreset.mp3");
       audio.volume = 1.0;
       return audio;
    }
    function chesscastle() {
       const audio = new Audio("/audio/chesscastle.mp3");
       audio.volume = 1.0;
       return audio;
    }
    function chessmove() {
       const audio = new Audio("/audio/chessmove.mp3");
       audio.volume = 1.0;
       return audio;
    }
    function chesscapture() {
       const audio = new Audio("/audio/chesscapture.mp3");
       audio.volume = 1.0;
       return audio;
    }

    var PLAY_AW_ = false;
    function playAW() {
        PLAY_AW_ = (PLAY_AW_) ? false: true;
        const music_ = document.getElementById("musicid");
        if (PLAY_AW_) { 
            music_.innerHTML = "&#9834;";
            chess_awalker.playbackRate = 1.0;
         } else  { 
            music_.innerHTML = "&#9632;";
            chess_awalker.pause(); chess_awalker.currentTime = 0 
         };
    } 

    // audio objects
    const chess_awalker = playawalker();
    const chess_move = chessmove();
    const chess_capture = chesscapture();
    const chess_castle = chesscastle();
    const chess_reset = chessreset();

    var parser = null;
    async function loadParser() {
        const res = await fetch('/jscripts/pgngrammar.pegjs');
        const grammer = await res.text();
        parser = PEG.buildParser(grammer);
    }


    const pause = time => new Promise(resolve => setTimeout(resolve, time))
    const musictime_ = document.getElementById("musictimeid");
    var MUSIC_TIME = musictime_.value;

    function movePiece(cl, move, spanmove, sound = true) {
        var src_loc = null, dest_loc = null, role = null, src = null, hint = null;
        var piece = (cl == 'lt') ? move.white : move.black;  
        var len = piece.length;

        role = piece[0]; 
        dest_loc = piece.slice(-2);


        if (piece == "O-O") {
             src_loc = [ (cl == 'lt') ? "e1" : "e8" ]; dest_loc = (cl == 'lt') ? "g1" : "g8";
        } else
        if ( piece == "O-O-O") {
             src_loc = [ (cl == 'lt') ? "e1" : "e8" ]; dest_loc = (cl == 'lt') ? "c1" : "c8";
        } else if (len == 2) {
             dest_loc = piece;
             src_loc = find_location(cl, piece[0], dest_loc);
        } else if (len == 3) {
             src_loc = find_location(cl, role, dest_loc);
        } else
        if (len == 4) { // e.g. Rxe1 exd1 Rhe1
             hint = piece[1];
             if (hint != 'x') { hint = null; src = piece[1]; }
             src_loc = find_location(cl, role, dest_loc, hint, src);
        } else
        if (len == 5) { // e.g. Rhxe1 R8xe1  Nh8g6
             hint = piece[2];
             if (hint == 'x') {
                   src = piece[1];
             } else {
                   hint = null;
                   src = piece.slice(1,3).match(/[a-h][1-8]/)[0]
             }
             src_loc = find_location(cl, role, dest_loc, hint, src);
        } else
        if (len == 6) { // e.g. Rh8xe1
             src = piece.slice(1,3); hint = piece[3];
             src_loc = find_location(cl, role, dest_loc, hint, src);
        }
        if (src_loc.length < 1) illegal_move('Illegal move (99)!');
        log("Final " + cl + " location: " + src_loc + " " + dest_loc);
        if (spanmove != null) { spanmove.className = "chesspiecenomove"; }
        const mid = (cl == 'lt') ? "moveidl" : "moveidd"
        spanmove = document.getElementById( mid + move.step);
        if (spanmove != null) spanmove.className = "chesspiecemove";
        place(src_loc, dest_loc, (cl == 'lt') ? move.wpromote : move.bpromote, sound);
        return spanmove;
    }

    
    var F_WELO_OPS_ = null, F_BELO_OPS_ = null, F_MOVES_OPS_ = null, 
        F_WELO_ = null, F_BELO_ = null, F_MOVES_ = null, F_RES1_ = null, F_RES2_ = null, F_RES3_ = null;
    function filterPlay() {
        f_welo_ops = document.getElementById("filter_welo_ops");
        f_belo_ops = document.getElementById("filter_belo_ops");
        f_moves_ops = document.getElementById("filter_moves_ops");
        f_welo = document.getElementById("filter_welo");
        f_belo = document.getElementById("filter_belo");
        f_moves = document.getElementById("filter_moves");

        f_res1 = document.getElementById("filter_res1");
        f_res2 = document.getElementById("filter_res2");
        f_res3 = document.getElementById("filter_res3");

        F_WELO_OPS_ = f_welo_ops.options[f_welo_ops.selectedIndex].value;
        F_BELO_OPS_ = f_belo_ops.options[f_belo_ops.selectedIndex].value;
        F_MOVES_OPS_ = f_moves_ops.options[f_moves_ops.selectedIndex].value;

        F_WELO_ = f_welo.value; F_BELO_ = f_belo.value; F_MOVES_ = f_moves.value;
        F_RES1_ = (f_res1.checked) ? f_res1.value : null;
        F_RES2_ = (f_res2.checked) ? f_res2.value : null;
        F_RES3_ = (f_res3.checked) ? f_res3.value : null;
    }

    var ECO_ = null;
    async function loadECO() {
        const res = await fetch('/jscripts/eco2.pgn');
        var eco = await res.text();
        eco = eco.split(/\n/);
        const eco_ = []
        for (var p in eco) {
            const variation = eco[p].replace(/"/g,"").replace(/[ ]+/g, " ").split("~");
            variation[variation.length-1] = variation[variation.length-1].replace(/([0-9]+\.) /g, "$1");
            eco_.push(variation);
        }
        ECO_ = eco_;
    }

    function findECO(eco, moves) {
        var eco_ = null;
        for (p in ECO_) {
          var peco = ECO_[p];
          if (peco[0] == eco) {
             eco_ = { eco: peco[0], variation: peco[2], opening:  peco[1] }
             break;
          }
        }
        return eco_; 
    }


    function moveIt(step = null, move) {
        const wmove = move.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, '');

        const comment = "";
        const movespan0 = document.createElement("span");
        const movespan1 = document.createElement("span");
        const movespan2 = document.createElement("span");
        const movespace1 = document.createTextNode(" ");
        const movechk1 = document.createElement("span"); movechk1.innerHTML = ""; movechk1.className = 'chesscmt';
        const movecmt1 = document.createElement("span"); movecmt1.innerHTML = ""; movecmt1.className = 'chesscmt';

        if (step != null) { movespan0.innerHTML = step + "."; } 
        movespan1.innerHTML = wmove; movespan1.id = "moveidl" + (step != null ? step : "b");
        movespan0.className = "chesspiecestep";
        movespan1.className = "chesspiecenomove";

        chessgame.appendChild(movespan0);
        chessgame.appendChild(movespan1);
        chessgame.appendChild(movechk1);
        chessgame.appendChild(movecmt1);
        chessgame.appendChild(movespace1);
        ecoGame_.push( movespan0.innerHTML + move.replace(/P/g, '') );
    }     


    var PLAYBUTTON = null, PLAYING = false, INTERRUPT = false, MOVETRACKER_ = null;
    var CHESSMOVES_ = [], CURRENTGAME_ = null, CURRENTCOLOR_ = null;
    async function initializePlay(n) {

        const game = Games[n];
        if (typeof(game) == "undefined") return;
        const pmoves = parser.parse(game.moves)[0];

        // reload Board
        reloadBoard();

        // populate header
         const wplayer = document.getElementById("whiteplayer");
         const bplayer = document.getElementById("blackplayer");
         const welo    = document.getElementById("whiteelo");
         const belo    = document.getElementById("blackelo");
         const eventid = document.getElementById("eventid");
         const dateid  = document.getElementById("dateid");
         const resid   = document.getElementById("resultid");
         eventid.innerHTML = game.ev + " (" + game.si + ")";
         dateid.innerHTML = game.dt;
         wplayer.innerHTML = game.wp; 
         bplayer.innerHTML = game.bp;
         welo.innerHTML = "(" + game.we + ")";
         belo.innerHTML = "(" + game.be + ")";
         resid.innerHTML = game.rt;

         // get eco
         const ecoid   = document.getElementById("ecoid");
         const openingid   = document.getElementById("openingid");
         const variationid   = document.getElementById("variationid");
         const eco_ = findECO(game.eco, game.moves);
         ecoid.innerHTML       = eco_.eco;
         openingid.innerHTML   = eco_.opening;
         variationid.innerHTML = eco_.variation.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, '');

        // populate moves
        chessgame.innerHTML = "";
        var moves = CHESSMOVES_ = [];
        for (g in pmoves) {
           const move = pmoves[g][0];
           const wmove = move[2][0].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                       replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                       replace(/R/g,'&#9814;');
           const bmove = move[4][0].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                       replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                       replace(/R/g,'&#9814;');

           const comment = pmoves[g][1];
           const movespace1 = document.createTextNode(" ");
           const movespace2 = document.createTextNode("  ");
           const movespan0 = document.createElement("span");
           const movespan1 = document.createElement("span");
           const movespan2 = document.createElement("span");
           const movechk1 = document.createElement("span"); movechk1.innerHTML = move[2][2]; movechk1.className = 'chesscmt';
           const movechk2 = document.createElement("span"); movechk2.innerHTML = move[4][2]; movechk2.className = 'chesscmt';
           const movecmt1 = document.createElement("span"); movecmt1.innerHTML = move[2][3]; movecmt1.className = 'chesscmt';
           const movecmt2 = document.createElement("span"); movecmt2.innerHTML = move[4][3]; movecmt2.className = 'chesscmt';

           movespan0.innerHTML = move[0] + ".";
           movespan1.innerHTML = wmove; movespan1.id = "moveidl" + move[0];
           movespan2.innerHTML = bmove; movespan2.id = "moveidd" + move[0];
           movespan0.className = "chesspiecestep";
           movespan1.className = "chesspiecenomove";
           movespan2.className = "chesspiecenomove";
           movespan1.onclick = jumpPlay; movespan1.internal_ = { tracker_: g, color: 'lt' }
           movespan2.onclick = jumpPlay; movespan2.internal_ = { tracker_: g, color: 'dt' }
           chessgame.appendChild(movespan0);
           chessgame.appendChild(movespan1);
           chessgame.appendChild(movechk1);
           chessgame.appendChild(movecmt1);
           chessgame.appendChild(movespace1);
           chessgame.appendChild(movespan2);
           chessgame.appendChild(movechk2);
           chessgame.appendChild(movecmt2);
           chessgame.appendChild(movespace2);
           CHESSMOVES_.push({ step: move[0], white: move[2][0], black: move[4][0], 
                    wpromote: move[2][1], bpromote: move[4][1], wcheck: move[2][2], bcheck: move[4][2] });
        }
        const movespace3 = document.createTextNode("   ");
        const movespan3 = document.createElement("span");
        movespan3.className = "chesspiecers";
        movespan3.style.color = "#1255b3";
        movespan3.innerHTML = " " + game.rt;
        chessgame.appendChild(movespace3);
        chessgame.appendChild(movespan3);
        return moves;
     }

    function place(where, location, promote = null, sound = true) {
        if (where.length > 1) { // multiple
          for (p in where) {
            const where_ = where[p];
            if (Board[where_] != null) {
                Board[where_].move = { location: location, promote: promote } ;
                if (sound) chess_move.play();
                return Board[where_];
            }
          }
        } else {
            Board[where].move = { location: location, promote: promote } ;
            if (sound) chess_move.play();
            return Board[where_];
        }
    }

    function showGame(obj) {
       var g = obj.innerHTML;
       g = g.replace(". ", ""); 
       const game_ = document.getElementById("gametrid" + g);
       game_.scrollIntoView();
    }

     // start playing
     async function play(bt) {
        if (PLAYING || REPEATPLAY_) { return };
        if (MOVETRACKER_ != null && moves.length == parseInt(MOVETRACKER_) + 1) { MOVETRACKER_ = '-1' };
        var current_ = document.getElementById("currentgameid");

        var INT_TRACKER = MOVETRACKER_, spanmove = null;
        PLAYING = true;
        CURRENTGAME_ = bt.value;
        current_.innerHTML = (parseInt(CURRENTGAME_) + 1) + ". ";

        moves = await initializePlay(CURRENTGAME_);
        if (INT_TRACKER == null || INT_TRACKER == '-1') await pause(MUSIC_TIME);
        chess_move.volume = 1.0;
        bt.parentNode.parentNode.className = "chesstr chesstrcurrent";
        for (g in moves) {

           if (INTERRUPT || LOADPGN_) { break; }
           if (INT_TRACKER != null && INT_TRACKER != '-1') {
              spanmove =  await movePiece('lt', moves[g], spanmove); 
              spanmove =  await movePiece('dt', moves[g], spanmove); 
              if (INT_TRACKER == g) {
                  INT_TRACKER = null;
                  if (CURRENTCOLOR_ == 'lt') await pause(MUSIC_TIME); 
              }
              continue;
           }
           MOVETRACKER_ = g;
           spanmove =  await movePiece('lt', moves[g], spanmove);
           await pause(MUSIC_TIME); CURRENTCOLOR_ = 'lt';
           spanmove =  await movePiece('dt', moves[g], spanmove);
           if (g > 127 || g == 1) spanmove.scrollIntoView();
           await pause(MUSIC_TIME); CURRENTCOLOR_ = 'dt';
        }

        // chess_awalker.pause();
 
        // release playing status
        PLAYING = false; INTERRUPT = false;  LOADPGN_ = false;
        bt.innerHTML = "&#8594;"
        bt.onclick = proceedPlay;
    }

    // interrupt play
    var int_interval = 0, playtime = null;
    function readyPlay(bt) {
        int_interval += 1;
        if (int_interval > 20) { int_interval = 0; clearInterval(playtime)  }
        if (!INTERRUPT) {
           int_interval = 0;
           clearInterval(playtime);
           if (PLAYBUTTON != null && PLAYBUTTON.value != bt.value) {
              PLAYBUTTON.innerHTML = "&#8594;";
              PLAYBUTTON.onclick = proceedPlay;
              MOVETRACKER_ = null; CURRENTCOLOR_ = null;
              PLAYBUTTON.parentNode.parentNode.className = "chesstr";
           }
           bt.innerHTML = "&#9675;";
           bt.onclick = interruptPlay;
           PLAYBUTTON = bt;
           play(bt);
        }
    }

    function proceedPlay() {
        const bt = this;
        if (REPEATPLAY_) return;
        if (PLAYING && !INTERRUPT) {
            INTERRUPT = true;
            playtime = setInterval(readyPlay, 50, this);
        } else if (!PLAYING && !INTERRUPT) {
            if (PLAYBUTTON != null && PLAYBUTTON.value != bt.value) {
               MOVETRACKER_ = null; CURRENTCOLOR_ = null;
               PLAYBUTTON.parentNode.parentNode.className = "chesstr";
           }
           if (REPEATBUTTON_ != null) REPEATBUTTON_.parentNode.parentNode.className = "chesstr";
           bt.innerHTML = "&#9675;";
           bt.onclick = interruptPlay;
           PLAYBUTTON = bt;
           play(bt);
        }
    }

    function interruptPlay() {
        if (REPEATPLAY_) return;
        const bt = this;
        bt.innerHTML = "&#8594;";
        bt.onclick = proceedPlay;
        INTERRUPT = true; // this will trigger the async play function to quit
    }

    function keyPress() { document.onkeydown = keyPlay; }

    async function keyPlay(e) {
        e = e || window.event;
       if (PLAYING || REPEATPLAY_) return;
       if (e.keyCode == '38') { // up
       }
       else if (e.keyCode == '40') { // down
       }
       else if (e.keyCode == '37') { // left
         backwardPlay();
       }
       else if (e.keyCode == '39') {  // right
         forwardPlay();
       }
    }

    // calculate time
    function calcTime(timer, start) {
        const sec = ( Date.now() - start ) / 1000;
        const hr = Math.floor(sec / 3600);
        const min = (sec % 3600) / 60;
        timer.innerHTML = hr + ":" + min.toFixed(1);
    }

    // repeat Play
    var REPEATPLAY_ = false, REPEATWHERE_ = null, REPEATBUTTON_ = null;
    async function repeatPlay() {
       if (PLAYING) return;
       var current_ = document.getElementById("currentgameid");
       var limit = document.getElementById("limitmoveid");
       var repeatbt = document.getElementById("repeatid");
       if (Games.length > 0) {
         const len_ = Games.length;
         REPEATPLAY_ = true;
         repeatbt.innerHTML = "&#10074;&#10074;";
         repeatbt.onclick = interruptRepeat;
         if (PLAYBUTTON != null) { REPEATWHERE_ = PLAYBUTTON.value; }
         if (PLAY_AW_) { chess_awalker.volume = 1.0; chess_move.volume = 0.0 } else { chess_move.volume = 1.0 }
         var start = Date.now();
         const timer = document.getElementById('timerid');
          
         for (var i=0; i < len_; i++) {
           const bt = document.getElementById("gameid" + i);
           if (bt != null) { 
             if (LOADPGN_) {
                  bt.innerHTML = "&#8594;";
                  bt.onclick = proceedPlay;
                  repeatbt.innerHTML = "&#9654;";
                  repeatbt.onclick = repeatPlay;
                  REPEATWHERE_ = null; LOADPGN_ = false;
                  return;
             } else
             if (REPEATPLAY_ ==  false) { 
                  bt.innerHTML = "&#8594;";
                  bt.onclick = proceedPlay;
                  repeatbt.innerHTML = "&#9654;";
                  repeatbt.onclick = repeatPlay;
                  REPEATWHERE_=i; 
                  return; 
             }
             if (REPEATWHERE_ != null) { if (i!=REPEATWHERE_) { continue; } else { REPEATWHERE_ = null }}
             if (REPEATBUTTON_!= null) {  
                REPEATBUTTON_.parentNode.parentNode.className = "chesstr"; 
                REPEATBUTTON_.scrollIntoView();
             }
             current_.innerHTML  = (parseInt(i) + 1) + ". ";
             bt.innerHTML = "&#9675;"; 
             bt.onclick = interruptPlay;
             bt.parentNode.parentNode.className = "chesstr chesstrcurrent"; 
             REPEATBUTTON_ = bt;

             calcTime(timer, start);
             const moves = await initializePlay(i);
             await pause(MUSIC_TIME * 1);
         
             var spanmove = null, cnt_mv = 0;
             for (g in moves) {
                 if (LOADPGN_) {
                   REPEATWHERE_ = null; LOADPGN_ = false;
                   bt.innerHTML = "&#8594;";
                   bt.onclick = proceedPlay;
                   repeatbt.innerHTML = "&#9654;";
                   repeatbt.onclick = repeatPlay;
                   return;
                 } else
                 if (REPEATPLAY_ ==  false) { 
                      bt.innerHTML = "&#8594;";
                      bt.onclick = proceedPlay;
                      repeatbt.innerHTML = "&#9654;";
                      repeatbt.onclick = repeatPlay;
                      REPEATWHERE_=i; 
                      return; 
                 }
                 if (PLAY_AW_) {  chess_awalker.play(); chess_move.volume = 0.0; } else { chess_move.volume = 1.0 }
                 spanmove =  await movePiece('lt', moves[g], spanmove);
                 await pause(MUSIC_TIME); CURRENTCOLOR_ = 'lt';
                 spanmove =  await movePiece('dt', moves[g], spanmove);
                 await pause(MUSIC_TIME); CURRENTCOLOR_ = 'dt';
                 if (g > 127 || g == 1) spanmove.scrollIntoView();
                 cnt_mv += 1;
                 if (cnt_mv >= limit.value) break; 
             }
             bt.innerHTML = "&#8594;";
             bt.onclick = proceedPlay;
             await pause(MUSIC_TIME * 1.124);
           }
         }
         repeatbt.innerHTML = "&#9654;";
         repeatbt.onclick = repeatPlay;
         REPEATWHERE = null;
       }
    }

    function interruptRepeat() {
         REPEATPLAY_ = false;    
         chess_awalker.pause();
    }

    async function jumpMove(sound=true) {

        moves = await initializePlay(CURRENTGAME_);

        var spanmove = null, stoptracker_ = MOVETRACKER_;
        for (g in moves) {
           spanmove =  await movePiece('lt', moves[g], spanmove, sound); 
           if (g == stoptracker_) {
               if (CURRENTCOLOR_ == 'dt') spanmove =  await movePiece('dt', moves[g], spanmove, sound);
               break;
           }
           spanmove =  await movePiece('dt', moves[g], spanmove, sound);
        }
        return { moves: moves, spanmove: spanmove } 
    }


    var jmp_interval = 0, jumptime = null;
    async function readyJump(obj) {
        jmp_interval += 1;
        if (jmp_interval > 20) { jmp_interval = 0; clearInterval(jumptime)  }
        if (!PLAYING) {
          jmp_interval = 0;
          clearInterval(jumptime);
          MOVETRACKER_ = obj.internal_.tracker_;
          CURRENTCOLOR_ = obj.internal_.color;
          return await jumpMove();
        }
    } 

    async function jumpPlay() {
        if (REPEATPLAY_) return;
        if (PLAYING) {
          INTERRUPT = true;
          jumptime = setInterval(readyJump, 50, this);
        } else {
          const obj = this;
          MOVETRACKER_ = obj.internal_.tracker_;
          CURRENTCOLOR_ = obj.internal_.color;
          return await jumpMove();
        }
    }

    // forward Play
    async function forwardPlay() {
        if (REPEATPLAY_) return;
        if (PLAYING) return;
        var len_ = CHESSMOVES_.length, tracker_ = parseInt(MOVETRACKER_);
        if (CURRENTCOLOR_ == 'dt') { tracker_ += 1; }
        if (tracker_ < 0) tracker_ = -1;
        if (tracker_ < len_) {
            var new_tracker_ = String(tracker_);
            CURRENTCOLOR_ = (CURRENTCOLOR_ == 'dt') ? 'lt' : 'dt';
            MOVETRACKER_ = new_tracker_;
            await jumpMove();
         }
    }

    async function backwardPlay() {
        if (REPEATPLAY_) return;
        if (PLAYING) return;
        var tracker_ = parseInt(MOVETRACKER_);
        if (tracker_ < 0) return;
        var len_ = CHESSMOVES_.length, tracker_ = parseInt(MOVETRACKER_);
        if (CURRENTCOLOR_ == 'lt') { tracker_ -= 1; }
        if (tracker_ >= 0 ) {
            var new_tracker_ = String(tracker_);
            CURRENTCOLOR_ = (CURRENTCOLOR_ == 'dt') ? 'lt' : 'dt';
            MOVETRACKER_ = new_tracker_;
            await jumpMove();
        } else {
            resetGame(sound=false);
        }
    }


    async function resetGame(sound=true) {
        if (REPEATPLAY_) return;
        if (PLAYING) return;
        if (MOVETRACKER_ == '-1' || MOVETRACKER_ == null) return;
        MOVETRACKER_ = '-1'; CURRENTCOLOR_ = 'dt';
        moves = await initializePlay(CURRENTGAME_);
        if (sound) { chess_reset.play();} else { chess_move.play(); }
    }

    async function endGame() {
        if (REPEATPLAY_) return;
        if (PLAYING) return;
        var len_ = CHESSMOVES_.length;
        MOVETRACKER_ = String(len_ - 1);
        CURRENTCOLOR_ = 'dt';
        await jumpMove();
    }

    function evalFilter(game) {
       var filter_ = true ;
       var moves_ = game.moves.split(' ').length - 4; moves_ = Math.floor(moves_ / 2); 
       if (F_WELO_OPS_ == "=") if (parseInt(game.we) != parseInt(F_WELO_)) filter_ = false;
       if (F_WELO_OPS_ == ">=") if (parseInt(game.we) < parseInt(F_WELO_)) filter_ = false;
       if (F_WELO_OPS_ == "<=") if (parseInt(game.we) > parseInt(F_WELO_)) filter_ = false;

       if (F_BELO_OPS_ == "=") if (parseInt(game.we) != parseInt(F_BELO_)) filter_ = false ;
       if (F_BELO_OPS_ == ">=") if(parseInt(game.we) < parseInt(F_BELO_))  filter_ = false;
       if (F_BELO_OPS_ == "<=") if(parseInt(game.we) > parseInt(F_BELO_))  filter_ = false;

       if (F_MOVES_OPS_ == "=") if (moves_ != parseInt(F_MOVES_))  filter_ = false;
       if (F_MOVES_OPS_ == ">=") if (moves_ < parseInt(F_MOVES_)) filter_ = false;
       if (F_MOVES_OPS_ == "<=") if (moves_ > parseInt(F_MOVES_))  filter_ = false;

       if (F_RES1_ == null) if (game.rt == "1-0")  filter_ = false;
       if (F_RES2_ == null) if (game.rt == "0-1")  filter_ = false;
       if (F_RES3_ == null) if (game.rt == "1/2-1/2")  filter_ = false;

       return filter_;
    }

    function sortGames(g1, g2) {
         var res = 0, ORDER = 0;
         for (var i=1; i<=6; i++) {
           ORDER = ORDERS_[i-1];
           if (ORDER != 0) {
              if (ORDER == 1) {
                  if (i == 1)  res =  ((g2.wp) > (g1.wp)) ? 1 : -1;
                  if (i == 2)  res =  ((g2.we) > (g1.we)) ? 1 : -1;
                  if (i == 3)  res =  ((g2.bp) > (g1.bp)) ? 1 : -1;
                  if (i == 4)  res =  ((g2.be) > (g1.be)) ? 1 : -1;
                  if (i == 5)  res =  ((g2.rt) > (g1.rt)) ? 1 : -1;
                  if (i == 6)  res =  ((g2.ct) > (g1.ct)) ? 1 : -1;
              } else
              if (ORDER == 2) {
                  if (i == 1)  res =  ((g2.wp) < (g1.wp)) ? 1 : -1;
                  if (i == 2)  res =  ((g2.we) < (g1.we)) ? 1 : -1;
                  if (i == 3)  res =  ((g2.bp) < (g1.bp)) ? 1 : -1;
                  if (i == 4)  res =  ((g2.be) < (g1.be)) ? 1 : -1;
                  if (i == 5)  res =  ((g2.rt) < (g1.rt)) ? 1 : -1;
                  if (i == 6)  res =  ((g2.ct) < (g1.ct)) ? 1 : -1;
              }
          }
         }
         return res;
    }

    // order List // &#8593; up // &#8595; down // &#8597; neutral
    // 0 = no order, 1 = descending, 2 = ascending
    const ORDERS_ = [0,0,0,0,0,0];
    const ORDERSDESC_ = ["White Side","Elo","Black Side","Elo","Result","Cnt"];
    function orderGame() {
       if (PLAYING || REPEATPLAY_) return;
       var bt = this; 
       var ORDER_ = 0, HTML = "";
       const OGames = Games;
       for (var i=1; i<=6; i++) {
         if (bt.value == i) {
             ORDER_ = ORDERS_[i-1];
             if (ORDER_ == 0) { HTML = "&#8595;"; ORDER_ = 1; } else  // change to 1
             if (ORDER_ == 1) { HTML = "&#8593;"; ORDER_ = 2; } else // change to 2
             if (ORDER_ == 2) { HTML = "&#8595;"; ORDER_ = 1; } // change to 1
             ORDERS_[i-1] = ORDER_;
             bt.innerHTML = ORDERSDESC_[i-1] + HTML;
         } else { 
             ORDERS_[i-1] = 0;
             bt.innerHTML = ORDERSDESC_[i-1] + "&#8597;";
         }
       }
       const ordered = Games.sort(sortGames);
       Games = ordered;
       refreshGames(true, bt.value);
    }

    // Now load a PGN
    var Games = [];
    async function fetchPGN(pgn_){
        const res = await fetch(pgn_);
        const pgngame = await res.json();
        Games = [];

        class Game {
           constructor (game) {
           var moves_ = game.moves.split(' ').length - 4; moves_ = Math.floor(moves_ / 2); 
           game.ct = moves_;
           this.detail_ = game;
 
         }
           get detail()  { return this.detail_; }
        }

        for (let i=0; i < pgngame.length; i++) {
             const game = new Game(pgngame[i])
             Games.push(game.detail)
        }
        if (Games.length > 0) {   
          // Disable Engine
          ENGINEGAME_ = false; FETCHEDGAME_ = true;
          refreshGames(false, null);
        }
     }

    var FETCHEDGAME_ = false;
     function refreshGames(sorted = false, bttn_ = null) {
        // populate html
        const chesstable = document.getElementById("chesstableid");
        const tbody = document.createElement('tbody');

        if (chesstable.firstChild != null) {
            chesstable.replaceChild(tbody, chesstable.firstChild);
        } else {
            chesstable.appendChild(tbody);
        }

        var td = null, txtnode;
        var game_cnt = 0;
        filterPlay();
        for (var p in Games) {
            const game = Games[p]
           if (game.we != "" && game.be != "") {
            if (evalFilter(game) ==  false) continue;
            game_cnt += 1;
            // var moves_ = game.moves.split(' ').length - 4; moves_ = Math.floor(moves_ / 2); 
            if (game_cnt == 1) {
              const tr1 = document.createElement("tr");
              const td1 = document.createElement("td"); td1.appendChild(document.createTextNode(""));
              const td2 = document.createElement("td"); td2.appendChild(document.createTextNode(""));
              const td3 = document.createElement("td"); td3.appendChild(document.createTextNode(""));
              const td4 = document.createElement("td"); td4.appendChild(document.createTextNode(""));
              const tdowp  = document.createElement("td"); const owp = document.createElement("button");
              const tdowe  = document.createElement("td"); const owe = document.createElement("button");
              const tdobp  = document.createElement("td"); const obp = document.createElement("button");
              const tdobe  = document.createElement("td"); const obe = document.createElement("button");
              const tdort  = document.createElement("td"); const ort = document.createElement("button");
              const tdocnt = document.createElement("td"); const ocnt = document.createElement("button");
              // #8593; up // &#8595; down
              tdowp.appendChild(owp); tdowe.appendChild(owe); tdobp.appendChild(obp); 
              tdobe.appendChild(obe); tdort.appendChild(ort); tdocnt.appendChild(ocnt);
              const bts_ = [ owp, owe, obp, obe, ort, ocnt ];
              for (var i=1; i<=6; i++ ) {
                  const bt_ = bts_[i-1];
                  bt_.onclick = orderGame;
                  bt_.value = i;
                  bt_.innerHTML = ORDERSDESC_[i-1] + "&#8597;"; 
                  if (sorted && bttn_ == i) {
                    if (ORDERS_[i-1] == 1) bt_.innerHTML = ORDERSDESC_[i-1] + "&#8595;"; else
                    if (ORDERS_[i-1] == 2) bt_.innerHTML = ORDERSDESC_[i-1] + "&#8593;"; 
                  }
              }
              tr1.appendChild(td1);
              tr1.appendChild(td2);
              tr1.appendChild(tdowp); tr1.appendChild(tdowe);
              tr1.appendChild(tdobp); tr1.appendChild(tdobe);
              tr1.appendChild(tdort); 
              tr1.appendChild(td3);
              tr1.appendChild(td4);
              tr1.appendChild(tdocnt);
              tdowp.className = "chesstdp"; tdobp.className = "chesstdp"; 
              tdowe.className = "chesstdl"; tdobe.className = "chesstdl"; 
              td1.className = "chesstdb"; td2.className = "chesstdb";
              td3.className = "chesstce"; td4.className = "chesstde";
              tdort.className = "chesstdb";
              tr1.className = "chesstr"; 
              tbody.appendChild(tr1);
            }

            const tr = document.createElement("tr");

            const tdcnt = document.createElement("td"); const cnt = document.createTextNode(game_cnt);
            const tdev = document.createElement("td"); const ev = document.createTextNode(game.ev.slice(0,35));
            const tdwp = document.createElement("td"); const wp = document.createTextNode(game.wp.slice(0,23));
            const tdbp = document.createElement("td"); const bp = document.createTextNode(game.bp.slice(0,23));
            const tdwe = document.createElement("td"); const we = document.createTextNode(game.we);
            const tdbe = document.createElement("td"); const be = document.createTextNode(game.be);
            const tdrt = document.createElement("td"); const rt = document.createTextNode(game.rt);
            const tdbt = document.createElement("td"); const bt = document.createElement("button"); 
            const tdec = document.createElement("td"); 
            const ec = document.createTextNode(typeof game.eco === "undefined" ? "" : game.eco); 

            const tdct = document.createElement("td"); const ct = document.createTextNode(game.ct);
            tdev.appendChild(ev); tdcnt.appendChild(cnt);
            tdwp.appendChild(wp); tdbp.appendChild(bp); tdwe.appendChild(we); 
            tdbe.appendChild(be); tdrt.appendChild(rt); tdbt.appendChild(bt);
            tdct.appendChild(ct); tdec.appendChild(ec);
            tr.id = "gametrid" + p;
            tr.appendChild(tdbt); tr.appendChild(tdcnt); tr.appendChild(tdct); 
            tr.appendChild(tdwp); tr.appendChild(tdwe); 
            tr.appendChild(tdbp); tr.appendChild(tdbe); tr.appendChild(tdrt);
            tr.appendChild(tdec); tr.appendChild(tdev); tr.appendChild(tdct); 
            tr.className = "chesstr";
            tdcnt.className = "chesstdb"; tdev.className = "chesstde";  tdec.className = "chesstce";
            tdwp.className = "chesstdp"; tdbp.className = "chesstdp"; tdwe.className = "chesstdl";
            tdbe.className = "chesstdl"; tdrt.className = "chesstdr";  tdbt.className = "chesstdb";
            tdct.className = "chesstdb";
            tbody.appendChild(tr);

            bt.innerHTML = "&#8594;";
            bt.onclick = proceedPlay;
            bt.value = p;
            bt.id = "gameid" + p;

            if (p == '0') {
              tr.className = "chesstr chesstrcurrent";
              tr.scrollIntoView();
              PLAYBUTTON = bt;
            }
           }
        }
        var current_ = document.getElementById("currentgameid");
        var repeatbt = document.getElementById("repeatid");
        current_.innerHTML = '1. ';
        repeatbt.value = "&#9654;"; repeatbt.innerHTML = "&#9654;";
        const totalid = document.getElementById("totalid"); totalid.innerHTML = game_cnt;
        MOVETRACKER_ = null; CURRENTCOLOR_ = null; LOADPGN_ = false; INTERRUPT = false;
        REPEATPLAY_ = false; REPEATWHERE_ = null; REPEATBUTTON_ = null; 
        chess_awalker.pause(); chess_awalker.currentTime = 0
        initializePlay(0);
   }

   var pgn_interval = 0;
   function readyPGN(pgn_) {
     if (pgn_interval > 20) { pgn_interval = 0; clearInterval(pgntime); fetchPGN(pgn_); return  }
     pgn_interval ++;
     if (LOADPGN_ == false) {
          clearInterval(pgntime);
          LOADPGN_ = false;
          fetchPGN(pgn_);
     }
   }

   var pgntime = null , LOADPGN_ = false;
   async function loadPGN(pgn_){
        INTERRUPT = true; LOADPGN_ = true;
        pgntime = setInterval(readyPGN, 50, pgn_);
   }

   log("Render Board ...");
   reloadBoard();
   log(Board);
   log("Load Parser ...");
   loadParser();
   log("Load ECO ...");
   loadECO();
   log("Load Stockfish ...");
   loadStockfish();
   log("Enable Key Event Capture ...");
   keyPress();
</script>
</body>
</html>
