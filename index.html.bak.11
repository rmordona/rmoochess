<!DOCTYPE html>
<html lang="en" Cross-Origin-Embedder-Policy: require-corp>
<head>
  <meta charset="UTF-8">
  <title>Chess Repertoire</title>

<style type="text/css" id="genericpieceid" >
.piece { position: absolute; width: 0px; height: 0px; margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; border: 0px solid #00ff00; }
.p_a8 { left: 33px;  top: 33px; } .p_b8 { left: 130px;  top: 33px; } .p_c8 { left: 227px; top: 33px; } .p_d8 { left: 323px; top: 33px; }
.p_e8 { left: 420px; top: 33px; } .p_f8 { left: 517px; top: 33px; } .p_g8 { left: 613px; top: 33px; } .p_h8 { left: 710px; top: 33px; }

.p_a7 { left: 33px;  top: 130px; } .p_b7 { left: 130px;  top: 130px; } .p_c7 { left: 227px; top: 130px; } .p_d7 { left: 323px; top: 130px; }
.p_e7 { left: 420px; top: 130px; } .p_f7 { left: 517px; top: 130px; } .p_g7 { left: 613px; top: 130px; } .p_h7 { left: 710px; top: 130px; }

.p_a6 { left: 33px;  top: 226px; } .p_b6 { left: 130px;  top: 226px; } .p_c6 { left: 227px; top: 226px; } .p_d6 { left: 323px; top: 226px; }
.p_e6 { left: 420px; top: 226px; } .p_f6 { left: 517px; top: 226px; } .p_g6 { left: 613px; top: 226px; } .p_h6 { left: 710px; top: 226px; }

.p_a5 { left: 33px;  top: 323px; } .p_b5 { left: 130px;  top: 323px; } .p_c5 { left: 227px; top: 323px; } .p_d5 { left: 323px; top: 323px; }
.p_e5 { left: 420px; top: 323px; } .p_f5 { left: 517px; top: 323px; } .p_g5 { left: 613px; top: 323px; } .p_h5 { left: 710px; top: 323px; }

.p_a4 { left: 33px;  top: 420px; } .p_b4 { left: 130px;  top: 420px; } .p_c4 { left: 227px; top: 420px; } .p_d4 { left: 323px; top: 420px; }
.p_e4 { left: 420px; top: 420px; } .p_f4 { left: 517px; top: 420px; } .p_g4 { left: 613px; top: 420px; } .p_h4 { left: 710px; top: 420px; }

.p_a3 { left: 33px;  top: 517px; } .p_b3 { left: 130px;  top: 517px; } .p_c3 { left: 227px; top: 517px; } .p_d3 { left: 323px; top: 517px; }
.p_e3 { left: 420px; top: 517px; } .p_f3 { left: 517px; top: 517px; } .p_g3 { left: 613px; top: 517px; } .p_h3 { left: 710px; top: 517px; }

.p_a2 { left: 33px;  top: 615px; } .p_b2 { left: 130px;  top: 615px; } .p_c2 { left: 227px; top: 615px; } .p_d2 { left: 323px; top: 615px; }
.p_e2 { left: 420px; top: 615px; } .p_f2 { left: 517px; top: 615px; } .p_g2 { left: 613px; top: 615px; } .p_h2 { left: 710px; top: 615px; }

.p_a1 { left: 33px;  top: 710px; } .p_b1 { left: 130px;  top: 710px; } .p_c1 { left: 227px; top: 710px; } .p_d1 { left: 323px; top: 710px; }
.p_e1 { left: 420px; top: 710px; } .p_f1 { left: 517px; top: 710px; } .p_g1 { left: 613px; top: 710px; } .p_h1 { left: 710px; top: 710px; }
</style>

<style type="text/css">
.source { position: absolute; width: 0px; height: 0px; background-color: #000080;  opacity: 0.2; z-index: 0 }
.destination { position: absolute; width: 0px; height: 0px; background-color: #A08080;  opacity: 0.2; z-index: 0 }

.popupdiv { position: absolute; top: 0px; left: 0px; width: 0px; height: 0px; background-color: #d0d0d0; 
             padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px; border: 1px solid #dedede; }
.popup { position: absolute; top: 0px; left: 0px; bottom: 0px; right: 0px; font-weight: normal; 
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px ; background-color: #EFEFEF }
.popspan { display: block; width: 0px; height: 20px; background-color: #efefef; border-bottom: 2px solid #dfdfdf; cursor: pointer; white-space: nowrap; }

.chessdiv { position: absolute; top: 0px; left: 0px; width: 0px; height: 0px; background-color: #FFFFFF; margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px }
.chessboard { position: absolute; top: 0px; left: 0px;  margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px }
.chessboardimg { position: absolute; top: 0px; left: 0px; width: 840px; height: 840px;; margin: 0px 0px 0px 0px  }
.chessheader { position: absolute; top: 0px; left: 0px; width: 25px; height: 25px; background-color: #dedede;
					margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; }
.chessfooter { position: absolute; top: 0px; left: 0px; width: 25px; height: 25px; background-color: #dedede;
					margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; }
.chessside0 { position: absolute; top: 0px; left: 0px; border: 0px solid #afafaf; background-color: #FFFFFF;
			width: 0px; height: 0px; margin: 0px 0px 0px 0px }
.chessside1 { position: absolute; top: 0px; left: 0px; width: 850px; height: 10px; background-color: #d0d0d0; }
.chesstitle { position: absolute; top: 0px; left: 0px; width: 98.5%; height: 80px;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px; ; background-color: #EFEFEF }
.chessgame1 { position: absolute; top: 80px; left: 0px; bottom: 23px; right: 0px; font-weight: bold;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px; ; background-color: #EFEFEF }
.chessmoves { position: absolute; top: 0px; left: 0px; width: 0px; height: 0px; background-color: #d0d0d0; 
             padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px }
.chessgame { position: absolute; top: 0px; left: 0px; bottom: 0px; right: 0px; font-weight: bold;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px ; background-color: #EFEFEF }
.chessrate  { position: absolute; top: 0px; left: 0px; width: 100%; height: 50%; background-color: #404040; margin: 0px 0px 0px 0px }
.chesslisting { position: absolute; top: 0px; left: 0px; width: 850px; height: 280px; background-color: #d0d0d0; margin: 0px 0px 0px 0px }
.popfilter { position: absolute; top: 300px; left: 580px; border: 1px solid #ABABAB; width: 190px; height: 180px; background-color: #EFEFEF; visibility: hidden }
.chesspiece  { font-weight: bold; font-size: 14pt; margin: 5px 5px 5px 5px; }
.chesspiecestep { color: #00AA44; font-weight: normal }
.chesspiecemove { color: #FFFFFF; background-color: #288BA8;  cursor: pointer }
.chesspiecenomove { color: #440000; cursor: pointer }
.chesscmt { color: #FF0000; font-weight: normal }
.chesstrcurrent { background-color: #afafaf; width: 840px; }
.chesstr { margin: 0px 0px 0px 0px; border: 2px solid #ff00ff; width: 840px; }
.chesstdp { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 180px; }
.chesstde { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 220px; }
.chesstce { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 20px; }
.chesstdr { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 60px; }
.chesstdl { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 20px; }
.chesstdb { margin: 3px 3px 3px 3px; border: 1px solid #aaaaaa; width: 10px; }
.chessplaybtn { position: absolute; display: block; margin: 0px 0px 0px 0px }
.chessbutton { margin: 5px 5px 5px 5px }
.chessbutton1 { margin: 1px 0px 1px 0px }
.player { font-weight: bold; color: #1255b3;  }
.playerelo { font-weight: normal; color: #880000; font-family: helvetica; font-size: 12pt }
.gresult { color: #880000; font-weight: bold }
.opening { font-weight: normal; color: #000000;  }
.variation { font-weight: normal; color: #000000;  }
.playerside   { color: #12626A; font-weight: normal; font-family: helvetica; font-size: 12pt } 
.playertimer   { color: #800000; font-weight: normal; font-family: helvetica; font-size: 12pt } 
.playercapture   { color: #12626A; font-weight: bold; font-family: helvetica; font-size: 12pt } 
.sidetomove  { font-size: 16pt; font-weight: bold; color: #000000 }
.promocontain { font-size: 50px; position: absolute; top: 10px; left: 25px; visibility: hidden }
.promoclass { cursor: pointer; z-index: 20; border: 1px solid #ababab }

.disableselect { user-select: none; -webkit-user-select: none; -moz-user-select: none; }
</style>
<link rel="shortcut icon" href="images/favicon.ico">
</head>
<body style="background-color: #24262A; top: 0px; left: 0px; margin: 0px 0px 0px 0px">
<div id="chessdiv" class="chessdiv disableselect"> 

<div id="chessboard" class="chessboard"></div> 

<div id="chessheader" class="chessheader">
 <div style="position:absolute; top: 0px; left: 0px;" ><button onclick="collapseTool()" id="collapseid" 
      style="font-size: 12pt; border: 0px; margin: 2px 2px 2px 2px" alt="Tooltips" title="Tooltips">&#8801</button></div>
 <div style="position:absolute; top: 2px; left: 35px;">
    <span id="bplayer" class="playerside">Home Player</span>
    <span id="blackelo" class="playerelo">(1800)</span>
</div>
 <div style="position:absolute; top: 0px; right: 75px;"><span id="bcapture" class="playercapture">&#9813; &#9814; &#9815; &#9816; &#9817;</span></div>
 <div style="position:absolute; top: 2px; right: 5px;"><span id="btimer" class="playertimer">1:00:00</span></div>
</div>

<div id="chessfooter" class="chessfooter">
 <div style="position:absolute; top: -2px; left: 5px;" ><span class="sidetomove" id="sidetomoveid" >&#9675;</span> </div>
 <div style="position:absolute; top: 2px; left: 35px;">
    <span id="wplayer" class="playerside">Guest Player</span>
    <span id="whiteelo" class="playerelo">(1800)</span>
  </div>
 <div style="position:absolute; top: 0px; right: 75px;"><span id="wcapture" class="playercapture">&#9819; &#9820; &#9821; &#9822; &#9823;</span></div>
 <div style="position:absolute; top: 2px; right: 5px;"><span id="wtimer" class="playertimer">1:00:00</span></div>
</div>

<div id="chessside0" class="chessside0"> 
      <div class="chessrate" id="chessrate"></div> 
</div>

<div id="chessside1" class="chessside1">
      <div id="chesstitle" class="chesstitle"">
         <div style="position: absolute; margin: 5px 5px 5px 5px">
         <span id="currentgameid" class="player" style="cursor: pointer" onclick="showGame(this)"></span>
         <span id="wplayertitle" class="playerside">Guest Player</span> - <span id="bplayertitle" class="playerside">Home Player</span>
         <span id="resultid" class="gresult">1/2-1/2</span> <br>
         <span style="font-weight: bold"></span> <span id="eventid" class="variation">Event</span> (<span id="dateid" class="player">Date</span>)<br>
         <span style="font-weight: bold"></span><span id="ecoid" class="player">ECO</span>: <span id="openingid" class="opening">Opening</span>
         <span style="font-weight: bold"></span> - <span id="variationid" class="variation">Variation</span><br>
         </div>
      </div>
       <div class="chessgame1">
          <div id="chessgame1" class="chessgame1" style="margin: 5px 5px 5px 5px; overflow-y:scroll; top: 0px"></div>
      </div>

      <div id="playitid1" style="position: absolute; bottom: 36px; left: 0px; width: 85px; height: 18px;
            visibility: visible; margin: 0px 0px 0px 7px ">
          <div  style="position: absolute;   width: 100%; height: 100%; background-color: #dedede; border: 3px solid #dedede">
             <span class="chessplaybtn" onclick="resetGame()" style="top: 0px; left: 5px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; color: #808080; font-size: 10pt">&#x258E;</span>
             <span style="position:absolute; display: block; top: 0px; left: 2px; color: #808080; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="backwardPlay()" style="top: 0px; left: 25px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; color: #808080; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="forwardPlay()" style="top: 0px; left: 45px">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px; color: #808080; font-size: 10.5pt">&#9654;</span>
             </span>
             <span class="chessplaybtn" onclick="endGame()" style="top: 0px; left: 65px">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px; color: #808080; font-size: 10.5pt">&#9654;</span>
             <span style="position:absolute; display: block; top: 0px; left: 12px; color: #808080; font-size: 10pt">&#x258E;</span>
             </span>
           </div>
     </div>

     <div style="position: absolute; margin: 5px 5px 5px 5px; bottom: 20px"/>
      <div style="position:absolute; top: 0px; left: 0px;" ><button onclick="newGame()" id="newgameid" style="font-size: 12pt; border: 0px" alt="New Game" title="New Game">n</button></div>
      <div style="position:absolute; top: 0px; left: 29px;" ><button onclick="resignGame()" id="resignid" style="font-size: 12pt; border: 0px" alt="Resign" title="Resign">r</button></div>
      <div style="position:absolute; top: 0px; left: 85px;" ><button onclick="machineChoice()" id="engineid" style="font-size: 12pt; border: 0px" alt="Play Engine" title="Play Engine">e</button></div>
      <div style="position:absolute; top: 0px; left: 110px;" ><button onclick="takeBack()" id="undoid" style="font-size: 12pt; border: 0px" alt="Takeback" title="Takeback">&#8592;</button></div>
      <div style="position:absolute; top: 0px; left: 140px;" ><button onclick="" id="choosecolorid" style="font-size: 12pt; border: 0px" alt="Board" title="Board">c</button></div>
      <div style="position:absolute; top: 0px; left: 170px;" ><button onclick="" id="choosesizeid" style="font-size: 12pt; border: 0px" alt="Board" title="Board">s</button></div>
      <div style="position:absolute; top: 0px; left: 200px;" ><button onclick=""  id="choosedatabaseid" style="font-size: 12pt; border: 0px" alt="Board" title="Board">d</button></div>
      <div style="position:absolute; top: 0px; left: 230px;" ><button onclick="" id="chooseanalyzeid" style="font-size: 12pt; border: 0px" alt="Board" title="Board">a</button></div>
      <div style="position:absolute; top: 0px; left: 260px;" ><button onclick="reverseBoard()"  alt="Reverse" title="Reverse">&#8634;</button></div>
      <div style="position:absolute; top: 0px; left: 290px;" ><button onclick="switchGame()" id="switchid" alt="Switch Game" title="Switch Game">g</button></div>
      <div style="position:absolute; top: 0px; left: 320px;" ><button onclick="" id="filterid" alt="Filter Game" title="Filter Game">f</button></div>
      <div style="position:absolute; top: 0px; left: 360px;" ><button onclick="repeatPlay()" id="repeatid" alt="Reverse" title="Reverse">&#9654;</button></div>
      <div style="position:absolute; top: 0px; left: 390px;"> <input type="text" value="25" id="limitmoveid" size=3 maxlength=3/></div>
      <div style="position:absolute; top: 0px; left: 425px;" ><button onclick="playAW()" id="musicid" alt="Reverse" title="Reverse">&#9632;</button></div>
      <div style="position:absolute; top: 0px; left: 450px;"> <input type="text" value="330.924" id="musictimeid" size=7 maxlength=6 onchange="MUSIC_TIME=this.value"/> </div>
      <div style="position:absolute; top: 0px; left: 650px; white-space: nowrap;"><span class="playertimer"> Total: </span><span id="totalid" class="playertimer">0</span></div>
      <div style="position:absolute; top: 0px; left: 750px; white-space: nowrap;"> <span class="playertimer"> Time: </span> <span id="timerid" class="playertimer">00:00</span>
      </div>
     </div>
 </div>

<div id="chessmoves" class="chessmoves">
      <div class="chessgame">
          <div id="chessgame" class="chessgame" style="margin: 5px 5px 5px 5px; overflow-y:scroll; top: 0px"></div>
      </div>
      <div id="playitid" style="position: absolute; bottom: 13px; left: 0px; width: 85px; height: 18px;
            visibility: visible; margin: 0px 0px 0px 7px ">
          <div style="position: absolute;   width: 100%; height: 100%; background-color: #dedede; border: 3px solid #dedede">
             <span class="chessplaybtn" onclick="resetGame()" style="top: 0px; left: 5px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; color: #808080; font-size: 10pt">&#x258E;</span>
             <span style="position:absolute; display: block; top: 0px; left: 2px; color: #808080; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="backwardPlay()" style="top: 0px; left: 25px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; color: #808080; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="forwardPlay()" style="top: 0px; left: 45px">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px; color: #808080; font-size: 10.5pt">&#9654;</span>
             </span>
             <span class="chessplaybtn" onclick="endGame()" style="top: 0px; left: 65px">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px; color: #808080; font-size: 10.5pt">&#9654;</span>
             <span style="position:absolute; display: block; top: 0px; left: 12px; color: #808080; font-size: 10pt">&#x258E;</span>
             </span>
           </div>
     </div>
</div>


<div id="chesslisting" class="chesslisting" >
 <div id="chesslistid" style="margin: 5px 5px 5px 5px; overflow-y:scroll; 
         position: absolute; width: 850px; height: 270px; border-collapse: collapse">
          <table style="display: block; table-layout: fixed; width: 840px" id="chesstableid"></table>
 </div>
</div>


<div id="messagedivid" style="visibility: hidden;  margin: 0px 0px 0px 0px; z-index:15000">
 <div style="position: absolute; top: 350px; left: 140px; width: 460px; height: 40px; 
        border: 3px solid #FFFFFF; background-color: #FDAE61; margin: 0px 0px 0px 0px; z-index: 15000;">
        <span id="messageid" style="position: absolute; margin: 10px 10px 10px 10px; color: #000044; z-index: 15000"></span>
 </div>
</div>

<div id="machineid" style="visibility: hidden;  margin: 0px 0px 0px 0px; z-index: 50;">
 <div style="position: absolute; top: 400px; left: 250px; width: 400px; height: 100px;
        border: 3px solid #000000; background-color: #DEDEDE; margin: 0px 0px 0px 0px; z-index: 30;">
    <div style="position: absolute; top: 10px; left: 25px; width: 400px; z-index: 25" id="blackpromotionid">
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 50px; position: absolute; top: 0px; left: 0px">&#9812;</span>
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 12pt; position: absolute; top: 15px; left: 65px">
           <input type="radio" name="whiteplayer" id="whiteplayerid" value="human" checked onclick="choosePlayer(this)"/>Human<br>
           <input type="radio" name="whiteplayer" id="whiteplayerid" value="machine"  onclick="choosePlayer(this)"/>Machine
         </span>
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 50px; position: absolute; top: 0px; left: 200px">&#9818;</span>
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 12pt; position: absolute; top: 15px; left: 265px">
           <input type="radio" name="blackplayer" id="blackplayerid" value="human" checked  onclick="choosePlayer(this)"/>Human<br>
           <input type="radio" name="blackplayer" id="blackplayerid" value="machine" onclick="choosePlayer(this)"/>Machine
         </span>
    </div>
    <span onclick="machineChoice()" style="cursor: pointer; z-index: 20; 
             border: 1px solid #ababab; position: absolute; top: 5px; left: 385px">x</span>
 </div>
</div>

<div id="promoteid" style="position: absolute; visibility: hidden;  margin: 0px 0px 0px 0px; top: 100px; left: 100px">
 <div style="position: absolute; top: 0px; left: 0px; width: 300px; height: 100px; 
        border: 3px solid #000000; background-color: #DEDEDE; margin: 0px 0px 0px 0px; z-index: 10;">
    <div class="promocontain" id="blackpromotionid" > 
         <span id='Q' class="promoclass">&#9819;</span>
         <span id='R' class="promoclass">&#9820;</span>
         <span id='B' class="promoclass">&#9821;</span>
         <span id='N' class="promoclass">&#9822;</span>
    </div>
    <div class="promocontain" id="whitepromotionid">
         <span id='Q' class="promoclass">&#9813;</span>
         <span id='R' class="promoclass">&#9814;</span>
         <span id='B' class="promoclass">&#9815;</span>
         <span id='N' class="promoclass">&#9816;</span>
    </div>
 </div>
</div>

<div id="tooltipsid" style="visibility: hidden; position: absolute; top: 25px; left: 0px; width: 250px; height: 50px; 
                background-color: #DEDEDE; border: 1px solid #808080; z-index: 15000; white-space: nowrap;">
  <div style="margin: 10px 10px 10px 10px">
   Profiles/Login (coming soon)!
  </div>
</div>

<div id="popfilterid" class="popfilter"> 
 <div style="margin: 5px 5px 5px 5px">
<br>
White elo:
<select id="filter_welo_ops">
<option>=</option>
<option selected>>=</option>
<option><=</option>
<option>not =</option>
</select>
<input value="1500" placeholder="1500" maxlength="4" size="4" type="text" id="filter_welo" />
Black elo:
<select id="filter_belo_ops">
<option>=</option>
<option selected>>=</option>
<option><=</option>
<option>not =</option>
</select>
<input value="1500" placeholder="1500" maxlength="4" size="4" type="text" id="filter_belo" />
Moves:
<select id="filter_moves_ops">
<option>=</option>
<option selected>>=</option>
<option><=</option>
<option>not =</option>
</select>
<input value="5" placeholder="5" maxlength="3" size="3" type="text" id="filter_moves" /><br>
Result:<br>
<input type="checkbox" id="filter_res1" value="1-0" checked>1-0
<input type="checkbox" id="filter_res2" value="0-1" checked>0-1
<input type="checkbox" id="filter_res3" value="1/2-1/2" checked>1/2-1/2
</div>
</div>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pegjs/0.9.0/peg.min.js"></script>
<script type="text/javascript">

    var RMOO_PIECES_   = true;
    var HDR_FTR_HSIZE = 25;
    var BOARDSIZE_ =  840;
    var BOARDOFFSET_ = 0;
    var PIECESIZE_ = 0;
    const bINITFEN_ = "RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbkqbnr w KQkq - 0 1";
    const wINITFEN_ = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQKq - 0 1";
    var   _REPEAT_DRAW_ = initRepeatDraw();
    var   _NO_POSSIBLE_MOVES_ = false;
    var   _POSSIBLE_STALE_MATE_ = false;
    var   _POSSIBLE_CHECK_MATE_ = false;
    var   _CHECK_MATE_ = false;
    var   _STALE_MATE_ = false;
    var   _CHECK_KING_ = false;
    var   REVERSE      = false;
    var   CHESSGAME_   = null;
    const HUMAN        = "human";
    const MACHINE      = "machine";
    const WHITE        =  97;
    const BLACK        =  98;
    const UNMOVE       = 100;
    const GOODMOVE     = 101;
    const ENPASSANT    = 102;
    const EATPIECE     = 103;
    const CASTLESHORT  = 104;
    const CASTLELONG   = 105;
    const TIMER_BULLET_ = 1200; // ( 1000 ms * 60 sec * 1 min ) / 50 ms callback 
    const TIMER_BLITZ_ = 3600;  // ( 1000 ms * 60 sec * 3 min ) / 50 ms callback 
    const TIMER_RAPID_ = 12000; // ( 1000 ms * 60 sec * 10 min ) / 50 ms callback
    const TIMER_CLASSIC_ = 60000; // ( 1000 ms * 60 sec * 50 min ) / 50 ms callback (should be able to play 40 moves in 50 min.
    const horiz = [ "a", "b", "c", "d", "e", "f", "g", "h" ];
    const chessdiv   = document.getElementById("chessdiv");
    const chessboard = document.getElementById("chessboard");
    const chessgame = document.getElementById("chessgame");
    const chessgame1 = document.getElementById("chessgame1");
    const chessheader = document.getElementById("chessheader");
    const chessfooter = document.getElementById("chessfooter");
    const chessmoves = document.getElementById("chessmoves");
    const chessrate = document.getElementById("chessrate");
    const chessside0 = document.getElementById("chessside0");
    const engineid = document.getElementById("engineid");
    const whitepromotionid = document.getElementById("whitepromotionid");
    const blackpromotionid = document.getElementById("blackpromotionid");
    const btimer = document.getElementById("btimer");
    const wtimer = document.getElementById("wtimer");

    // populate header
    const machineid = document.getElementById("machineid");
    const whiteplayerid = document.getElementById("whiteplayerid");
    const blackplayerid = document.getElementById("blackplayerid");
    const wplayer = document.getElementById("wplayer");
    const bplayer = document.getElementById("bplayer");
    const wplayertitle = document.getElementById("wplayertitle");
    const bplayertitle = document.getElementById("bplayertitle");
    const welo    = document.getElementById("whiteelo");
    const belo    = document.getElementById("blackelo");
    const eventid = document.getElementById("eventid");
    const dateid  = document.getElementById("dateid");
    const resid   = document.getElementById("resultid");

    // opening header
    const ecoid   = document.getElementById("ecoid");
    const openingid   = document.getElementById("openingid");
    const variationid   = document.getElementById("variationid");

    // promotion template
    const promoteid = document.getElementById("promoteid")

    // board positions and sizes
    const BOARDCONFIG_ = [
         { bp: 280, of: 18, ps: 32.05 },
         { bp: 340, of: 22, ps: 39.05 },
         { bp: 480, of: 34, ps: 55.20 },
         { bp: 560, of: 40, ps: 64.30 },
         { bp: 640, of: 46, ps: 73.70 },
         { bp: 760, of: 56, ps: 87.50 },
         { bp: 840, of: 62, ps: 96.70 },
         { bp: 940, of: 70, ps: 108   },
         { bp: 1024, of: 76, ps: 117.80 } ];

    // styleSheets
    const sheet = document.styleSheets[0]

 /*
    const img = document.createElement("img");
    img.id = "chessboardimg";
    img.src = "/images/chessboarddarkblue.png";
    img.style.display = "none"; // Turns off displaying it
    img.style.width = BOARDSIZE_ + 'px';
    img.style.height = BOARDSIZE_ + 'px';
    chessboard.appendChild(img); // Puts the image in the image container
    img.style.display = "block";

    // Position:
    img.className = "chessboardimg"; 

    // move hints
    const source_ = document.createElement('div');
    const destination_ = document.createElement('div');
    source_.className = "source"; source_.style.visibility = "hidden";
    destination_.className = "destination"; destination_.style.visibility = "hidden";
    source_.loc_ = 'a1';
    destination_.loc_ = 'a1';
    chessboard.appendChild(source_);
    chessboard.appendChild(destination_);
  */

    // log
    function log(msg) { console.log(msg); } 

    // message
    const messagedivid = document.getElementById("messagedivid");
    const messageid = document.getElementById("messageid");
    var int_message = 0, msgtime = null;
    function showmessage(msg) {
      if (int_message > 20) { int_message = 0; clearInterval(msgtime); 
        messagedivid.style.visibility = 'hidden';
        messageid.innerHTML = '';
      }
      int_message ++;
    }
    function message(msg, err = true) {
        int_message = 0;
        messagedivid.style.visibility = 'visible';
        messageid.innerHTML = msg;
        int_message = 0;
        msgtime = setInterval(showmessage, 100, msg);
        if (err) throw "Error.";
    }


    function setBoardConfig(bp) {
        for (p in BOARDCONFIG_) {
          const board_ = BOARDCONFIG_[p];
          if (board_.bp == bp) {
            BOARDSIZE_   = board_.bp;
            BOARDOFFSET_ = board_.of;
            PIECESIZE_   = board_.ps;
          }
        }
    } 

    const rules = sheet.rules || sheet.cssRules;
    function getCSS(cls) {
       for (p in rules) {
         var rule = rules[p];

         if (rule.selectorText == cls) {
            return { left: parseInt(rule.style.left.replace(/px/, "")),
                     top: parseInt(rule.style.top.replace(/px/, "")) }
         }
       }
       return null;
    }
    function setCSS(cls, width = null, height = null, top = null, left = null, bottom = null, right = null) {
       for (p in rules) {
         var rule = rules[p];
         if (rule.selectorText == cls) {
               if (width != null) rule.style.width = (width == '') ? '' : width + 'px';
               if (height != null) rule.style.height = (height == '') ? '' : height + 'px';
               if (top != null) rule.style.top = (top == '') ? '' : top + 'px';
               if (left != null) rule.style.left = (left == '') ? '' : left + 'px';
               if (bottom != null) rule.style.bottom = (bottom == '') ? '' : bottom + 'px';
               if (right != null) rule.style.right = (right == '') ? '' : right + 'px';
         }
       }
       return null;
    }

    const pieceLoc = {}, sizeLoc = {}
    function createNewSizeStyle(size) {
       var style = document.getElementById('style_' + size);
       setBoardConfig(size);
       var offset = ~~(BOARDOFFSET_/2); 
       var psize = PIECESIZE_;
       if (style == null) {
            var top = '', left = '';
            style = document.createElement('style');
            style.id = 'style_' + size;
            document.head.appendChild(style);
            style.sheet.insertRule(
             '.piece_' + size + ' { position: absolute; margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; border: 0px solid #00ff00;  ' +
                   ' width: ' + psize + 'px; height: ' + psize + 'px; }' );
            for (var p=0; p<=7; p++) {
               const h = horiz[p];
               for (var v=0; v<=7; v++) {
                   loc_ = h+(v+1);
                   left =  parseInt(p) * psize + offset + 1;
                   top  =  (7-v) * psize + offset + 2;
                   pieceLoc[ loc_ + '_' + size ] = { top: top, left: left }
                   style.sheet.insertRule('.p' + size + '_' + loc_ + '{ top:' + top + 'px; left: ' + left + 'px;' + '}', 0); 
               }
             }
       }
    }

    function buildStyles() {
       for (var p in BOARDCONFIG_) {
         var size = BOARDCONFIG_[p];
         createNewSizeStyle(size.bp);
       }
    }
    buildStyles();

    function pageSize() {
        var w = window.innerWidth;
        var h = window.innerHeight;

        if (!w) {
             w = document.documentElement.clientWidth;
             h = document.documentElement.clientHeight;
             if (!w) {
                 w = document.body.clientWidth;
                 h = document.body.clientHeight;
             }
        }
        return {width: w, height: h};
    }
    pageSize();

    // popups
    function mousehover() { this.style.backgroundColor = "#dedede"; }
    function mousehout() { this.style.backgroundColor = "#efefef"; }
    function mousehdown() { this.style.backgroundColor = "#8f8f8f"; }
    function mousehup() { this.style.backgroundColor = "#dedede"; }
    function leavePopup(e) {
       if (this.className.match('popupdiv')) {
         this.style.visibility = 'hidden';
       }
    }
    function addPopupSpan(this_, func, width, item) {
        var s = document.createElement('span');
        s.className = 'popspan';
        s.style.width = width ;
        s.addEventListener("mouseover", mousehover, true);
        s.addEventListener("mouseout", mousehout, true);
        s.addEventListener("mousedown", mousehdown, true);
        s.addEventListener("mouseup", mousehup, true);
        s.onclick = func;
        s.game_ = this_;
        if (item.nm != null) {
            s.innerHTML = item.lab; ;
            s.value_ = item.nm;
        } else {
            s.innerHTML = item;
            s.value_ = item ;
        }
        return s;
    }
    function createPopup(id, this_, top, left, width, height, list = null, func = null) {
      if (list != null) {
        var d1 = document.createElement('div');
        var d2 = document.createElement('div');
        var d3 = document.createElement('div');
        d1.className = "popupdiv";
        d2.className = "popup";
        d3.className = "popup";
        d3.style = "margin: 5px 5px 5px 5px; overflow-y:scroll";
        d1.style.top = top + 'px'; 
        d1.style.left = left + 'px'; 
        d1.style.width = width + 'px'; 
        d1.style.height = height + 'px'; 
        d1.style.zIndex = 15000;
        d1.appendChild(d2);  
        d2.appendChild(d3);  
        this_.container_.appendChild(d1);
          for (p in list) { 
           const item = list[p];
           var s = addPopupSpan(this_, func, width + 'px', item);
           d3.appendChild(s);
          }
        d1.id = id;
        d3.id = 'pop_' + id;
        d1.addEventListener('mouseleave', leavePopup, false);
      }
    }



    // size
    function resetPieceCSS(size = BOARDSIZE_) {
       setBoardConfig(size);
       var offset = ~~(BOARDOFFSET_/2); // Math.round(BOARDOFFSET_ / 2);
       var psize = PIECESIZE_;
       var page = pageSize();
       var loc_ = null, width = null, height = null, top = null, left = null;
       var movoffset = 0, movheight = 0, sidheight = 0;
       setCSS('.piece', psize, psize );
       setCSS('.source', psize, psize );
       setCSS('.destination', psize, psize );
       setCSS('.chessheader', BOARDSIZE_, null, null, null);
       setCSS('.chessfooter', BOARDSIZE_, null, chessboard.offsetTop + BOARDSIZE_ + 1, null);
       movoffset = chessboard.offsetTop + BOARDSIZE_ + 1;
       movheight =  page.height - movoffset - (HDR_FTR_HSIZE) * 2; 
       if (movheight > 280) { movheight = 281; }
       sidheight = (BOARDSIZE_ + HDR_FTR_HSIZE) - (280 - movheight) - 2;
       width = 5; height = BOARDSIZE_; top = 0; left = (BOARDSIZE_ + 1);
       setCSS('.chessside0', width, height, top + (HDR_FTR_HSIZE), left);
       setCSS('.chessside1', null, sidheight, (HDR_FTR_HSIZE + 1), BOARDSIZE_ + 10);
       setCSS('.chessmoves', BOARDSIZE_, movheight - 3, (movoffset + HDR_FTR_HSIZE + 1), 0) ;
       setCSS('.chesstitle', null, 70, null, null);
       var listheight = BOARDSIZE_ + (HDR_FTR_HSIZE * 2) +  movheight - 280;
       setCSS('.chesslisting', null, null, listheight, BOARDSIZE_ + 10,  null, null);
       for (var p=0; p<=7; p++) {
          const h = horiz[p];
          for (var v=0; v<=7; v++) {
           loc_ = h+(v+1);
           sizeLoc[loc_] = { left: parseInt(p) * psize + offset + 1 , 
                             top: (7-v) * psize + offset + 2};
           setCSS('.p_' + loc_, null, null, sizeLoc[loc_].top, sizeLoc[loc_].left);
          }
       }
    }
    // resetPieceCSS();

    // timer

    const BTIMER_ = { last_time: 0, watch: '00:00:00', timer: null, int_timer: 0, elapsed: 0}, 
        WTIMER_ = { last_time: 0, watch: '00:00:00', timer: null, int_timer: 0, elapsed: 0 };
    var PLAYCNT_ = TIMER_BULLET_;
    var PLAYTIME_ = PLAYCNT_ * 50;
    function padTime(elapsed) {
       var s = ~~(elapsed / 1000); 
       var m = ~~(s / 60);
       var h = ~~(m / 60);
       m = m % 60; 
       s = s % 60 ; 
       var t = ("00" + s).slice(-2); 
       if (h == 0) t = m + ':' + t; else t = ("00" + m).slice(-2) + t; 
       if (h > 0) t = h + ':' + t; 
       return t;
    }
    function typeTimer() {
      if (PLAYCNT_ == TIMER_BULLET_) { return '1:00'; }
      if (PLAYCNT_ == TIMER_BLITZ_) { return '3:00'; }
      if (PLAYCNT_ == TIMER_RAPID_) { return '10:00'; }
      if (PLAYCNT_ == TIMER_CLASSIC_) { return '50:00'; }
      return '00:00:00';
    }
    function stopTimer() {
        if (PTIMER_ != null) { clearInterval(PTIMER_); PTIMER_ = null }
    }
    function initTimer(side_) {
      stopTimer();
      if (side_ == WHITE) {
          WTIMER_.last_time = 0;
          WTIMER_.watch = typeTimer();
          WTIMER_.timer = null;
          WTIMER_.int_timer = 0;
          WTIMER_.elapsed = 0;
          WTIMER_.watch = padTime(PLAYTIME_)
          wtimer.innerHTML = WTIMER_.watch;
      } else {
          BTIMER_.last_time = 0;
          BTIMER_.watch = typeTimer();
          BTIMER_.timer = null;
          BTIMER_.int_timer = 0;
          BTIMER_.elapsed = 0;
          BTIMER_.watch = padTime(PLAYTIME_)
          btimer.innerHTML = BTIMER_.watch;
      }
    }
    var PTIMER_ = null,  int_PCOUNT_ = 0;
    function checkTimer() {
        var last_time_ = Date.now();
        var elapsed = 0;seconds = 0, minutes = 0, hours = 0;
        if (int_PCOUNT_ > 60000) { int_PCOUNT_ = 0; clearInterval(PTIMER_); PTIMER_ = null }
        int_PCOUNT_++;
        if (SIDETOMOVE_ == WHITE) {
           WTIMER_.elapsed += (last_time_ - WTIMER_.last_time);
           elapsed = (PLAYTIME_ - WTIMER_.elapsed)
           if (elapsed < 0) {
               int_PCOUNT = 0; clearInterval(PTIMER_); PTIMER_ = null;
               doneGame(false, true, false, "Time is up! WHITE lost!");
               return;
           }
           WTIMER_.watch = padTime(elapsed)
           wtimer.innerHTML = WTIMER_.watch;
           WTIMER_.last_time = last_time_;
         
        } else {
           BTIMER_.elapsed += (last_time_ - BTIMER_.last_time);
           elapsed = (PLAYTIME_ - BTIMER_.elapsed)
           if (elapsed < 0) {
               int_PCOUNT = 0; clearInterval(PTIMER_); PTIMER_ = null;
               doneGame(false, true, false, "Time is up! BLACK lost!");
               return;
           }
           BTIMER_.watch = padTime(elapsed)
           btimer.innerHTML = BTIMER_.watch;
           BTIMER_.last_time = last_time_;
        }
    }

    function setTimer(timeron = true) {
       var last_time_ = Date.now();
       if (SIDETOMOVE_ == WHITE) {
           WTIMER_.last_time = last_time_;
       } else {
           BTIMER_.last_time = last_time_;
       }
       int_PCOUNT = 0;
       if (timeron) if (PTIMER_ == null) PTIMER_ = setInterval(checkTimer, 50);
    }

    // Board Selection
    var imageboard_ = [
                       { lab: 'Dark Brown', nm: 'darkbrown' }, { lab: 'Dark Red',    nm: 'darkred' },
                       { lab: 'Dark Blue',  nm: 'darkblue' },  { lab: 'Light Green', nm: 'lightgreen' },
                       { lab: 'Dark Green', nm: 'darkgreen' }, { lab: 'Green',       nm: 'green' },
                       { lab: 'Brown',      nm: 'brown' },     { lab: 'Blue',        nm: 'blue' },
                       { lab: 'Grey',       nm: 'grey' },      { lab: 'Cyan',        nm: 'cyan' },
                       { lab: 'Purple',     nm: 'purple' } ];

    function changeBoard() {
      const selected = this.value_;
      var img_ = null;
      const chessboardimg = document.getElementById("chessboardimg");
      if (!REVERSE) {
           img_ = '/images/chessboard' + selected + '.png';
      } else {
           img_ = '/images/chessboard' + selected + 'b.png';
      }
      chessboardimg.src = img_;
    }

    function sizeBoard() {
        const selected = this.value_;
        const sizeb = document.getElementById("sizeselection");
        const bp = parseInt(selected);
        for (p in BOARDCONFIG_) {
          const board_ = BOARDCONFIG_[p];
          if (board_.bp == bp) {
            BOARDSIZE_   = board_.bp;
            BOARDOFFSET_ = board_.of;
            PIECESIZE_   = board_.ps;
          }
        }
        resetPieceCSS(BOARDSIZE_);
        resizeBoard();
    }


    function chooseBoardColor(this_, pos) {
      var id = 'choosecolorid_' + this_.id;
      const elem = document.getElementById(id);
       if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
            return 
       }
      createPopup(id, this_, top = pos.y, left =  pos.x, width = 200, height = 200, imageboard_, this_.changeBoardColor );
    }

    function chooseBoardSize(pos) {
      var id = 'choosesizeid_';
      const elem = document.getElementById(id);
       if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
           return 
       }
      const sizes = [280, 340, 480, 560, 640, 760, 840, 940, 1024 ];
      createPopup(id, top = pos.y, left =  pos.x, width = 200, height = 200, sizes, sizeBoard );
    }

    function chooseAnalyze(this_, pos) {
       var id = 'chooseanalyzeid_' + this_.id;
       const elem = document.getElementById(id);
       if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
           return 
       }
       const fens = ["K7/8/3R4/4k3/8/8/8/8 b - - 0 1",
  	"8/8/4K3/4R3/8/4Pk2/7Q/8 w - - 0 1",
  	"8/8/8/1k7/8/1b7/8/4K2R b KQkq - 0 1",
  	"rn2kb1r/ppp1qppp/4bn2/3p4/3P4/1PP2N2/P3BPPP/RNBQ1RK1 w Kq - 0 1",
  	"r1bqkb1r/pp2pp2/2np1n1p/2p3p1/4P3/P2P1N2/1PP1BPPP/RNBQ1RK1 w Kq - 0 1",
  	"r1b1k2r/pp3p2/2np1q2/8/1P1bP1pp/P2Q4/4BPPP/1RB2RK1 w kq - 0 1",
  	"r2qkb1r/pp2nppp/3p4/2pNN1B1/2BnP3/3P4/PPP2PPP/R2bK2R w KQkq - 0 1",
  	"5n2/6P2/8/8/5K2/7k/8/8 w - - 0 1",
  	"8/8/7K/8/5k2/8/6p2/8 b - - 0 1",
  	"RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbkqbnr w KQkq - 0 1",
  	"RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rPbkqbnr w KQkq - 0 1",
  	"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQKq - 0 1",
  	"rnbqkb1r/ppp1pppp/3p1n2/8/4P3/5N2/PPPPBPPP/RNBQK2R b KQKq - 0 1",
  	"4n3/5P2/8/8/K7/7k/8/8 w - - 0 1",
  	"8/8/8/8/k7/7K/4p3/8 b - - 0 1",
  	"1nb5/8/8/8/3K4/k7/8/8 w - - 0 1",
  	"k7/8/2K5/8/8/8/8/8 w - - 0 1",
  	"4k3/8/8/8/8/8/8/4K3 w - - 0 1",
  	"1nb5/8/8/2k6/8/4K3/8/8 w - - 0 1"];
        createPopup(id, this_, top = pos.y, left =  pos.x, width = 600, height = 200, fens, this_.analyzePosition );
    }

    function chooseDatabase(pos) {
      var id = 'choosedatabaseid_';
      const elem = document.getElementById(id);
      if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
           return 
      }
       const dbs = [
        { nm: "broken", lab: "broken.pgn" },
        { nm: "broken1", lab: "broken1.pgn" },
        { nm: "broken2", lab: "broken2.pgn" },
        { nm: "broken3", lab: "broken3.pgn" },
        { nm: "broken4", lab: "broken4.pgn" },
        { nm: "broken5", lab: "broken5.pgn" },
        { nm: "demo2", lab: "demo2.pgn" },
        { nm: "demo4", lab: "demo4.pgn" },
        { nm: "demo5", lab: "demo5.pgn" },
        { nm: "mygames", lab: "mygames.pgn" },
        { nm: "alek", lab: "Alek" },
        { nm: "AlekhineExchange", lab: "Alekhine Exchange" },
        { nm: "Alekhine2Nc3-d5", lab: "Alekhine (2.Nc3 d5)" },
        { nm: "BenkoGambit", lab: "Benko Gambit" },
        { nm: "CatalanClosed", lab: "Catalan Closed" },
        { nm: "CatalanOpen", lab: "Catalan Open" },
        { nm: "FrenchAdvance", lab: "French Advance" },
        { nm: "FrenchExachange", lab: "French Exchange" },
        { nm: "FrenchRubinstein", lab: "French Rubinstein" },
        { nm: "FrTarrasch3c5", lab: "French Tarrasch (3.c5)" },
        { nm: "FrTarrasch3Nf6", lab: "French Tarrasch (3.Nf6)" },
        { nm: "FrTarraschOther3", lab: "French Tarrasch (3.Other)" },
        { nm: "FrWinawerMain", lab: "French Winawer (Main)" },
        { nm: "GiuocoPiano", lab: "Giuoco Piano" },
        { nm: "KIDClassical", lab: "King's Indian (Classic)" },
        { nm: "KIDFianchetto", lab: "King's Indian (Fianchetto)" },
        { nm: "KIDSaemisch", lab: "King's Indian (Saemisch)" },
        { nm: "KIDPetrosian", lab: "King's Indian (Petrosian)" },
        { nm: "QID4a3", lab: "Queen's Indian (4.a3)" },
        { nm: "QID4e3", lab: "Queen's Indian (4.e3)" },
        { nm: "QID4g3-Ba6", lab: "Queen's Indian (4.g3 Ba6)" },
        { nm: "QID4Nc3", lab: "Queen's Indian (4.Nc3)" },
        { nm: "RuyLopezBerlin", lab: "Ruy Lopez (Berlin)" },
        { nm: "RuyLopezBreyer", lab: "Ruy Lopez (Breyer)" },
        { nm: "RuyLopezChigorin", lab: "Ruy Lopez (Chigorin)" },
        { nm: "RuyLopezMarshall", lab: "Ruy Lopez (Marshall)" },
        { nm: "RuyLopezAntiMarshall", lab: "Ruy Lopez (AntiMarshall)" },
        { nm: "PetroffMain", lab: "Petroff Main" },
        { nm: "PetroffOther3", lab: "Petroff Other 3." },
        { nm: "Scotch4Bc5", lab: "Scotch (4.Bc5)" },
        { nm: "Scotch4Nf6", lab: "Scotch (4.Nf6)" },
        { nm: "SicilianAlapin2Nf6", lab: "Sicilian Alapin (2.Nf6)" },
        { nm: "SicilianAlapin2d5", lab: "Sicilian Alapin (2.d5)" },
        { nm: "SicilianLowenthal", lab: "Sicilian Lowenthal" },
        { nm: "SicilianNajdorf6f3", lab: "Sicilian Najdorf (f6 f3)" },
        { nm: "SicilianNajdorf6f4", lab: "Sicilian Najdorf (f6 f4)" },
        { nm: "SicilianNajdorf6Bg5", lab: "Sicilian Najdorf (f6 Bg5)" },
        { nm: "SicilianNajdorf6Be3", lab: "Sicilian Najdorf (f6 Be3)" },
        { nm: "SicilianNajdorf6Be2", lab: "Sicilian Najdorf (f6 Be2)" },
        { nm: "SicilianNajdorf6Bc4", lab: "Sicilian Najdorf (f6 Bc4)" },
        { nm: "SicilianRossolimo", lab: "Sicilian Rossolimo" },
        { nm: "SicilianScheveningen", lab: "Sicilian Scheveningen" },
        { nm: "SicilianSveshnikov", lab: "Sicilian Sveshnikov" },
        { nm: "SicilianTaimanov5Nb5", lab: "Sicilian Talmanov (5.Nb5)" },
        { nm: "SicilianTaimanovMain", lab: "Sicilian Talmanov (Main)" } ];
         createPopup(id, top = pos.y, left = pos.x, width = 240, height = 200, dbs, changeDatabase );
    }

/*
    const choosecolorid = document.getElementById('choosecolorid'); 
    const choosesizeid = document.getElementById('choosesizeid'); 
    const choosedatabaseid = document.getElementById('choosedatabaseid'); 
    const chooseanalyzeid = document.getElementById('chooseanalyzeid'); 
    choosecolorid.addEventListener('mouseup', chooseColorMU);
    choosecolorid.addEventListener('mousedown', chooseColorMD);
    choosesizeid.addEventListener('mouseup', chooseSizeMU);
    choosesizeid.addEventListener('mousedown', chooseSizeMD);
    choosedatabaseid.addEventListener('mouseup', chooseDatabaseMU);
    choosedatabaseid.addEventListener('mousedown', chooseDatabaseMD);
    chooseanalyzeid.addEventListener('mouseup', chooseAnalyzeMU);
    chooseanalyzeid.addEventListener('mousedown', chooseAnalyzeMD);


    function chooseColorMD(e) {
        e.preventDefault();
       this.targetchoose_ = true;
    }

    function chooseColorMU(e) {
       if (this.targetchoose_) {
          var pos = eventOffset(e);
          chooseBoardColor(pos);
       }
    }

    function chooseSizeMD(e) {
        e.preventDefault();
       this.targetchoose_ = true;
    }

    function chooseSizeMU(e) {
       if (this.targetchoose_) {
          var pos = eventOffset(e);
          chooseBoardSize(pos);
       }
    }


    function chooseDatabaseMD(e) {
        e.preventDefault();
       this.targetchoose_ = true;
    }

    function chooseDatabaseMU(e) {
       if (this.targetchoose_) {
          var pos = eventOffset(e);
          chooseDatabase(pos);
       }
    }

    function chooseAnalyzeMD(e) {
        e.preventDefault();
       this.targetchoose_ = true;
    }

    function chooseAnalyzeMU(e) {
       if (this.targetchoose_) {
          var pos = eventOffset(e);
          chooseAnalyze(pos);
       }
    }
*/

    // Collapse Tooltips
    var TOOLS_ = false;
    const tooltipsid = document.getElementById("tooltipsid");
    function collapseTool() {
       TOOLS_ = (TOOLS_) ? false : true;
       tooltipsid.style.visibility = (TOOLS_) ? "visible" : "hidden";
    }

    // Reverse Board
    var reverse_ =  { a:"h", b:"g", c:"f", d:"e", e:"d", f:"c", g:"b", h:"a",
                      1:8, 2:7, 3:6, 4:5, 5:4, 6:3, 7:2, 8:1 }
    function reverseLoc(rv, location) {  /** Generic **/
        if (rv) {
             return reverse_[location[0]] + reverse_[location[1]];
        } 
        return location;
    }

    /* Remove */
    function reverseBoard() {
         chessboard.style.visibility = "hidden";
         REVERSE = !REVERSE;
         changeBoard();
         for (var p in Board) {
            var board = Board[p];
            if (board != null) {
               board.piece.className = "piece " + "p_" + reverseLoc(board.location);
            }
         }
         for (var p in Benched) {
            var board = Benched[p], loc_ = null;
            if (board != null) {
               board.piece.className = "piece " + "p_" + reverseLoc(board.location);
            }
         }
         source_.className = "source piece p_" + reverseLoc(source_.loc_);
         destination_.className = "destination piece p_" + reverseLoc(destination_.loc_);
         const game = initHeader(false, false, false);
         infoHeader(game);
         setRate();
         chessboard.style.visibility = "visible";
         if (NEWGAME_ || ANALYZEGAME_) {
            if (RESIGN_ || FETCHEDGAME_ || PROMOTE_) return;
            playEngine();
         }
    }


    // expandBoard
    function resizeBoard() {
         const chessboardimg = document.getElementById("chessboardimg");
         const chessboard = document.getElementById("chessboard");
         const chesslisting = document.getElementById("chesslisting");
         chessboard.style.visibility = "hidden";
        
         for (var p in Board) {
               var board = Board[p];
               if (board != null) {
                   board.piece.className = "piece " + "p_" + reverseLoc(board.location);
               }
         }
         for (var p in Benched) {
               var board = Benched[p], loc_ = null;
               if (board != null) {
                   board.piece.className = "piece " + "p_" + reverseLoc(board.location);
               }
         } 
         chessboard.className = 'chessboard'
         chessboardimg.className = 'chessboardimg'
         chessboardimg.style.width = ( BOARDSIZE_ ) + 'px';
         chessboardimg.style.height = ( BOARDSIZE_) + 'px';
         chessside0.className = "chessside0";

         source_.className = "source piece p_" + reverseLoc(source_.loc_);
         destination_.className = "destination piece p_" + reverseLoc(destination_.loc_);
         chessboard.style.visibility = "visible";
         emptyBench();
    }


    function changeDatabase() {
        const selected = this.value_
        const _pgn = "/pgn/" + selected + ".pgn";
        loadPGN(_pgn);
    }

    function illegal_move(msg) { throw msg; }

    const SOURCE_HIST_ = []
    function emptySource() { 
          while (SOURCE_HIST_.length) SOURCE_HIST_.pop(); 
          source_.style.visibility = 'hidden';
          destination_.style.visibility = 'hidden';
     }

    // remove
    function setSource(piece) {
      source_.loc_ = piece.oldlocation_;
      destination_.loc_ = piece.location_;
      source_.className = "source piece p_" + reverseLoc(source_.loc_);
      destination_.className = "destination piece p_" + reverseLoc(destination_.loc_);
      SOURCE_HIST_.push({ src: source_.loc_, dest: destination_.loc_ });
      source_.style.visibility = 'visible';
      destination_.style.visibility = 'visible';
    }

    // remove
    function unsetSource() {
      var piece = SOURCE_HIST_.pop();
      if (SOURCE_HIST_.length > 0) {
        piece = SOURCE_HIST_[SOURCE_HIST_.length - 1]; 
        source_.loc_ = piece.src;
        destination_.loc_ = piece.dest;
        source_.className = "source piece p_" + reverseLoc(source_.loc_);
        destination_.className = "destination piece p_" + reverseLoc(destination_.loc_);
        source_.style.visibility = 'visible';
        destination_.style.visibility = 'visible';
      } else {
        source_.style.visibility = 'hidden';
        destination_.style.visibility = 'hidden';
      }
    }

    var SIDETOMOVE_ = WHITE, MOVECOUNT_ = 0;
    var sidetoid = document.getElementById("sidetomoveid");
    function TurnToPlay(piece) {
        SIDETOMOVE_ = (SIDETOMOVE_ == WHITE) ? BLACK: WHITE;
        MOVECOUNT_ = MOVECOUNT_ + ((SIDETOMOVE_ == WHITE ) ? 1 : 0);
        sidetoid.innerHTML = (SIDETOMOVE_ == WHITE) ? '&#9675;' : '&#9679;';
        setTimer(false);
        if (piece != null) {
           LASTPIECE_ = piece;
           setSource(piece);
           if (piece.restype_ == CASTLELONG || piece.restype_ ==  CASTLESHORT) { chess_castle.currentTime = 0; chess_castle.play(); } 
           else
           if (piece.restype_ == EATPIECE) { chess_castle.currentTime = 0; chess_castle.play(); } else 
                                           { chess_move.currentTime = 0; chess_move.play(); }
        } else chess_move.play();
    }

    function searchGame() {
        return ecoGame_.join(' ');
    }

    var DONEGAME_ = true; const engineGames = [];
    function doneGame(resign = false, checkmate = false, draw = false, imsg = null) {
        var game = {}, msg = "Game Over!";
        if (ecoGame_.length == 0 && MOVECOUNT_ > 2 ) { message("Game Over! Game terminated early!", false);  return }
        var moves_ = 0, lastmove_ = null;
        game = initHeader(resign, draw, true);
        infoHeader(game);
        if (ecoGame_.length >= 6) {
          game.moves = ecoGame_.join(" ") + " " + game.rt + " ";
          moves_ = game.moves.split(' ').length - 1; moves_ = Math.floor(moves_ / 2);
          game.ct = moves_;
          game.eco = ecoid.innerHTML;
          game.round = String(engineGames.length + 1);
          game.fen = GAMEFEN_;
          engineGames.push(game);
          Games = engineGames;
          const movespace3 = document.createTextNode("   ");
          const movespan3 = document.createElement("span");
          movespan3.className = "chesspiecers";
          movespan3.style.color = "#1255b3";
          movespan3.innerHTML = " " + game.rt;
          CHESSGAME_.appendChild(movespace3);
          CHESSGAME_.appendChild(movespan3);
          refreshGame(false, null, false);
        }
        while (ecoGame_.length) ecoGame_.pop();
        DONEGAME_ = true; NEWGAME_ = false; ANALYZEGAME_ = false;
        stopTimer();
        if (resign || checkmate) {
          if (game.win != null) { msg = "Game Over! Winning team is " + game.win; } else { msg = "Game Over! Game terminated early." }
        }
        if (draw) { if (imsg != null) msg = imsg; else  msg = "Game is Drawn!"; }
        message(msg, false);
        log("Done Game ...");
    }

    function infoHeader(game) {
        // populate header
         eventid.innerHTML = game.ev + " (" + game.si + ")";
         dateid.innerHTML = game.dt;
         if (!REVERSE) {
            wplayer.innerHTML = game.wp; bplayer.innerHTML = game.bp;
            wplayertitle.innerHTML = game.wp; bplayertitle.innerHTML = game.bp;
            welo.innerHTML = "(" + game.we + ")";
            belo.innerHTML = "(" + game.be + ")";
         } else {
            wplayer.innerHTML = game.bp; bplayer.innerHTML = game.wp;
            wplayertitle.innerHTML = game.bp; bplayertitle.innerHTML = game.wp;
            welo.innerHTML = "(" + game.be + ")";
            belo.innerHTML = "(" + game.we + ")";
         }
         resid.innerHTML = game.rt;
         ecoid.innerHTML       = game.eco;
         openingid.innerHTML   = game.opening;
         variationid.innerHTML = game.variation.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, '');
    }

    function initHeader(resign = false, draw = false, rating = false) {
        const game = {}
        game.wp = (WPLAYER_ == HUMAN) ? "Human (Me)" : "Stockfish 15"
        game.bp = (BPLAYER_ == HUMAN) ? "Human (Me)" : "Stockfish 15"
        if (WPLAYER_ == HUMAN && BPLAYER_ == HUMAN) {
             game.wp =  "Home Player"; game.bp = "Guest Player";
             game.ev = "Human vs Human";
        } else
        if (WPLAYER_ == MACHINE && BPLAYER_ == MACHINE) {
             game.ev = "Machine vs Machine";
        } else {
             game.ev = "Human vs Machine";
        }
        game.we = String((WPLAYER_ == HUMAN) ? 1800 : 2800);
        game.be = String((BPLAYER_ == HUMAN) ? 1800 : 2800);
        game.dt = new Date(Date.now()).toLocaleString();
        game.eco = 'ECO'; game.opening = 'Opening'; game.variation = 'Variation';
        game.si = "Home";
        game.win = null;
        if (!rating) { game.rt = ""; } else {
          if (resign) {
             game.rt = (REVERSE) ? "1-0" : "0-1";
             game.win = (REVERSE) ? "WHITE" : "BLACK";
          } else {
             game.rt = (SIDETOMOVE_ == WHITE) ? "0-1" : "1-0";
             game.win = (SIDETOMOVE_ == WHITE) ? "BLACK" : "WHITE";
          }
          if (draw) { game.rt = "1/2-1/2"; game.win = "DRAW"}
        }
        return game;
    }

    function initRepeatDraw() { 
         return  { wmove: [], bmove: [], fen: [] }
    }

    function initGame(newgame, analyzegame) {
        MOVECOUNT_ = 0; SIDETOMOVE_ = WHITE; 
        RESIGN_ = false; 
        NEWGAME_ = newgame; ANALYZEGAME_ = analyzegame; 
        FETCHEDGAME_ = false; 
        // DONEGAME_ = false; set this during the first move.
       _POSSIBLE_CHECK_MATE_ = false; _POSSIBLE_STALE_MATE_ = false; GAMEFEN_ = null;
       _CHECK_MATE_ = false; _STALE_MATE_ = false; _NO_POSSIBLE_MOVES_ = false; BOOKADDED_ = false;
       _REPEAT_DRAW_ = initRepeatDraw();

       const game = initHeader(false, false, false);
       infoHeader(game);

       // For playing
       MOVETRACKER_ = null;

       // Timer
       initTimer(WHITE);
       initTimer(BLACK);

       // Source
       emptySource();

       // empty bench;
       emptyBench();
    }

    const ecoGame_ = [];
    var  NEWGAME_ = true, GAMEFEN_ = null;
    function newGame() {
        if (MACHINECHOICE_) return;
        if (PROMOTE_ || PLAYING || REPEATPLAY_) return;
        if (!DONEGAME_) doneGame(true); 
        initGame(true, false);
        CHESSGAME_.innerHTML = ""; 
        GAMEFEN_ = wINITFEN_;
        reloadBoard(GAMEFEN_);
        chess_reset.play();
        chess_move.volume = 1.0;
        playEngine();
    }

    var RESIGN_ = false;
    function resignGame() {
       if (MACHINECHOICE_) return;
       if (DONEGAME_) { message("No active game!", false); return }
       if (PROMOTE_ || PLAYING || REPEATPLAY_) return;
       RESIGN_ = true;
       doneGame(true);
    }

    var CHESSGAME_ = chessgame;
    const playitid = document.getElementById("playitid");
    const playitid1 = document.getElementById("playitid1");
    playitid.style.visibility = 'visible';
    playitid1.style.visibility = 'hidden';
    function switchGame() {
      if (!NEWGAME_) return;
       if (CHESSGAME_.id == 'chessgame') {
          CHESSGAME_ = chessgame1;
          playitid1.style.visibility = 'visible';
          playitid.style.visibility = 'hidden';
 
       } else {
          CHESSGAME_ = chessgame;
          playitid1.style.visibility = 'hidden';
          playitid.style.visibility = 'visible';
       }
    }

    const popfilterid = document.getElementById("popfilterid");
    const filterid = document.getElementById("filterid");
    filterid.addEventListener('mouseup', filterGameMU);
    filterid.addEventListener('mousedown', filterGameMD);
    popfilterid.addEventListener('mouseleave', filterGameLV, false);
    var FILTERPOP_ = false;
    function filterGame(pos) {
        FILTERPOP_ = (FILTERPOP_) ? false : true;
        if (FILTERPOP_) {
            popfilterid.style.visibility = 'visible';
            popfilterid.style.top = pos.y + 'px';
            popfilterid.style.left = pos.x + 'px';
        } else {
            popfilterid.style.visibility = 'hidden';
        } 
    }

    function filterGameLV(e) {
      if (this.className.match('popfilter')) {
         this.style.visibility = 'hidden';
         FILTERPOP_ = false;
       }
    }

    function filterGameMD(e) {
        e.preventDefault();
       this.targetchoose_ = true;
    }

    function filterGameMU(e) {
       if (this.targetchoose_) {
          var pos = eventOffset(e);
          filterGame(pos);
       }
    }

    function addFEN(fen) {
       const analyzeid = document.getElementById('pop_chooseanalyzeid_');
       var found_ = false;
       var next = analyzeid.firstChild, fen_, width = null, func = null;
       while (next) {
         fen_ = next.innerHTML;
         width = next.style.width;
         func = next.onclick;
         if (fen == fen_) { found_  = true; break }
         next = next.nextSibling;
       }
       if (!found_) {
          var s = addPopupSpan(func, width, fen);
          analyzeid.appendChild(s);
      }
    }

    var ANALYZEGAME_ = false;
    function analyzeGame() {
       var fen = this.value_ 
       var who_ = fen.split(' ')[1] 
       initGame(false, true);
       try {
         const reverseB = checkPositionLegality(fen);
         if (reverseB) {
           repositionBoard(wINITFEN_);
           reverseBoard();
         } else {
           repositionBoard(fen);
         }
         CHESSGAME_.innerHTML = "";  Games = [];
         while (ecoGame_.length > 0)  ecoGame_.pop();
         SIDETOMOVE_ = (who_ == 'b') ? BLACK : WHITE;
         sidetoid.innerHTML = (SIDETOMOVE_ == WHITE) ? '&#9675;' : '&#9679;';
         GAMEFEN_ = fen;
         // add FEN entry.   
         addFEN(fen);
         playEngine();
       } catch(e) { log(e) }
    }

/*
    function takeMove(piece, loc_, promote) {
          var move_ = '';
          piece.move = { location: loc_, promote: promote };
          const src_ = identifySource(piece);
          if (promote != null) {
              move_ = loc_ + "=" + promote;
          } else
          if (piece.restype_ == CASTLELONG) move_ = "O-O-O"; else
          if (piece.restype_ == CASTLESHORT) move_ = "O-O"; else
          if (piece.restype_ == EATPIECE) {
                if (piece.role_ == 'P')
                   move_ = piece.oldlocation_[0] + "x" + loc_;
                 else
                move_ = piece.role_ + src_ + "x" + loc_;
          } else move_ = piece.role_.replace(/P/g,'') + src_ + loc_;
          moveIt(MOVECOUNT_ + 1, move_, (_CHECK_MATE_) ? '#' : (_CHECK_KING_ ? '+' : ''));
          TurnToPlay(piece);
          isRepeatDraw();
          if (isEngineGame()) { playEngine(); }  else { checkState(piece, move_); }
    }
*/

    var matetime = null, int_mate = 0;
    var BOOKADDED_ = false;
    function checkEngineState() {
        if (int_mate > 20) { int_mate = 0; clearInterval(matetime)  }
        int_mate ++;
        if (ENGINEMOVE_ != null) {
            int_mate = 0;
            clearInterval(matetime);
            if (_STALE_MATE_) {
                 doneGame(false, false, true, "Game is drawn! Possible Stalemate!");
            } else
            if (_CHECK_MATE_ && _NO_POSSIBLE_MOVES_) {
                updateMate();
                doneGame(false, true, false);
            } else {
                 // let us calculate score (based on opponents pondered move.
                 // calculate only after book.
                 var move_ = searchBest();
                 if (BOOK_ == null && !BOOKADDED_) {
                    var book_ = ecoGame_.join(" ").replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                           replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                           replace(/R/g,'&#9814;').replace(/P/g, '');
                    variationid.innerHTML = variationid.innerHTML + " <br><span style='color:#FF0000'>(NOT in our ECO: " + book_ + ")</span>";
                    BOOKADDED_ = true;
                 }
            }
        }
    }

    async function checkState(piece, move_) {
       const whichside =  (SIDETOMOVE_ == WHITE) ? 'w' : 'b'; // see if next move is mated.
       var fen =  generateFEN(whichside, enpassant = "-")
       _POSSIBLE_CHECK_MATE_ = false; _POSSIBLE_STALE_MATE_ = false;
       _CHECK_MATE_ = false; _STALE_MATE_ = false; _NO_POSSIBLE_MOVES_ = false;
       ENGINEMOVE_ = null;
       // post("setoption name Hash value 8888");
       // post("setoption name UCI_LimitStrength 2800");
       post("setoption name UCI_ShowWDL value true");
       post("setoption name UCI_AnalyseMode value true");
       post("setoption name MultiPV value 5");
       post("setoption name Slow Mover type spin default 84 min 10 max 1000");
       post("isready");
       post("ucinewgame");
       post("position fen " + fen);
       await post("go movetime 500 depth 18");
       int_mate = 0;
       matetime = setInterval(checkEngineState, 50);
    }

    function checkPositionLegality(fen) {
       if (fen == null) fen =  generateFEN('w', enpassant = "-") 
       var fens_ = fen.split(' ');
       var initfen_ = fens_[0];
       var nside_ = fens_[1];
       var binitfen_ = bINITFEN_.split(' ')[0];
       var winitfen_ = wINITFEN_.split(' ')[0];
       var fen_ = initfen_.split('/');
       var cntP = initfen_.match(/[Pp]/g)
       var cntK = initfen_.match(/[K]/g)
       var cntk = initfen_.match(/[k]/g)
       var Kk  = initfen_.match(/Kk|kK/g)
       var un_ = initfen_.match(/[ACDEFGHIJLMOSTUVWXZY\.\!\#\$\%\^\&\*\(\)\_\-\+\=\[\{\]\}\;\'\:\"\<\>\>\<\?\\\~\`09]/ig)
       var my8thrank = fen_[0]; my1strank = fen_[7];
       var castl = fens_[2];
       if (fens_[2] == null) { message("Incorrect Notation."); return } 
       castl = castl.match(/^(KQkq|Qkq|KQk|Kkq|KQq|KQ|Kk|Kq|Qk|Qq|kq|Q|q|K|k|-)$/g);
       if (fen_.length != 8) message("invalid number of ranks");
       if (nside_ != 'w' && nside_ != 'b') message( "Incorrect side option. Use (w or b).");
       if (castl == null) message( "Invalid Castling options");
       if (un_ != null && un_.length > 0) message( "Invalid Notation. Unknown characters found!");
       if (Kk != null && Kk.length > 0) message( "Kings cannot be close to each other!");
       if (cntK != null && cntK.length != 1) message( cntK.length + " White Kings not allowed!");
       if (cntk != null && cntk.length != 1) message( cntk.length + " Black Kings not allowed!");
       if (cntK == null || cntk == null) message("Missing king.");
       if (cntP != null && cntP.length > 16) message( cntP.length + " Pawns not allowed!");
       if ((my8thrank != null && my8thrank.match(/[Pp]/)) || 
           (my1strank != null && my1strank.match(/[Pp]/)) )
             message( "Cannot have Pawns in the 1st and 8th ranks!");
       if (initfen_ == binitfen_) {
           if (nside_ == 'b') {
             message( "Black cannot start the game first!");
           } else {
             return 1; 
           }
        }
       return null; 
    }
        
    function generateFEN(whichside, enpassant = "-") {
      var piece = null;
      var fen = "", spc = 0, cmp = "";
      var castling = [0,0,0,0,0,0], cst = "";
      for (var v=8; v>=1; v--) {
         spc = 0;
         for (p in horiz) {
            piece = Board[horiz[p] + v];
            if (piece != null) {
                cmp =  (piece.color_.match(/dt$/)) ? piece.role_.toLowerCase() : piece.role_;
                fen = fen + ((spc > 0) ? (spc + cmp) : cmp);
                spc = 0;
                // check for castling availability
                if (cmp == 'K' && piece.location_ == 'e1' && piece.oldlocation_ == null) castling[0] =  1;
                if (cmp == 'k' && piece.location_ == 'e8' && piece.oldlocation_ == null) castling[1] =  1;
                if (cmp == 'R' && piece.location_ == 'h1' && piece.oldlocation_ == null) castling[2] =  1;
                if (cmp == 'R' && piece.location_ == 'a1' && piece.oldlocation_ == null) castling[3] =  1;
                if (cmp == 'r' && piece.location_ == 'h8' && piece.oldlocation_ == null) castling[4] =  1;
                if (cmp == 'r' && piece.location_ == 'a8' && piece.oldlocation_ == null) castling[5] =  1;
            } else { spc ++; }
         }
         fen = fen + ((spc > 0) ? spc : "");
         if (v > 1) fen = fen + "/";
       } 
       if (castling[0] == 1 && castling[2] == 1) cst = cst + "K";
       if (castling[0] == 1 && castling[3] == 1) cst = cst + "Q";
       if (castling[1] == 1 && castling[4] == 1) cst = cst + "k";
       if (castling[1] == 1 && castling[5] == 1) cst = cst + "q";
       if (cst == "") cst = "-";
       fen = fen + " " + whichside + " " + cst + " " + enpassant + " " + "0 1";
       return fen;
    }

    var ENGINEMOVE_ = null, PONDER_ = null, int_engine = 0, enginetime = null;
    var ENGINE_ = null, ANALYZE_ = []
    function post(msg) { ENGINE_.postMessage(msg); }

    var wscore = 0, bscore=0, wcp = 0, bcp = 0, chessdata_ = null;
    async function loadStockfish() {
       ENGINE_ = await new Worker('/wasm/stockfish.js');
       ENGINE_.onmessage = function(event) {
             var load = event.data ? event.data : event;
             var sdata = load.split(' ');
             var mate = sdata[8];
             var xcp   = parseInt(sdata[9]);
             var draw = Math.floor(parseInt(sdata[12]) / 2); 
             var win = ( parseInt(sdata[11])) / 1000;
             var draw = (parseInt(sdata[12])) / 1000;
             var loss = (parseInt(sdata[13])) / 1000;
             var wscore = (parseInt(sdata[11]) + parseInt(sdata[12])/2) / 1000;
             var bscore = (parseInt(sdata[13]) + parseInt(sdata[12])/2) / 1000;
             var srate = 1 / (1 + Math.exp(-0.004*xcp)); // formula from Landon Lehman blog site.
             var pv = load.lastIndexOf("pv");
             if (!isNaN(srate))  {
                ANALYZE_.push({ srate: srate, mt: mate, wscore: wscore, bscore: bscore, cp: xcp, 
					win: win, draw: draw, loss: loss, moves: load.slice(pv+3) } );
             }
             if (load.includes("info depth 0 score cp 0")) {
                 _POSSIBLE_STALE_MATE_ = true;  
                 log("possible stale mate ...");
             } else
             if (load.includes("mate 0")) {
                 _POSSIBLE_CHECK_MATE_ = true;  
                 log("possible check mate ...");
             } else
             if (load.includes("mate 1 ")) {
                 _CHECK_MATE_ = true;  
                 log("check mate ...");
             } else
             if (load.includes('bestmove')) {
                ENGINEMOVE_ = sdata[1];
                PONDER_ = sdata[3];
                if (ENGINEMOVE_ == "(none)" && _POSSIBLE_CHECK_MATE_ == true) {
                  _CHECK_MATE_ = true;
                  _NO_POSSIBLE_MOVES_ = true;
                  log("mate ...");
                } else
                if (ENGINEMOVE_ == "(none)" && _POSSIBLE_STALE_MATE_ == true) {
                  _STALE_MATE_ = true;
                  log("stalemate ...");
                } else
                if (typeof(PONDER_) == "undefined") { 
                  // _NO_POSSIBLE_MOVES_ = true;
		  log(_CHECK_MATE_);
                  log("(possible mate ...)");
                } 
             } 
       };
    }

    var BOOK_ = null;
    function searchECO() {
       var randmove = 0, book_ = "";
       var game_ = searchGame();
       const ecoran_ = [];
       BOOK_ = null;
       for (p in ECO_) {
          var eco = ECO_[p][2];
          if (typeof(eco) != "undefined") {
            if (eco.match(game_)) {
               ecoran_.push(ECO_[p]);
            } 
          }
       }
       randmove = Math.floor(Math.random() * ecoran_.length)
       if (ecoran_.length > 0 ) {
         var idx = (SIDETOMOVE_ == WHITE) ? (MOVECOUNT_ * 2): (MOVECOUNT_ * 2 + 1) , 
             move_ = null;
         BOOK_ = ecoran_[randmove]
         ecoid.innerHTML = BOOK_[0] 
         openingid.innerHTML = BOOK_[1] 
         variationid.innerHTML = BOOK_[2].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, ''); 
         move_ = BOOK_[2].split(' ')[idx]
         if (typeof(move_) != "undefined") { 
           move_ = move_.replace(/^[0-9]+\./g, "");
         } else BOOK_ = null; 
         if (BOOK_ != null && BOOK_[2].lastIndexOf("(") >=0 ) BOOK_ = null;
         return move_;
       }
       return null;
    }

    var ANALYZERATE_ = 50;
    function setRate() {
        var height = (!REVERSE) ? ANALYZERATE_ : 100 - ANALYZERATE_;
        chessrate.style.height = height + "%";
        chessside0.style.backgroundColor = (!REVERSE) ? "#FFFFFF" : "#404040";
        chessrate.style.backgroundColor = (!REVERSE) ? "#404040" : "#FFFFFF";
    }
    function searchBest(OPENING=true) {
        var load_ = null, found = 0, score = 0, moveit_ = null;
        var ponder_ = (typeof(PONDER_) == "undefined") ? "" : " " + PONDER_;
        var move_ = ENGINEMOVE_ + ponder_;
        var analyze = 50;
        for (p in ANALYZE_) {
          const l_ = ANALYZE_[p]; 
          found = l_.moves.lastIndexOf(move_); 
          if (found == 0) {
            if (l_.srate > score ) {
              load_ = l_;
              score = load_.srate
            }
          }
        }
        if (!ANALYZEGAME_ && OPENING) moveit_ = searchECO();
        if (load_ != null && load_.mt == "mate") { analyze = 100; } else
        if (moveit_ != null) { analyze = 50; } else { if (load_ != null) analyze = (load_.srate * 100) }
        ANALYZERATE_ = analyze;
        setRate();       
        // chessrate.style.height = analyze + "%"; 
        // chessside0.style.backgroundColor = (!REVERSE) ? "#FFFFFF" : "#404040";
        // chessrate.style.backgroundColor = (!REVERSE) ? "#404040" : "#FFFFFF";
        if (moveit_ != null) return moveit_;
        return null;
    }

/*
    var PROMOTE_ = false, PROMOTEPIECE_ = null;
    function promotePiece(piece) {
       PROMOTE_ = false; PROMOTEPIECE_ = piece;
       whitepromotionid.style.visibility = 'hidden';
       blackpromotionid.style.visibility = 'hidden';
       promo.style.visibility = "hidden";
    }

    var int_promote = 0;
    function readyPromote(piece, loc_) {
        if (int_promote > 200) {
           int_promote = 0;
           clearInterval(promotetime);
           takeMove(piece, loc_, 'Q'); // taking forever to decide, let's promote to Queen
           promotePiece(null);
        }
        if (!PROMOTE_ && PROMOTEPIECE_ != null) { 
           clearInterval(promotetime);
           takeMove(piece, loc_, PROMOTEPIECE_);
           promotePiece(null);
        }
        int_promote ++;
    }

    var promotetime = '';
    function promoteChoice(piece, loc_, color) {
       PROMOTE_ = true;
       promo.style.visibility = "visible";
       if (color == 'lt') {
         whitepromotionid.style.visibility = 'visible';
         blackpromotionid.style.visibility = 'hidden';
       } else {
         whitepromotionid.style.visibility = 'hidden';
         blackpromotionid.style.visibility = 'visible';
       }
       int_promote = 0;
       promotetime = setInterval(readyPromote, 50, piece, loc_);
    }
*/

    function updateMate()  {
      const chk = document.getElementById(LASTMOVE_);
      if (chk != null) {
        const cnt_ = LASTMOVE_.split('_')[1];
        const move_ = LASTMOVE_.split('_')[2];
        chk.innerHTML = (_CHECK_MATE_ || _NO_POSSIBLE_MOVES_) ? '#' : (_CHECK_KING_ ? '+' : '');
        for (p in ecoGame_) {
           const eco_ = ecoGame_[p];
           if (eco_ == cnt_ + '.' + move_ + '+') {
                ecoGame_[p] = cnt_ + '.' + move_ + '#';
           } else
           if (eco_ == move_ + '+') {
                ecoGame_[p] = move_ + '#';
            }
        }
      }
    }

    const bcapture = document.getElementById("bcapture");
    const wcapture = document.getElementById("wcapture");
    const wicon_ = { Q:'&#9813;', R:'&#9814;', B:'&#9815;', N:'&#9816;', P:'&#9817;' }
    const bicon_ = { Q:'&#9819;', R:'&#9820;', B:'&#9821;', N:'&#9822;', P:'&#9823;' }
    function sortBenchedPieces() {
        const white_ = { Q: 0, R: 0, B: 0, N: 0, P: 0 };
        const black_ = { Q: 0, R: 0, B: 0, N: 0, P: 0 };
        if (BOARDSIZE_ < 480) {
          bcapture.innerHTML = '';
          wcapture.innerHTML = '';
          return
        }
        for (p in Benched) {
           const piece = Benched[p];
           if (piece.color_.match(/lt$/)) {
             white_[piece.role] ++ ;
           } else {
             black_[piece.role_] ++ ;
           }
        }
        const pieces_ = ['Q','R','B','N','P'];
        var wpcs_ = '', bpcs_ = '';
        for (h in pieces_) {
           const pcs = pieces_[h];
           const wpiece = white_[pcs]; bpiece = black_[pcs];
           if (wpiece > 0) for (var i=1; i<=wpiece; i++) wpcs_ = wpcs_ + wicon_[pcs];
           if (bpiece > 0) for (var i=1; i<=bpiece; i++) bpcs_ = bpcs_ + bicon_[pcs];
        }
        bcapture.innerHTML = wpcs_; 
        wcapture.innerHTML = bpcs_; 
    }

    function isRepeatDraw() {  // Three-fold repetition of the same Position in the board.
        var fen = generateFEN("w", "-").split(' ')[0];
        _REPEAT_DRAW_.fen.push(fen);
        if (_REPEAT_DRAW_.fen.length >= 15) { // though rule says repetition could be anywhere in the whole game.
           _REPEAT_DRAW_.fen.shift(); // chops off the first element to manage length of array 
        } 
        var dupfen = {};
        _REPEAT_DRAW_.fen.forEach((i) => { dupfen[i] = ++dupfen[i] || 1} );
        for (p in dupfen) {
            var repeat = dupfen[p];
            if (repeat >= 3) doneGame(false, false, true, "Draw due to repetition of position!");
        }
    }

    function captureEngineMove() {
        if (int_engine > 150) { int_engine = 0; clearInterval(enginetime);  }
        int_engine ++;
        if (ENGINEMOVE_ != null) {
            int_engine = 0;
            clearInterval(enginetime);
            var oloc_ = ENGINEMOVE_.slice(0,2), nloc_ = ENGINEMOVE_.slice(-2);
            var piece = Board[oloc_];
            if (piece != null) {
                var move_ = null, role;
                move_ = searchBest();
                if (move_ != null) { // Book moves
                   piece = movePiece(((SIDETOMOVE_ == WHITE) ? 'lt' : 'dt'), { white: move_, black: move_ }, null, false).piece; 
                } else {
                   var promote = null;
                   if (ENGINEMOVE_.length == 5) {
                        promote = ENGINEMOVE_.slice(-1); 
                        if (promote.match(/[QBRNqbrn]/)) { nloc_ =  ENGINEMOVE_.slice(-3,-1); promote = promote.toUpperCase();  }
                   }
                   piece.move = { location: nloc_, promote: promote }
                   const src_ = identifySource(piece);
                   if (promote != null) {
                           move_ = nloc_ + '=' + promote;
                   } else
                   if (piece.restype_ == CASTLELONG) move_ = "O-O-O"; else
                   if (piece.restype_ == CASTLESHORT) move_ = "O-O"; else
                   if (piece.restype_ == EATPIECE) {
                   if (piece.role_ == 'P') 
                         move_ = piece.oldlocation_[0] + "x" + nloc_; 
                        else 
                        move_ = piece.role_ + src_ + "x" + nloc_; 
                    } else {
                         move_ = piece.role_.replace(/P/g,'') + src_ + nloc_;
                    }
                }
                moveIt(MOVECOUNT_ + 1, move_, (_CHECK_MATE_) ? '#' : (_CHECK_KING_ ? '+' : ''));
                TurnToPlay(piece);
                isRepeatDraw();
                if (_STALE_MATE_) { doneGame(false, false, true) }
                if (_CHECK_MATE_ && !_NO_POSSIBLE_MOVES_) {  // Engine is check mating the opponent ...
                     updateMate();
                     doneGame(false, true); 
                }
            } else { // Engine is trapped ... ?
                if (_STALE_MATE_) { doneGame(false, false, true) }
                if (_CHECK_MATE_ && _NO_POSSIBLE_MOVES_) { // Engine is check mated by the opponent ...
                     updateMate();
                     doneGame(false, true); 
                }
                TurnToPlay(piece);
            } 

            if (isEngineGame()) playEngine();
        }
    }


    var WPLAYER_ = HUMAN, BPLAYER_ = HUMAN;
    function choosePlayer(obj) {
        if (obj.id == "whiteplayerid") WPLAYER_ = obj.value;
        if (obj.id == "blackplayerid") BPLAYER_ = obj.value;
    }

    var MACHINECHOICE_ = false;
    function machineChoice() {
      machineid.style.visibility = (machineid.style.visibility == "visible") ? "hidden" : "visible";
      MACHINECHOICE_ = (machineid.style.visibility == "visible") ? true : false;
      const game = initHeader(false, false, false);
      infoHeader(game);
      playEngine();
    }

    function isEngineGame() {
       if (WPLAYER_ == MACHINE && SIDETOMOVE_ == WHITE) return true;
       if (BPLAYER_ == MACHINE && SIDETOMOVE_ == BLACK) return true;
       return false;
    }

    async function playEngine(enpassant = "-") {
       var whichside = null;
       if (!NEWGAME_ && !ANALYZEGAME_) return;
       if (WPLAYER_ == MACHINE && SIDETOMOVE_ == WHITE) whichside = "w"; else
       if (BPLAYER_ == MACHINE && SIDETOMOVE_ == BLACK) whichside = "b"; else return;
       var fen = generateFEN(whichside, enpassant);
       if (PTIMER_ == null) { initTimer(WHITE); initTimer(BLACK); setTimer() }
       var movetime =  Math.floor(Math.random() * 200 + 500)
       var depth =  Math.floor(Math.random() * 5 + 15)
       ENGINEMOVE_ = null; 
    
       _POSSIBLE_CHECK_MATE_ = false; _POSSIBLE_STALE_MATE_ = false; 
       _CHECK_MATE_ = false; _STALE_MATE_ = false; _NO_POSSIBLE_MOVES_ = false;
       ANALYZE_ = [];
       // post("setoption name Hash value 8888");
       // post("setoption name UCI_LimitStrength 2800");
       post("setoption name UCI_ShowWDL value true");
       post("setoption name UCI_AnalyseMode value true");
       post("setoption name MultiPV value 5");
       post("setoption name Slow Mover type spin default 84 min 10 max 1000");
       post("isready");
       post("ucinewgame");
       post("position fen " + fen);
       await post("go movetime " + movetime + " depth " + depth);
       int_engine = 0;
       enginetime = setInterval(captureEngineMove, 150);
    }

    function eventOffset(e) {
          e = e || window.event;
           edoc = (e.target && e.target.ownerDocument) || document;
           doc = edoc.documentElement;
           body = edoc.body;

           x = event.clientX +
              (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
              (doc && doc.clientLeft || body && body.clientLeft || 0);
           y = event.clientY +
              (doc && doc.scrollTop  || body && body.scrollTop  || 0) -
              (doc && doc.clientTop  || body && body.clientTop  || 0 );
          return { x: x, y: y }
    }

/*
    var zindex_ = 0;
    function mouseMove(e) {
           piece = this.targetmove_;
           var pos = eventOffset(e), x = pos.x, y = pos.y;

           piece.newPosX   = piece.startPosX - x;
           piece.newPosY   = piece.startPosY - y;
           piece.startPosX = x;
           piece.startPosY = y;
           piece.style.top  = (piece.offsetTop - piece.newPosY) + "px";
           piece.style.left = (piece.offsetLeft - piece.newPosX) + "px";
           piece.style.zIndex = 5; 
    }
*/

/*
    var MOUSEDU_ = false;
    function mouseDown(e)  {
         e.preventDefault();
         if (MACHINECHOICE_) return;
         if (RESIGN_ || FETCHEDGAME_ || PROMOTE_ || (!NEWGAME_ && !ANALYZEGAME_)) return;
         MOUSEDU_ = true;
         var center = Math.ceil(PIECESIZE_ / 2) 
         offsetLeft = chessdiv.offsetLeft + chessboard.offsetLeft + center; 
         offsetTop = chessdiv.offsetTop + chessboard.offsetTop + center; 
         this.startPosX = offsetLeft + this.offsetLeft;
         this.startPosY = offsetTop + this.offsetTop ;
         chessboard.targetmove_ = this;
         chessboard.addEventListener('mousemove', mouseMove);
    }

    // chessboard.addEventListener('mouseup', captureHumanMove);
*/

/*
    function repositionPiece(obj) {
       var target = obj.targetmove_;
       if (target != null) {
          const piece = target.pclass;
          if (piece != null) {
             target.className = 'piece p_' + reverseLoc(piece.location_); 
             target.style.top = ''; target.style.left = '';
             target.style.zIndex = 0;
             chessboard.removeEventListener('mousemove', mouseMove);
          }
       }
    }
*/
 
/*
    function captureHumanMove()  {
      if (!NEWGAME_ && MOUSEDU_) { repositionPiece(this);  MOUSEDU_ = false; return }
      MOUSEDU_ = false;
      if (MACHINECHOICE_) return;
      if (!NEWGAME_ && !ANALYZEGAME_) message('No game running. You can create a new game.', false);
      if (RESIGN_ || FETCHEDGAME_ || PROMOTE_ || (!NEWGAME_ && !ANALYZEGAME_)) return;
      if (typeof(this.targetmove_) != 'undefined') {
      if (PTIMER_ == null) { initTimer(WHITE); initTimer(BLACK); setTimer() }; 
               PRACTICEGAME_ = true; 
               var piece = this.targetmove_, loc_ = null;
               var loffset = piece.offsetLeft, toffset = piece.offsetTop;
               var center =   Math.ceil(PIECESIZE_ / 2);
               var x = loffset + center; var y = toffset + center;
               var cls_ = null, clsp_ = null, loc_ = null, woffs = PIECESIZE_;
               var BRK = false;
               for (h in horiz) {
                 for (var v=1; v<=8; v++) {
                     loc_ = horiz[h] + v; 
                     clsp_ =  "p_" + reverseLoc(loc_);  
                     cls_ = sizeLoc[reverseLoc(loc_)];
                     if (cls_.left < x && cls_.left + woffs > x && cls_.top < y && cls_.top + woffs > y) {
                        try {
		            var promote = null, move_ = null, pclass = piece.pclass;
                            if (SIDETOMOVE_ == WHITE && pclass.color_.match(/dt$/)) { BRK = true; break; }
                            if (SIDETOMOVE_ == BLACK && pclass.color_.match(/lt$/)) { BRK = true; break; }
                            if (pclass.role == 'P') {
                               if (pclass.color == 'plt' && v == 8) promote = 'lt';
                               if (pclass.color == 'pdt' && v == 1) promote = 'dt';
                            } 
                            if (promote == null) {
                               takeMove(pclass, loc_, promote);
                            } else {
                               promoteChoice(pclass, loc_, promote);  
                            }
                            if (MOVECOUNT_ >= 0) DONEGAME_ = false; 
                            BRK = true; break;
                        } catch(e) { 
                            if (typeof(e.lastIndexOf) != "undefined") {
                              var s = e.lastIndexOf('endangering its own king'),
                                  p = e.lastIndexOf('Not able to find proper pieces');
                              if (s >= 0 || p >=0) { undoitMove(false, false); }  else log(e);
                            } else {
                               log(e);
                            }
                        }
                     } 
                 }
                 if (BRK) break;
               }
               piece.style.top = ''; piece.style.left = '';
               piece.style.zIndex = 0;
               this.removeEventListener('mousemove', mouseMove);
      }
    }
*/

    function identifySource(Board, piece_, move_) {
       var src_ = '', srch_ = '', srcv_ = '';
       for (var p in Board) {
         const piece = Board[p];
         if (src_.length == 2) break; // we got the full source
         if (piece != null && piece.role_ == piece_.role_) {
             if (piece_ !== piece) {
               if (piece_.color_ == piece.color_) {
                  const ro_ = piece_.role_, oh_ = (piece_.oldlocation_ != null) ? piece_.oldlocation_[0] : null, 
                                            ov_ = (piece_.oldlocation_ != null) ? piece_.oldlocation_[1] : null, 
                       nh_ = piece_.location_[0], nv_ = piece_.location_[1];
                  const ro = piece.role_, oh = (piece.oldlocation_ != null) ? piece.oldlocation_[0] : null, 
                                          ov = (piece.oldlocation_ != null) ? piece.oldlocation_[1] : null, 
                        nh = piece.location_[0], nv = piece.location_[1];
             
                  for (y in ['R', 'Q']) {
                    const mro = ['R', 'Q'][y];
                    if (ro_ == mro) {
                      var blk_ = false;
                      if (nv_ == nv) {
                          const d1 = oh_.charCodeAt(0), d2 = nh.charCodeAt(0);
                          const mi = (d1 < d2) ? d1 : d2, mx = (d1 < d2) ? d2 : d1
                          for (var i = mi;  i <= mx; i++) { 
                               const hv = String.fromCharCode(i) + nv_;
                               if (Board[hv] != null && Board[hv].role_ != mro ) { blk_ = true; break }
                          }
                      } else // end if ov_ == ov
                      if (nh_ == nh) {
                          const mi = (ov_ < nv) ? ov_ : nv, mx = (ov_ < nv) ? nv : ov_ 
                          for (var i = mi;  i <= mx; i++) {
                               const hv = nh_ + i;
                               if (Board[hv] != null && Board[hv].role_ != mro ) { blk_ = true; break }
                          }
                      } 
                      if (!blk_ && (nv_ == nv || nh_ == nh)) { 
                            if (src_.length == 0) {
                               if (oh_ != nh) src_ = oh_; else src_ = ov_;
                            } else
                            if (src_.length == 1) {
                                   if (src_ == oh_) src_ = src_ + ov_;
                                   if (src_ == ov_) src_ = oh_ + src_ ;
                            }
                      }
                    } // end ro == 'R'
                  } // end for mro

                  for (y in ['B', 'Q']) {
                    const mro = ['B', 'Q'][y];
                    if (ro_ == mro) {
                      var blk_ = false;
                      const d1 = nh.charCodeAt(0), d2 = nh_.charCodeAt(0), diff_h = Math.abs(d1 - d2), diff_v = Math.abs(nv - nv_);
                      if (diff_h == diff_v) {
                         const mi = (d1 < d2) ? d1 : d2, mx = (d1 < d2) ? d2 : d1
                         for (var i=1; i<=diff_h; i++) {
                             const hv = String.fromCharCode(mi + i) + (parseInt(nv) < parseInt(nv_) ? (parseInt(nv) + i) : (parseInt(nv) - i));
                             if (Board[hv] != null && Board[hv].role_ != mro ) { blk_ = true; break }
                         }
                         if (!blk_) {
                            if (src_.length == 0) {
                               if (oh_ != nh) src_ = oh_; else src_ = ov_;
                            } else
                            if (src_.length == 1) {
                                   if (src_ == nh) src_ = src_ + ov_;
                                   if (src_ == nv) src_ = oh_ + src_ ;
                            }
                         } 
                      }
                    } // end ro == 'B'
                  } // end for mro

                  if (ro_ == 'N') {
                      const d1 = nh.charCodeAt(0), d2 = nh_.charCodeAt(0), diff_h = Math.abs(d1 - d2), diff_v = Math.abs(nv - nv_);
                      if ((diff_h == 1 && diff_v == 2) || (diff_h == 2 && diff_v == 1)) { 
                        if (src_.length == 0) {
                               if (oh_ != nh) src_ = oh_; else src_ = ov_;
                        } else
                        if (src_.length == 1) {
                               if (src_ == nh) src_ = src_ + ov_;
                               if (src_ == nv) src_ = oh_ + src_ ;
                        }
                      }
                  }


                } // end if piece.color
              } // end if piece != piece
          } // end if piece null
       } // end for
       return src_;
    }

    function getImgSrc(tag) {
      if (RMOO_PIECES_ == true ) {
        const piece_path = "/images/rmoo_";
        return piece_path + tag + ".svg";
      } else {
        const piece_path = "/images/Chess_";
        return piece_path + tag + "45.svg";
      }
    }

    var LASTPIECE_ = null;
    // Piece class
    class Piece111111 {
       constructor(role, tag, location) {
          this.image(role, tag, location);              
       }

       image(role, tag, location, ol = 0, img = 0) { 
           this.role_ = role;
           this.color_ = tag;
           this.location_ = location;
           if (ol == 0) this.oldlocation_ = null;
           this.active_ = 1;
           if (img == 0) this.piece = document.createElement("img");
           this.piece.id   = role + location;
           this.piece.src = getImgSrc(tag);
           this.piece.className = "piece " + "p_" + reverseLoc(location);
           this.piece.style.display = "block";
           this.piece.style.cursor = "pointer"; 
           this.piece.addEventListener('mousedown', mouseDown);
           this.piece.pclass = this;
        }

       get role() { return this.role_; }
       get location() { return this.location_; }
       get oldlocation() { return this.oldlocation_; }
       get getpiece() { return this.piece; }
       get color() { return this.color_; }
  
       set active(s) {
          if (s == 0) {
             this.piece.style.visibility = "hidden";
             this.active_ = s;
          }
       }

       set promote_piece(what) {
         if (what == "=Q" || what == "(Q)" || what == "Q") {
          if (this.color_ == 'plt' && this.location_[1] == '7' ) { this.image('Q', 'qlt', this.location_, 1, 1); return } 
          if (this.color_ == 'pdt' && this.location_[1] == '2' ) { this.image('Q', 'qdt', this.location_, 1, 1); return } 
         } else
         if (what == "=R" || what == "(R)" || what == "R") {
          if (this.color_ == 'plt' && this.location_[1] == '7') { this.image('R', 'rlt', this.location_, 1, 1); return } 
          if (this.color_ == 'pdt' && this.location_[1] == '2') { this.image('R', 'rdt', this.location_, 1, 1); return } 
         } else
         if (what == "=B" || what == "(B)" || what == "B") {
          if (this.color_ == 'plt' && this.location_[1] == '7') { this.image('B', 'blt', this.location_, 1, 1); return } 
          if (this.color_ == 'pdt' && this.location_[1] == '2') { this.image('B', 'bdt', this.location_, 1, 1); return } 
         } else
         if (what == "=N" || what == "(N)" || what == "N") {
          if (this.color_ == 'plt' && this.location_[1] == '7') { this.image('N', 'nlt', this.location_, 1, 1); return } 
          if (this.color_ == 'pdt' && this.location_[1] == '2') { this.image('N', 'ndt', this.location_, 1, 1); return } 
         } 
         illegal_move("Illegal move (81)!"); 
       }

    

       get_location(obj) {
         const oldlocation = obj.oldlocation;
         const oh = (oldlocation != null) ? oldlocation[0].charCodeAt(0) : null;
         const ov = (oldlocation != null) ? oldlocation[1] : null;
         return { nh: obj.location[0].charCodeAt(0 ), nv: parseInt(obj.location[1]), oh: oh, ov: ov };
       }

    }  // end Piece class


    function threat_by_bishop(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, Queen = 0) {
            var Board = game.Board_;
            var this_ = pclass;
            var threat = 0;
            var colorl = (Queen) ? 'qlt' : 'blt';
            var colord = (Queen) ? 'qdt' : 'bdt';
            if (diff_kdh == diff_kdv && Piece.color_ == colorl) {  var bthreat = 1;
                 for (var v = 1; v < diff_kdv; v++) {
                     const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + v) : (KD_loc.nv - v);
                     const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + v) : (KD_loc.nh - v);
                     const nh = String.fromCharCode(dist);
                     if (Board[nh + nv]  != null)  { bthreat = 0; break }
                 }
                 threat = bthreat;
            }
            if (diff_klh == diff_klv && Piece.color_ == colord) {  var bthreat = 1;
                 for (var v = 1; v < diff_klv; v++) {
                     const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + v) : (KL_loc.nv - v);
                     const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + v) : (KL_loc.nh - v);
                     const nh = String.fromCharCode(dist);
                     if (Board[nh + nv]  != null)  { bthreat = 0; break }
                 }
                 threat = bthreat;
            }
             _CHECK_KING_ = _CHECK_KING_ || (threat && this_.color_.slice(-2) == Piece.color_.slice(-2))
             threat = _CHECK_KING_ ? 0 : threat; // not endangering itself
             return  threat;
    }

    function threat_by_rook(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, Queen = 0) {
             var Board = game.Board_;
             var this_ = pclass;
             var nh = null, nv = null, threat = 0;
             var colorl = (Queen) ? 'qlt' : 'rlt';
             var colord = (Queen) ? 'qdt' : 'rdt';
             if (diff_kdh == 0 && diff_kdv > 0 && Piece.color_ == colorl ) { var rthreat = 1;
                 for (var v = 1; v < diff_kdv; v++) {
                     const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + v) : (KD_loc.nv - v);
                     const nh = String.fromCharCode(KD_loc.nh);
                     if (Board[nh + nv]  != null)  { rthreat = 0; break }
                 }
             } else
             if (diff_kdv == 0 && diff_kdh > 0 && Piece.color_ == colorl) { var rthreat = 1;
                 for (var h = 1; h < diff_kdh; h++) {
                     const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + h) : (KD_loc.nh - h);
                     const  nh = String.fromCharCode(dist);
                     if (Board[nh + KD_loc.nv]  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             }
             if (diff_klh == 0 && diff_klv > 0 && Piece.color_ == colord) { var rthreat = 1;
                 for (var v = 1; v < diff_klv; v++) {
                     const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + v) : (KL_loc.nv - v);
                     const nh = String.fromCharCode(KL_loc.nh);
                     if (Board[nh + nv]  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             }  else
             if (diff_klv == 0 && diff_klh > 0 && Piece.color_ == colord) { var rthreat = 1;
                 for (var h = 1; h < diff_klh; h++) {
                     const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + h) : (KL_loc.nh - h);
                     const  nh = String.fromCharCode(dist);
                     if (Board[nh  + KL_loc.nv]  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             }
             _CHECK_KING_ = _CHECK_KING_ || (threat && this_.color_.slice(-2) == Piece.color_.slice(-2))
             threat = _CHECK_KING_ ? 0 : threat; // not endangering itself
             return threat;
    }

    function threat_by_knight(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv) {
             var Board = game.Board_;
             var this_ = pclass;
             var nthreat = 0;
             if (diff_kdv == 2 && diff_kdh == 1 && Piece.color_ == 'nlt') {
                 const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + 1) : (KD_loc.nh - 1);
                 const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + 2) : (KD_loc.nv - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv]  != null)  { nthreat = 1; }
             } else
             if (diff_kdh == 2 && diff_kdv == 1 && Piece.color_ == 'nlt') {
                 const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + 1) : (KD_loc.nv - 1);
                 const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + 2) : (KD_loc.nh - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv]  != null)  { nthreat = 1; }
             }
             if (diff_klv == 2 && diff_klh == 1 && Piece.color_ == 'ndt') {
                 const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + 1) : (KL_loc.nh - 1);
                 const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + 2) : (KL_loc.nv - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv]  != null)  { nthreat = 1; }
             } else
             if (diff_klh == 2 && diff_klv == 1 && Piece.color_ == 'ndt') {
                 const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + 1) : (KL_loc.nv - 1);
                 const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + 2) : (KL_loc.nh - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv]  != null)  { nthreat = 1; }
             }
             _CHECK_KING_ = _CHECK_KING_ || (nthreat && this_.color_.slice(-2) == Piece.color_.slice(-2))
             nthreat = _CHECK_KING_ ? 0 : nthreat; // not endangering itself
             return nthreat;
    }

    function get_location(obj) {
         const oldlocation = obj.oldlocation;
         const oh = (oldlocation != null) ? oldlocation[0].charCodeAt(0) : null;
         const ov = (oldlocation != null) ? oldlocation[1] : null;
         return { nh: obj.location[0].charCodeAt(0 ), nv: parseInt(obj.location[1]), oh: oh, ov: ov };
    }


    function  evaluate_king_threat(game, pclass, RES) {
          var Board = game.Board_;
          var this_ = pclass;
          var KD = null, KL = null;
          // find the kings
          for (var p in Board) {
               const Piece = Board[p];
               if (Piece != null) {
                  if (Piece.role == 'K') {
                     if (Piece.color_ == 'klt') {
                         KL = Piece;
                     } else
                     if (Piece.color_ == 'kdt') {
                         KD = Piece;
                     }
                  }
               }
          }
          var KDR_loc = null,  KLR_loc = null;
          if (RES == CASTLESHORT) {
              const KDR = new game.Piece(game, "K", "kdt", "f8");
              const KLR = new game.Piece(game, "K", "klt", "f1");
              KDR_loc = get_location(KDR);
              KLR_loc = get_location(KLR);
          } else
          if (RES == CASTLELONG) {
              const KDR = new game.Piece(game, "K", "kdt", "d8");
              const KLR = new game.Piece(game, "K", "klt", "d1");
              KDR_loc = get_location(KDR);
              KLR_loc = get_location(KLR);
          }
          const KD_loc = get_location(KD); const KL_loc = get_location(KL);
          // evaluate the pieces
          var threat = 0;
          _CHECK_KING_ = false;
          for (var p in Board) {
               const Piece = Board[p];
               // if (Piece === this_) continue;
               if (Piece != null) {
                  const ploc = get_location(Piece);
                  const diff_kdh = Math.abs(KD_loc.nh - ploc.nh); const diff_kdv = Math.abs(KD_loc.nv - ploc.nv);
                  const diff_klh = Math.abs(KL_loc.nh - ploc.nh); const diff_klv = Math.abs(KL_loc.nv - ploc.nv);
                  var diff_kdrh = 0, diff_kdrv = 0, diff_klrh = 0, diff_klrv = 0;
                  if (KDR_loc != null && KLR_loc != null) {
                    diff_kdrh = Math.abs(KDR_loc.nh - ploc.nh); diff_kdrv = Math.abs(KDR_loc.nv - ploc.nv);
                    diff_klrh = Math.abs(KLR_loc.nh - ploc.nh); diff_klrv = Math.abs(KLR_loc.nv - ploc.nv);
                  }
                  if (Piece.role == 'K') {
                      var kthreat = 0;
                      if (Piece.color_ == 'klt') {
                         if ((diff_kdh == 0 && diff_kdv == 1) || (diff_kdv == 0 && diff_kdh == 1)) { kthreat = 1; }
                         if ((diff_kdh ==  diff_kdv && diff_kdv == 1)) { threat = 1; }
                      } else {
                         if ((diff_klh == 0 && diff_klv == 1) || (diff_klv == 0 && diff_klh == 1)) { kthreat = 1; }
                         if ((diff_klh ==  diff_klv && diff_klv == 1)) { threat = 1; }
                      }
                      _CHECK_KING_ = _CHECK_KING_ || (kthreat && this_.color_.slice(-2) == Piece.color_.slice(-2))
                      kthreat = _CHECK_KING_ ? 0 : kthreat; // not endangering itself
                      threat = (kthreat) ? -1 : threat;

                  } else
                  if (Piece.role == 'Q') {
                      const bthreat = threat_by_bishop(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, 1);
                      const rthreat = threat_by_rook(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, 1);
                      threat = (bthreat || rthreat) ? 2 : threat;
                      if (KDR_loc != null && KLR_loc != null) { // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const bthreat1 = threat_by_bishop(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv, 1);
                        const rthreat1 = threat_by_rook(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv, 1);
                        threat = (bthreat1 || rthreat1) ? -2 : threat;
                      }
                  } else
                  if (Piece.role == 'B') {
                      const bthreat = threat_by_bishop(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv);
                      threat = (bthreat) ? 3 : threat;
                      if (KDR_loc != null && KLR_loc != null) { // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const bthreat1 = threat_by_bishop(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv);
                        threat = (bthreat1) ? -3 : threat;
                      }
                  } else
                  if (Piece.role == 'R') {
                      const rthreat = threat_by_rook(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv);
                      threat = (rthreat) ? 4 : threat;
                      if (KDR_loc != null && KLR_loc != null) {  // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const rthreat1 = threat_by_rook(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv);
                        threat = (rthreat1) ? -4 : threat;
                      }
                  } else
                  if (Piece.role == 'N') {
                      const nthreat = threat_by_knight(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv);
                      threat = (nthreat) ? 5 : threat;
                      if (KDR_loc != null && KLR_loc != null) {  // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const nthreat1 = threat_by_knight(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv);
                        threat = (nthreat1) ? -5 : threat;
                      }
                  } else
                  if (Piece.role == 'P') {
                     var pthreat = 0, pthreat1 = 0;
                     if (diff_klh == 1 && diff_klv == 1) {
                       if (KL_loc.nv < ploc.nv && Piece.color_ == 'pdt') { pthreat = 1; }
                     }
                     if (diff_kdh == 1 && diff_kdv == 1) {
                       if (KD_loc.nv > ploc.nv && Piece.color_ == 'plt') { pthreat = 1; }
                     }
                     _CHECK_KING_ = _CHECK_KING_ || (pthreat && this_.color_.slice(-2) == Piece.color_.slice(-2))
                     pthreat = _CHECK_KING_ ? 0 : pthreat; // not endangering itself
                     threat = (pthreat) ? 6 : threat;
                     if (KDR_loc != null && KLR_loc != null) {  // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                       if (diff_klrh == 1 && diff_klrv == 1) {
                         if (KLR_loc.nv < ploc.nv && Piece.color_ == 'pdt') { pthreat1 = 1; }
                       }
                       if (diff_kdrh == 1 && diff_kdrv == 1) {
                         if (KDR_loc.nv > ploc.nv && Piece.color_ == 'plt') { pthreat1 = 1; }
                       }
                       threat = (pthreat1) ? -6 : threat;
                     }
                  }
                  if (threat) { illegal_move("Move is endangering its own king (" + threat + ")!"); }
               }
          }
          return threat;
    }


    function take_piece(Board, location, color, code) {
           if (Board[location] != null ) { // Check if something to eat!
                 var board_ = Board[location];
                 if (board_.color_.match(color)) {
                     if (board_.role == 'K') {
                       illegal_move("Cannot eat king!");
                     } else
                     return EATPIECE;
                 }
           }
           illegal_move("Illegal move " + code + "!");
    }

    function assertMove(game, pclass, location) {
         const Board = game.Board_
         const this_ = pclass;
         const locations = { oh: this_.location_[0], ov: parseInt(this_.location_[1]),
                             nh: location[0],       nv: parseInt(location[1]) }
         if (this_.role_ == "K") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h == 1) ||
                (diff_h == 0 && diff_v == 1) ||
                (diff_v == diff_h && diff_v == 1)) {
                if (Board[location] != null ) { // Check if something to eat!
                      if (this_.color_ == "klt") {
                         return take_piece(Board, location, /dt$/, '22');
                      } else
                      if (this_.color_ == "kdt") {
                         return take_piece(Board, location, /lt$/, '21');
                      }
                } else {
                  const oh = this_.location_;
                  const nh = locations.nh, nv = locations.nv
                  const nh1 = String.fromCharCode(this_nh + 1);
                  const nh2 = String.fromCharCode(this_nh - 1);
                  const nv1 = locations.nv + 1;
                  const nv2 = locations.nv - 1;
                  if (
                      (Board[nh1 + nv1] != null && Board[nh1 + nv1].role_.match(/[Kk]/) && this_.location_ != nh1 + nv1)  ||
                      (Board[nh1 + nv2] != null && Board[nh1 + nv2].role_.match(/[Kk]/)  && this_.location_ != nh1 + nv2) ||
                      (Board[nh2 + nv1] != null && Board[nh2 + nv1].role_.match(/[Kk]/) && this_.location_ != nh2 + nv1) ||
                      (Board[nh2 + nv2] != null && Board[nh2 + nv2].role_.match(/[Kk]/) && this_.location_ != nh2 + nv2) ||
                      (Board[nh + nv1] != null && Board[nh + nv1].role_.match(/[Kk]/) && this_.location_ != nh + nv1) ||
                      (Board[nh + nv2] != null && Board[nh + nv2].role_.match(/[Kk]/) && this_.location_ != nh + nv2) ||
                      (Board[nh1 + nv] != null && Board[nh1 + nv].role_.match(/[Kk]/) && this_.location_ != nh1 + nv) ||
                      (Board[nh2 + nv] != null && Board[nh2 + nv].role_.match(/[Kk]/) && this_.location_ != nh2 + nv)
                  ) {
                      illegal_move("King faces king!");
                  }
                  return GOODMOVE;
                }
            } else // consider castling
            if (diff_v == 0 && diff_h == 2) {
                 if (this_oh < this_nh) {
                     const oh1 = String.fromCharCode(this_oh + 1);
                     const oh2 = String.fromCharCode(this_oh + 2);
                     if ((Board[oh1 + locations.nv] == null) &&
                         (Board[oh2 + locations.nv] == null) &&
                           this_.oldlocation_ == null ) {
                        if (_CHECK_KING_) illegal_move("King is under check!");
                        if ((oh1 + locations.nv != 'f1' && oh2 + locations.nv != 'g1') &&
                            (oh1 + locations.nv != 'f8' && oh2 + locations.nv != 'g8')) {
                              illegal_move("Illegal move (50k)!");
                        };
                        return CASTLESHORT;
                     } else { illegal_move("Illegal move (50)!"); }
                 } else {
                     const oh1 = String.fromCharCode(this_oh - 1);
                     const oh2 = String.fromCharCode(this_oh - 2);
                     if ((Board[oh1 + locations.nv] == null) &&
                         (Board[oh2 + locations.nv] == null) &&
                          this_.oldlocation_ == null) {
                       if (_CHECK_KING_) illegal_move("King is under check!");
                       if ((oh1 + locations.nv != 'd1' && oh2 + locations.nv != 'c1') &&
                           (oh1 + locations.nv != 'd8' && oh2 + locations.nv != 'c8')) {
                              illegal_move("Illegal move (51k)!");
                       };
                       return CASTLELONG;
                     } else { illegal_move("Illegal move (51)!"); }
                 }
            }
            else { illegal_move("Illegal move (20)!"); }
         } else // Queen
         if (this_.role_ == "Q") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h > 0) ||
                (diff_h == 0 && diff_v > 0) ||
                (diff_v == diff_h && diff_v != 0)) {

                // check bishop-like obstruction
                if (diff_v == diff_h && diff_v != 0)
                for (let i=1; i < diff_v; i++) {
                  var oh = null, ov = null;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else {
                     oh = String.fromCharCode(this_oh - i);
                  }
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else {
                     ov = locations.ov - i;
                  }
                  if (Board[oh + ov] != null) {
                     illegal_move("Illegal move (33)!");
                  }
                }

                // check root-like obstruction
                if ((diff_v == 0 && diff_h > 0) ||
                   (diff_h == 0 && diff_v > 0))
                for (let i=1; i < ( (diff_v < diff_h) ? diff_h : diff_v ); i++) {
                  var oh = String.fromCharCode(this_oh), ov = locations.ov;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else
                  if (this_oh >this_nh) {
                     oh = String.fromCharCode(this_oh - i);
                  } else
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else
                  if (locations.ov > locations.nv) {
                     ov = locations.ov - i;
                  } else {
                     illegal_move("Illegal move (34)!");
                  }
                  if (Board[oh + ov] != null) {
                     illegal_move("Illegal move (35)!");
                  }
                }


                if (Board[location] != null ) { // Check if something to eat!
                      if (this_.color_ == "qlt") {
                         return take_piece(Board, location, /dt$/, '18');
                      } else
                      if (this_.color_ == "qdt") {
                         return take_piece(Board, location, /lt$/, '19');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (17)!"); }
         } else // Rook
         if (this_.role_ == "R") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h > 0) ||
                (diff_h == 0 && diff_v > 0)) {

                // check rook obstruction
                for (let i=1; i < ( (diff_v < diff_h) ? diff_h : diff_v ); i++) {
                  var oh = String.fromCharCode(this_oh), ov = locations.ov;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else
                  if (this_oh >this_nh) {
                     oh = String.fromCharCode(this_oh - i);
                  } else
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else
                  if (locations.ov > locations.nv) {
                     ov = locations.ov - i;
                  } else {
                     illegal_move("Illegal move (31)!");
                  }
                  if (Board[oh + ov] != null) {
                     illegal_move("Illegal move (32)!");
                  }
                }
                if (Board[location] != null ) { // Check if something to eat!
                      if (this_.color_ == "rlt") {
                         return take_piece(Board, location, /dt$/, '15');
                      } else
                      if (this_.color_ == "rdt") {
                         return take_piece(Board, location, /lt$/, '16');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (14)!"); }
         } else // Bishop
         if (this_.role_ == "B") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const aha1 = String.fromCharCode(this_oh);
            const aha2 = String.fromCharCode(this_nh);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if (diff_v == diff_h && diff_v != 0) {
                // check bishop obstruction
                for (let i=1; i < diff_v; i++) {
                  var oh = null, ov = null;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else {
                     oh = String.fromCharCode(this_oh - i);
                  }
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else {
                     ov = locations.ov - i;
                  }
                  if (Board[oh + ov] != null) {
                     illegal_move("Illegal move (31)!");
                  }
                }
                if (Board[location] != null ) { // Check if something to eat!
                      if (this_.color_ == "blt") {
                         return take_piece(Board, location, /dt$/, '12');
                      } else
                      if (this_.color_ == "bdt") {
                         return take_piece(Board, location, /lt$/, '13');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (11)!"); }

         } else // if Knight
         if (this_.role_ == "N") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            if (locations.ov + 2 == locations.nv ||
                locations.ov == locations.nv + 2) {
                if (this_nh == this_oh + 1 || this_nh + 1 == this_oh) {
                   if (Board[location] != null ) { // Check if something to eat!
                      if (this_.color_ == "nlt") {
                         return take_piece(Board, location, /dt$/, '8');
                      } else
                      if (this_.color_ == "ndt") {
                         return take_piece(Board, location, /lt$/, '9');
                      }
                   } else {
                       return GOODMOVE;
                   }
                } else { return take_piece(Board, location, "na", "5"); }
            } else
            if (this_nh + 2 == this_oh ||
                this_nh == this_oh + 2) {
                if (locations.nv == locations.ov + 1 || locations.nv + 1 == locations.ov) {
                   if (Board[location] != null ) { // Check if something to eat!
                      if (this_.color_ == "nlt") {
                         return take_piece(Board, location, /dt$/, '10');
                      } else
                      if (this_.color_ == "ndt") {
                         return take_piece(Board, location, /lt$/, '11');
                      }
                   } else {
                       return GOODMOVE;
                   }
                } else { return take_piece(Board, location, "na", "6"); }
            }
            else { return take_piece(Board, location, "na", "7"); }
         } else // if Pawn
         if (this_.role_ == "P") {
             if (locations.oh == locations.nh) {
               if (this_.color_ == "plt") {
                  if (( locations.ov == 2 && ( locations.nv == 3 || locations.nv == 4 ))) {
                     // check obstruction
                     if (locations.nv == 3 && Board[locations.oh + 3] != null) {
                          illegal_move("Illegal move (40)!");
                     } else
                     if (locations.nv == 4 && ( Board[locations.oh + 3] != null ||
                                                Board[locations.oh + 4] != null )) {
                          illegal_move("Illegal move (41)!");
                     }
                     return GOODMOVE;
                  } else if (locations.ov >= 3 && locations.ov + 1 == locations.nv && locations.nv <= 8) {
                     if ( Board[locations.oh + locations.nv] != null) {
                          illegal_move("Illegal move (42)!");
                     }
                     return GOODMOVE;
                  } else {
                     illegal_move("Illegal pawn move (42a)!");
                  }
                } else {
                  if (( locations.ov == 7 && ( locations.nv == 6 || locations.nv == 5 ))) {
                     // check obstruction
                     if (locations.nv == 6 && Board[locations.oh + 6] != null) {
                          illegal_move("Illegal move (43)!");
                     } else
                     if (locations.nv == 5 && ( Board[locations.oh + 6] != null ||
                                                Board[locations.oh + 5] != null )) {
                          illegal_move("Illegal move (44)!");
                     }
                     return GOODMOVE;
                  } else if (locations.ov <= 6 && locations.ov - 1 == locations.nv && locations.nv >= 1) {
                     if ( Board[locations.oh + locations.nv] != null) {
                          illegal_move("Illegal move (45)!");
                     }
                     return GOODMOVE;
                  } else {
                    illegal_move("Illegal pawn move (46)!");
                  }
                }
             } else { // (locations.oh != locations.nh) -- diagonal means eat
                 const this_nh = locations.nh.charCodeAt(0);
                 const this_oh = locations.oh.charCodeAt(0);
                 const diff_h = Math.abs(this_nh - this_oh);
                 const diff_v = Math.abs(locations.ov - locations.nv);
                 if (diff_h > 1 || diff_v > 1) { illegal_move("Illegl pawn move (47)!"); }
                 if (Board[location] != null) { // something to eat?
                   if (this_.color_ == "plt") {
                      if (locations.ov < locations.nv) {
                        return take_piece(Board, location, /dt$/,'48');
                      } else { illegal_move("Illegal move(54)"); }
                    } else {
                      if (locations.ov > locations.nv) {
                         return take_piece(Board, location, /lt$/,'49');
                      } else { illegal_move("Illegal move(55)"); }

                    }
                 } else { // en passant?
                    log("en passant!!!");
                    if (LASTPIECE_ != null) {
                        const that = LASTPIECE_;
                        const that_location = { nh: that.location_[0], nv: parseInt(that.location[1]),
                                                oh: that.oldlocation[0], ov: parseInt(that.oldlocation[1]) }
                        const this_nh = locations.nh.charCodeAt(0);
                        const this_oh = locations.oh.charCodeAt(0);
                        const that_nh = that_location.nh.charCodeAt(0);
                        const that_oh = that_location.oh.charCodeAt(0);
                        const diff_v = Math.abs(that_location.ov - that_location.nv);
                        const diff_h = Math.abs(that_nh - this_nh);
                        if (that_oh != that_nh || that.role != 'P' ||
                            diff_v != 2 || diff_h != 0 || that_location.nv != locations.ov )
                                { illegal_move("Illegal move(53)"); }

                        if (this_.color_ == "plt") {
                            if (locations.ov < locations.nv) {
                                return ENPASSANT;
                            } else { illegal_move("Illegal move(56)"); }
                        } else {
                            if (locations.ov > locations.nv) {
                                return ENPASSANT;
                             } else { illegal_move("Illegal move(57)"); }
                        }
                    } else {
                       illegal_move("Illegal pawn move (52)!");
                    }
                 }
             }
         }
         return UNMOVE;
    }

    function move(game, pclass, what) {
           const Board = game.Board_;
           const Benched = game.Bench_;
           const this_ = pclass;
           const location = what.location;
           const promote = what.promote;
           const Undo = game.Undo_;
           const GAME_STATE = game.GAME_STATE;
           var LASTPIECE_ = GAME_STATE.lastpiece_;
           const RES = assertMove(game, pclass, location);
           if (RES == ENPASSANT) {
                  var len = Benched.length;
                  this_.restype_ = RES;
                  LASTPIECE_.active = 0;
                  Benched.push ( LASTPIECE_ );
                  Board[location] = this_;
                  Board[this_.location_] =  null;
                  Board[LASTPIECE_.location_] =  null;
                  Undo.push( { type: RES, color: this_.color_, piece: this_, benched: LASTPIECE_,
                                oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                  sortBenchedPieces();
           } else
           if (RES == EATPIECE) {
                  var len = Benched.length;
                  this_.restype_ = RES;
                  Board[location].active = 0;
                  Benched.push ( Board[location]);
                  if (promote != null && promote != "") { 
                       this_.role_ = promote;
                       this_.color_ =  (this_.color_ == 'plt') ? promote.toLowerCase() + 'lt' : promote.toLowerCase() + 'dt';
                       this_.piece.src = getImgSrc(this_.color_);
		       this_.promote_piece = promote;
                  }
                  Board[location] = this_;
                  Board[this_.location_] =  null;
                  Undo.push( { type: RES, color: this_.color_, piece: this_, benched: Benched[Benched.length - 1],
                                oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_, promote: promote } )
                  sortBenchedPieces();
           } else
           if (RES == CASTLELONG) {
                      var goodcastle_ = false;
                      for (var p in Board) {
                         const Piece = Board[p];
                         if (Piece == null) continue;
                         if (Piece.role_ != 'R' || this_.role_ != 'K') continue;
                         if (Piece.oldlocation_ == null && this_.oldlocation_ == null) {
                                              // Rook and King have not moved before
                             if (this_.color_ == "klt") {
                                 if (location == "c1") {
                                   if (Piece.location_ == "a1" && Piece.color == "rlt") {
                                     Piece.piece.className = "piece p_" + reverseLoc("d1");
                                     this_.restype_ = RES;
                                     Piece.piece.display = "block";
                                     Piece.oldlocation_ = "a1";
                                     Piece.location_ = "d1";
                                     Board[location] = this_;
                                     Board[this_.location_] =  null;
                                     Board["d1"] = Piece;
                                     Board["a1"] = null;
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              } else
                              if (this_.color_ == "kdt") { // dark
                                 if (location == "c8") {
                                   if (Piece.location_ == "a8" && Piece.color == "rdt") {
                                        Piece.piece.className = "piece p_" + reverseLoc("d8");
                                     this_.restype_ = RES;
                                     Piece.piece.display = "block";
                                     Piece.oldlocation_ = "a8";
                                     Piece.location_ = "d8";
                                     Board[location] = this_;
                                     Board[this_.location_] =  null;
                                     Board["d8"] = Piece;
                                     Board["a8"] = null;
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              }
                          }
                       }
                       if (!goodcastle_) illegal_move("Not able to find proper pieces for long castling!");
           } else
           if (RES == CASTLESHORT) {
                      var goodcastle_ = false;
                      for (var p in Board) {
                         const Piece = Board[p];
                         if (Piece == null) continue;
                         if (Piece.role_ != 'R' || this_.role_ != 'K') continue;
                         if (Piece.oldlocation_ == null && this_.oldlocation_ == null) {
                                              // Rook and King have not moved before
                             if (this_.color_ == "klt") {
                                 if (location == "g1") {
                                   if (Piece.location_ == "h1" && Piece.color == "rlt") {
                                        Piece.piece.className = "piece p_" + reverseLoc("f1");
                                     this_.restype_ = RES;
                                     Piece.piece.display = "block";
                                     Piece.oldlocation_ = "h1";
                                     Piece.location_ = "f1";
                                     Board[location] = this_;
                                     Board[this_.location_] =  null;
                                     Board["f1"] = Piece;
                                     Board["h1"] = null;
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              } else
                              if (this_.color_ == "kdt") { // dark
                                 if (location == "g8") {
                                   if (Piece.location_ == "h8" && Piece.color == "rdt") {
                                     Piece.piece.className = "piece p_" + reverseLoc("f8");
                                     this_.restype_ = RES;
                                     Piece.piece.display = "block";
                                     Piece.oldlocation_ = "h8";
                                     Piece.location_ = "f8";
                                     Board[location] = this_;
                                     Board[this_.location_] =  null;
                                     Board["f8"] = Piece;
                                     Board["h8"] = null;
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              }
                          }
                       }
                       if (!goodcastle_) illegal_move("Not able to find proper pieces for short castling!");
           } else
          if (RES == GOODMOVE) {
log("promotion ...");
log(promote);
                  if (promote != null && promote != "") { 
                       this_.role_ = promote;
                       this_.color_ =  (this_.color_ == 'plt') ? promote.toLowerCase() + 'lt' : promote.toLowerCase() + 'dt';
                       this_.piece.src = getImgSrc(this_.color_);
		       this_.promote_piece = promote;
                  }
                  this_.restype_ = RES;
                  Board[location] = this_;
                  Board[this_.location_] =  null;
                  Undo.push( { type: RES, color: this_.color_, piece: this_, oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_, promote: promote } )
           } else {
                 illegal_move("No result from assertion!");
           }
           this_.piece.className = pieceLocation(game, location); // "piece_" + game.BOARDSIZE_ +  " p" + game.BOARDSIZE_ + "_" + reverseLoc(location);
           this_.piece.display = "block";
           this_.oldlocation_ = this_.location_;
           this_.location_ = location;
log("taking it in for the move ...");
log(this_);
           game.GAME_STATE.lastpiece_ = this_;
           const threat = evaluate_king_threat(game, pclass, RES);
           if (threat) { log( "King is in danger (" + threat + ")!"); }
           return RES;
    }

    function pieceLocation(this_, loc) {
       var bs = this_.BOARDSIZE_
       var rv = this_.GAME_STATE.reverse_
       return "piece_" + bs + " p" + bs + "_" + reverseLoc(rv, loc);
    }

    class Game {
       constructor(id, parent, size, top, left) {
          this.id = id;
          this.setBoardConfig(size);
          this.create(id, parent, size, top, left);
       }

       create(id, parent, size, top, left) {
         const board = document.createElement("div");
         const img = document.createElement("img");
         img.id = "chessboardimg";
         img.src = "/images/chessboarddarkblue.png";
         img.label_ = "darkblue";
         img.style.display = "none"; // Turns off displaying it
         img.style.width = this.BOARDSIZE_ + 'px';
         img.style.height = this.BOARDSIZE_ + 'px';
         img.style.display = "block";
         img.className = "chessboardimg";
         board.className = "chessboard";
         board.appendChild(img); // Puts the image in the image container
         this.parent_ = parent;
         this.board_ = board;
         this.boardimg_ = img;
         this.id_ = id;

         // clone header and footer
         this.header_ = chessheader.cloneNode(true);
         this.footer_ = chessfooter.cloneNode(true);
         this.hdr_player_  = this.header_.getElementsByClassName('playerside')[0]
         this.hdr_elo_     = this.header_.getElementsByClassName('playerelo')[0]
         this.hdr_capture_ = this.header_.getElementsByClassName('playercapture')[0]
         this.hdr_timer_   = this.header_.getElementsByClassName('playertimer')[0]
         this.ftr_player_  = this.footer_.getElementsByClassName('playerside')[0]
         this.ftr_elo_     = this.footer_.getElementsByClassName('playerelo')[0]
         this.ftr_capture_ = this.footer_.getElementsByClassName('playercapture')[0]
         this.ftr_timer_   = this.footer_.getElementsByClassName('playertimer')[0]
         this.ftr_side_    = this.footer_.getElementsByClassName('sidetomove')[0]
         this.addBoard(parent, top, left);


         // set Controls
         this.setControl();

         // move hints
         const source_ = document.createElement('div');
         const destination_ = document.createElement('div');
         board.appendChild(source_);
         board.appendChild(destination_);
         this.src_ = source_;
         this.dst_ = destination_;
         this.disableMoveHints();

         // reset board
         this.Board_ = [];
         this.Bench_ = [];
         this.Undo_  = [];
         this.MoveHint_ = [];
         this.ecoGame_ = [];
         this.setBoard();

          // clone promotion template
          this.promo_ = promoteid.cloneNode(true);
          this.promocoll_  = this.promo_.getElementsByClassName('promocontain')
          this.promoblack_ = this.promocoll_[0]
          this.promowhite_ = this.promocoll_[1]
          var next = this.promoblack_.firstChild;
          while (next) {
            if (next.nodeType == 1) { next.onclick = this.promotePiece; next.game_ = this }
            next = next.nextSibling;
          }
          next = this.promowhite_.firstChild;
          while (next) {
            if (next.nodeType == 1) { next.onclick = this.promotePiece; next.game_ = this }
            next = next.nextSibling;
          }
          this.container_.appendChild(this.promo_);

       }

       GAME_STATE =  { sidetomove_: WHITE, movecount_: 0, analyzegame_: false, 
                       chessgame_: null, lastmove_: null, lastpiece_: null,
                       ptimer_: null,  mousedu_: false, reverse_: false,
                       onpromote_: false, promotepiece: null
                     }

       BTIMER_ = { last_time: 0, watch: '00:00:00', timer: null, int_timer: 0, elapsed: 0 }
       WTIMER_ = { last_time: 0, watch: '00:00:00', timer: null, int_timer: 0, elapsed: 0 }

       BOARDSIZE_   = 640
       BOARDOFFSET_ = 46
       PIECESIZE_   = 73.70
       setBoardConfig(bp) {
         for (p in BOARDCONFIG_) {
             const board_ = BOARDCONFIG_[p];
             if (board_.bp == bp) {
               this.BOARDSIZE_   = board_.bp;
               this.BOARDOFFSET_ = board_.of;
               this.PIECESIZE_   = board_.ps;
             }
          }
       }

       setBoard() {
         this.repositionBoard(wINITFEN_, this);
         this.board_.addEventListener('mouseup', this.captureHumanMove);
       }

       addBoard(parent = this.parent_, top, left) {
         const container = document.createElement('div');
         parent.appendChild(container);
         container.appendChild(this.board_);
         container.appendChild(this.header_);
         container.appendChild(this.footer_);

         this.container_ = container;
         this.header_.style.width = this.BOARDSIZE_ + 'px';
         this.footer_.style.width = this.BOARDSIZE_ + 'px';

         this.header_.style.top = '0px';
         this.board_.style.top =  '25px';
         this.footer_.style.top = this.BOARDSIZE_  + 25 + 'px';

         this.header_.style.left = '0px';
         this.board_.style.left  = '0px';
         this.footer_.style.left = '0px';

         this.board_.style.width = this.BOARDSIZE_ + 'px';
         this.board_.style.height = this.BOARDSIZE_ + 'px';

         container.style.position = 'absolute';
         container.style.width  = ( this.BOARDSIZE_ ) + 'px'
         container.style.height = ( 50 + this.BOARDSIZE_ ) + 'px'
         container.style.top = top + 'px';
         container.style.left = left + 'px';
         container.style.border = '3px solid #dedede';

         container.addEventListener('mouseenter', this.highlightBoard, false);
         container.addEventListener('mouseleave', this.unhighlightBoard, false);

         container.addEventListener('mousedown', this.mouseDownForContainer);
         
         chessdiv.style.border = '3px solid #0000ff';
       }

       mouseDownForContainer(e)  {
         e.preventDefault();
           var this_ = this.game_;
           var offsetLeft = chessdiv.offsetLeft;
           var offsetTop = chessdiv.offsetTop;
           this.startPosX = offsetLeft + this.offsetLeft;
           this.startPosY = offsetTop + this.offsetTop ;
           chessdiv.addEventListener('mousemove', this_.mouseMoveForContainer);
       }

       mouseMoveForContainer(e) {
         e.preventDefault();
         log('aloha');  
       }

       disableMoveHints() {
         this.src_.className = "source";      this.src_.style.visibility = "hidden";
         this.dst_.className = "destination"; this.dst_.style.visibility = "hidden";
         this.src_.loc_ = 'a1';
         this.dst_.loc_ = 'a1';
       }

       highlightBoard() {
         this.style.border = '3px solid #FF0000';
       }

       unhighlightBoard() {
         this.style.border = '3px solid #DEDEDE';
       }
   

       setControl() {
         const condiv = document.createElement('div');
         condiv.style = 'position: absolute; margin: 0px 0px 0px 0px; background-color: #dedede; ' +
                        'border: 2px solid #efefef; top: -32px; left: 0px; width: 240px; height: 25px';
         this.container_.appendChild(condiv);

         const ctrl1 = document.createElement('span');
         const ctrl2 = document.createElement('span');
         const ctrl3 = document.createElement('span');
         const ctrl4 = document.createElement('span');
         const ctrl5 = document.createElement('span');
         const ctrl6 = document.createElement('span');
         const ctrl7 = document.createElement('span');
         const ctrl8 = document.createElement('span');
         ctrl1.style = 'position: absolute; top: 2px; left: 5px';  // above the board
         ctrl2.style = 'position: absolute; top: 2px; left: 30px';  // abover the board
         ctrl3.style = 'position: absolute; top: 2px; left: 60px';  // abover the board
         ctrl4.style = 'position: absolute; top: 2px; left: 90px';  // abover the board
         ctrl5.style = 'position: absolute; top: 2px; left: 120px';  // abover the board
         ctrl6.style = 'position: absolute; top: 2px; left: 150px';  // abover the board
         ctrl7.style = 'position: absolute; top: 2px; left: 180px';  // abover the board
         ctrl8.style = 'position: absolute; top: 2px; left: 210px';  // abover the board
         ctrl1.innerHTML = '&#x2795;';
         ctrl2.innerHTML = '&#x1F519;';
         ctrl3.innerHTML = '&#x1F44E;';
         ctrl4.innerHTML = '&#x21BB;';
         ctrl5.innerHTML = '&#x1F3A8;';
         ctrl6.innerHTML = '&#x1F916;';
         ctrl7.innerHTML = '&#x1F5C2;';
         ctrl8.innerHTML = '&#x1F4AC;';
         condiv.appendChild(ctrl1); ctrl1.game_ = this;
         condiv.appendChild(ctrl2); ctrl2.game_ = this;
         condiv.appendChild(ctrl3); ctrl3.game_ = this;
         condiv.appendChild(ctrl4); ctrl4.game_ = this;
         condiv.appendChild(ctrl5); ctrl5.game_ = this;
         condiv.appendChild(ctrl6); ctrl6.game_ = this;
         condiv.appendChild(ctrl7); ctrl7.game_ = this;
         condiv.appendChild(ctrl8); ctrl8.game_ = this;
         ctrl1.onclick = this.newGame;
         ctrl2.onclick = this.takeBack;
         ctrl3.onclick = this.Resign;
         ctrl4.onclick = this.reverseBoard;
         ctrl5.onclick = this.chooseColor;
         ctrl6.onclick = this.engineGame;
         ctrl7.onclick = this.loadPosition;
         ctrl8.onclick = this.sendMEssage;
       }

       analyzePosition() {
log("Let's analyze");
log(this.value_);
          var this_ = this.game_;
          var fen = this.value_;
          var who_ = fen.split(' ')[1]
/*
          initGame(false, true);
*/
          try {
             const reverseB = checkPositionLegality(fen);
             if (reverseB) {
               this_.repositionBoard(wINITFEN_, this_);
/*
               this_.reverseBoard();
*/
             } else {
               this_.repositionBoard(fen, this_);
             }
/*
             CHESSGAME_.innerHTML = "";  Games = [];
             while (ecoGame_.length > 0)  ecoGame_.pop();
             SIDETOMOVE_ = (who_ == 'b') ? BLACK : WHITE;
             sidetoid.innerHTML = (SIDETOMOVE_ == WHITE) ? '&#9675;' : '&#9679;';
             GAMEFEN_ = fen;
             // add FEN entry.
             addFEN(fen);
             playEngine();
*/
           } catch(e) { log(e) }
       }

       loadPosition() {
         log("hello there ...");
         var this_ = this.game_;
         var top = 0; // ((this.style.top).replace(/px/,'') + 25) ;
         var left = parseInt(this.style.left.replace(/px/,'')) - 70;
         chooseAnalyze( this_, { y: top, x: left } );
       }

       chooseColor() {
         log("hello there ...");
         var this_ = this.game_;
         var top = 0; // ((this.style.top).replace(/px/,'') + 25) ;
         var left = parseInt(this.style.left.replace(/px/,'')) - 10;
         chooseBoardColor( this_, { y: top, x: left } ); // references external function
       }

       changeBoardColor() { // this is internal function. Don't confuse with the external one
        var this_ = this.game_;
        this_.boardimg_.label_ = this.value_;
        this_.changeBoard();
       }

       int_PCOUNT_ = 0
       checkTimer(this_) {
           var BTIMER_ = this_.BTIMER_,  WTIMER_ = this_.WTIMER_;
           var SIDETOMOVE_ = this_.GAME_STATE.sidetomove_;
           var PTIMER_ = this_.GAME_STATE.ptimer_;
           var last_time_ = Date.now();
           var elapsed = 0, seconds = 0, minutes = 0, hours = 0;
           if (this_.int_PCOUNT_ > 60000) { this_.int_PCOUNT_ = 0; clearInterval(PTIMER_); this_.GAME_STATE.ptimer_ = null }
           this_.int_PCOUNT_++;
           if (SIDETOMOVE_ == WHITE) {
              WTIMER_.elapsed += (last_time_ - WTIMER_.last_time);
              elapsed = (PLAYTIME_ - WTIMER_.elapsed)
              if (elapsed < 0) {
                  this_.int_PCOUNT = 0; clearInterval(PTIMER_); this_.GAME_STATE.ptimer_ = null;
                  this_.WTIMER_ = WTIMER_;
                  doneGame(false, true, false, "Time is up! WHITE lost!");
                  return;
              }
              WTIMER_.watch = padTime(elapsed)
              this_.hdr_timer_.innerHTML = WTIMER_.watch;
              WTIMER_.last_time = last_time_;
          } else {
              BTIMER_.elapsed += (last_time_ - BTIMER_.last_time);
              elapsed = (PLAYTIME_ - BTIMER_.elapsed)
              if (elapsed < 0) {
                 this_.int_PCOUNT = 0; clearInterval(PTIMER_); this_.GAME_STATE.ptimer_ = null;
                 this_.BTIMER_ = BTIMER_; 
                 doneGame(false, true, false, "Time is up! BLACK lost!");
                 return;
              }
              BTIMER_.watch = padTime(elapsed)
              this_.ftr_timer_.innerHTML = BTIMER_.watch;
              BTIMER_.last_time = last_time_;
          }
          this_.BTIMER_ = BTIMER_; this_.WTIMER_ = WTIMER_;
       }

       setTimer(timeron = true) {
          var last_time_ = Date.now();
          if (this.GAME_STATE.sidetomove_ == WHITE) {
             this.WTIMER_.last_time = last_time_;
          } else {
             this.BTIMER_.last_time = last_time_;
          }
          this.int_PCOUNT = 0;
          if (timeron) if (this.GAME_STATE.ptimer_ == null) this.GAME_STATE.ptimer_ = setInterval(this.checkTimer, 50, this);
       }

       setMoveHint(piece) {
          this.src_.loc_ = piece.oldlocation_;
          this.dst_.loc_ = piece.location_;
          this.src_.className = "source " + pieceLocation(this, this.src_.loc_) // piece_" + this.BOARDSIZE_ + " p" + this.BOARDSIZE_ + "_" + reverseLoc(this.src_.loc_);
          this.dst_.className = "destination " + pieceLocation(this, this.dst_.loc_); // piece_" + this.BOARDSIZE_ + " p" + this.BOARDSIZE_ + "_" + reverseLoc(this.dst_.loc_);
          this.MoveHint_.push({ src: this.src_.loc_, dest: this.dst_.loc_ });
          this.src_.style.visibility = 'visible';
          this.dst_.style.visibility = 'visible';
       }

       unsetMoveHint() {
          var piece = this.MoveHint_.pop();
          if (this.MoveHint_.length > 0) {
             piece = this.MoveHint_[this.MoveHint_.length - 1];
             this.src_.loc_ = piece.src;
             this.dst_.loc_ = piece.dest;
             this.src_.className = "source " + pieceLocation(this, this.src_.loc_); // piece_" + this.BOARDSIZE_ + " p" + this.BOARDSIZE_ + "_" + reverseLoc(this.src_.loc_);
             this.dst_.className = "destination " + pieceLocation(this, this.dst_.loc_); //  piece_" + this.BOARDSIZE_ + " p" + this.BOARDSIZE_ + "_" + reverseLoc(this.dst_.loc_);
             this.src_.style.visibility = 'visible';
             this.dst_.style.visibility = 'visible';
          } else {
             this.src_.style.visibility = 'hidden';
             this.dst_.style.visibility = 'hidden';
          }
       }

       TurnToPlay(piece) {
        var game = this.GAME_STATE;
        var SIDETOMOVE_ = game.sidetomove_;
        var MOVECOUNT_ = game.movecount_;
        game.sidetomove_ = ( game.sidetomove_ == WHITE) ? BLACK: WHITE;
        game.movecount_ = game.movecount_ + ((game.sidetomove_ == WHITE ) ? 1 : 0);
        this.ftr_side_.innerHTML = (game.sidetomove_ == WHITE) ? '&#9675;' : '&#9679;';
        this.setTimer(true);
        if (piece != null) {
           game.lastpiece_ = piece;
           this.setMoveHint(piece);
           if (piece.restype_ == CASTLELONG || piece.restype_ ==  CASTLESHORT) { chess_castle.currentTime = 0; chess_castle.play(); }
           else
           if (piece.restype_ == EATPIECE) { chess_castle.currentTime = 0; chess_castle.play(); } else
                                           { chess_move.currentTime = 0; chess_move.play(); }
        } else chess_move.play();
        this.GAME_STATE = game;
       }

       moveIt(count_, move, chk = '') {
         var game = this.game;
         var ANALYZEGAME_ = game.GAME_STATE.analyzegame_;
         var ecoGame_ = game.ecoGame_;
         var SIDETOMOVE_ = game.GAME_STATE.sidetomove_;
         var ANALYZEGAME_ = game.GAME_STATE.analyzegame_;
         var CHESSGAME_ = game.GAME_STATE.chessgame_;
         const wmove = move.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, '');
         if (ANALYZEGAME_ && ecoGame_.length == 0) { // handle premove for white ...
          if (count_ == 1 && SIDETOMOVE_ == BLACK) {
             const movespan0 = document.createElement("span");
             const movespan1 = document.createElement("span");
             const movespan2 = document.createElement("span");
             const movespace1 = document.createTextNode(" ");
             const movechk1 = document.createElement("span"); movechk1.innerHTML = chk; movechk1.className = 'chesscmt';
             const movecmt1 = document.createElement("span"); movecmt1.innerHTML = ""; movecmt1.className = 'chesscmt';
             movechk1.id = "chk_" + count_ + "_premove";
             movespan0.innerHTML = count_ + ".";
             movespan1.innerHTML = "(...)"; movespan1.id = "moveid" + count_ + "w";
             movespan0.className = "chesspiecestep";
             movespan1.className = "chesspiecenomove";
             CHESSGAME_.appendChild(movespan0);
             CHESSGAME_.appendChild(movespan1);
             CHESSGAME_.appendChild(movechk1);
             CHESSGAME_.appendChild(movecmt1);
             CHESSGAME_.appendChild(movespace1);
             ecoGame_.push( movespan0.innerHTML + "(...)" + chk);
          }

         }
         const movespan0 = document.createElement("span");
         const movespan1 = document.createElement("span");
         const movespan2 = document.createElement("span");
         const movespace1 = document.createTextNode(" ");
         const movechk1 = document.createElement("span"); movechk1.innerHTML = chk; movechk1.className = 'chesscmt';
         const movecmt1 = document.createElement("span"); movecmt1.innerHTML = ""; movecmt1.className = 'chesscmt';
         movechk1.id = "chk_" + count_ + "_" + move;
         game.GAME_STATE.lastmove_ = movechk1.id;
         if (SIDETOMOVE_ == WHITE) { movespan0.innerHTML = count_ + "."; }
         movespan1.innerHTML = wmove; movespan1.id = "moveid" + count_ + ((SIDETOMOVE_ == WHITE) ? "w" : "b");
         movespan0.className = "chesspiecestep";
         movespan1.className = "chesspiecenomove";

         CHESSGAME_.appendChild(movespan0);
         CHESSGAME_.appendChild(movespan1);
         CHESSGAME_.appendChild(movechk1);
         CHESSGAME_.appendChild(movecmt1);
         CHESSGAME_.appendChild(movespace1);
         ecoGame_.push( movespan0.innerHTML + move.replace(/P/g, '') + chk);
         game.ecoGame_ = ecoGame_;
       }

       promotePiece() {
         var this_ = null;
         if (typeof(this.nodeType) == "undefined") {
             this_  = this;
             this_.GAME_STATE.promotepiece_ = null;
         } else {
             this_  = this.game_;
             this_.GAME_STATE.promotepiece_ = this.id;
         }
         this_.GAME_STATE.onpromote_ = false; 
         this_.promowhite_.style.visibility = 'hidden';
         this_.promoblack_.style.visibility = 'hidden';
         this_.promo_.style.visibility = "hidden";
       }

       int_promote = 0
       readyPromote(this_, piece, loc_) {
        var ONPROMOTE_ = this_.GAME_STATE.onpromote_;
        var PROMOTEPIECE_ = this_.GAME_STATE.promotepiece_;
        if (this_.int_promote > 200) {
           this_.int_promote = 0;
           clearInterval(this_.promotetime);
           this_.takeMove(piece, loc_, 'Q'); // taking forever to decide, let's promote to Queen
           this_.promotePiece();
        }
log("promoted ...");
        if (!ONPROMOTE_ && PROMOTEPIECE_ != null) {
log("promoted 1 ...");
log(PROMOTEPIECE_);
           clearInterval(this_.promotetime);
           this_.takeMove(piece, loc_, PROMOTEPIECE_);
           this_.promotePiece();
        }
        this_.int_promote ++;
       }

       promotetime = ''
       promoteChoice(piece, loc_, color) {
log(this.promo_);

          this.GAME_STATE.onpromote_ = true;
          this.promo_.style.visibility = "visible";
          if (color == 'lt') {
             this.promowhite_.style.visibility = 'visible';
             this.promoblack_.style.visibility = 'hidden';
          } else {
             this.promowhite_.style.visibility = 'hidden';
             this.promoblack_.style.visibility = 'visible';
          }
          this.int_promote = 0;
          this.promotetime = setInterval(this.readyPromote, 50, this, piece, loc_);
       }

       takeMove(piece, loc_, promote) {
          var MOVECOUNT_ = this.GAME_STATE.movecount_;
          var move_ = '';
          piece.move = { location: loc_, promote: promote };
          const src_ = identifySource(this.Board_, piece);
          if (promote != null) {
              move_ = loc_ + "=" + promote;
log("the promoting move ...");
log(move_);
          } else
          if (piece.restype_ == CASTLELONG) move_ = "O-O-O"; else
          if (piece.restype_ == CASTLESHORT) move_ = "O-O"; else
          if (piece.restype_ == EATPIECE) {
                if (piece.role_ == 'P')
                   move_ = piece.oldlocation_[0] + "x" + loc_;
                 else
                move_ = piece.role_ + src_ + "x" + loc_;
          } else move_ = piece.role_.replace(/P/g,'') + src_ + loc_;
          // this.moveIt(MOVECOUNT_ + 1, move_, (_CHECK_MATE_) ? '#' : (_CHECK_KING_ ? '+' : ''));
          this.TurnToPlay(piece);
          // isRepeatDraw();
          // if (isEngineGame()) { playEngine(); }  else { checkState(piece, move_); }
       }

       captureHumanMove() {
              var this_ = this.game;
              var piece = this.targetmove_, loc_ = null;
              var SIDETOMOVE_ = this_.GAME_STATE.sidetomove_;
              this_.GAME_STATE.mousedu_ = false;
              
              var loffset = piece.offsetLeft, toffset = piece.offsetTop;
              var center =   Math.ceil(this_.PIECESIZE_ / 2);
              var x = loffset + center; var y = toffset + center;
              var cls_ = null, loc_ = null, woffs = this_.PIECESIZE_;
              var BRK = false;
              for (var h in horiz) {
                 for (var v=1; v<=8; v++) {
                     loc_ = horiz[h] + v;
                     cls_ = pieceLoc[reverseLoc(this_.GAME_STATE.reverse_, loc_) + '_' + this_.BOARDSIZE_];
                     if (cls_.left < x && cls_.left + woffs > x && cls_.top < y && cls_.top + woffs > y) {
                        try {
                            var promote = null, move_ = null, pclass = piece.pclass;
                            if (SIDETOMOVE_ == WHITE && pclass.color_.match(/dt$/)) { BRK = true; break; }
                            if (SIDETOMOVE_ == BLACK && pclass.color_.match(/lt$/)) { BRK = true; break; }
                            if (pclass.role == 'P') {
                               if (pclass.color == 'plt' && v == 8) promote = 'lt';
                               if (pclass.color == 'pdt' && v == 1) promote = 'dt';
                            }
                            if (promote == null) {
                               this_.takeMove(pclass, loc_, promote);
                            } else {
                               this_.promoteChoice(pclass, loc_, promote);
                            }
                            if (MOVECOUNT_ >= 0) DONEGAME_ = false;
                            BRK = true; break;
                        } catch(e) {
                            if (typeof(e.lastIndexOf) != "undefined") {
                              var s = e.lastIndexOf('endangering its own king'),
                                  p = e.lastIndexOf('Not able to find proper pieces');
                              if (s >= 0 || p >=0) { undoMove(this_, false, false); }  else log(e);
                            } else {
                               log(e);
                            }
                        }
                     }
                 }
                 if (BRK) break;
               }
               piece.style.top = ''; piece.style.left = '';
               piece.style.zIndex = 0;
               this.removeEventListener('mousemove', this_.mouseMove);
       }

       captureEngineMove() {
       }

       mouseDown(e)  {
         e.preventDefault();
           // if (MACHINECHOICE_) return;
           // if (RESIGN_ || FETCHEDGAME_ || PROMOTE_ || (!NEWGAME_ && !ANALYZEGAME_)) return;
           var this_ = this.game_;
           var board_ = this_.board_;
           var container_ = this_.container_;
           var center = Math.ceil(this_.PIECESIZE_ / 2)
           var offsetLeft = chessdiv.offsetLeft + container_.offsetLeft + board_.offsetLeft + center;
           var offsetTop = chessdiv.offsetTop + container_.offsetTop + board_.offsetTop + center;
           this.startPosX = offsetLeft + this.offsetLeft;
           this.startPosY = offsetTop + this.offsetTop ;
           board_.targetmove_ = this;
           this_.GAME_STATE.mousedu_ = true;
           board_.addEventListener('mousemove', this_.mouseMove);
           board_.game = this_;
       }

       zindex_ = 0;
       mouseMove(e) {
           var piece = this.targetmove_;
           var pos = eventOffset(e), x = pos.x, y = pos.y;
           piece.newPosX   = piece.startPosX - x;
           piece.newPosY   = piece.startPosY - y;
           piece.startPosX = x;
           piece.startPosY = y;
           piece.style.top  = (piece.offsetTop - piece.newPosY) + "px";
           piece.style.left = (piece.offsetLeft - piece.newPosX) + "px";
           piece.style.zIndex = 5;
       }

       // Piece class ************************************************
       Piece = class Piece {
           constructor(game, role, tag, location) {
              this.image(game, role, tag, location);
           }

           image(game, role, tag, location, ol = 0, img = 0) {
               this.role_ = role;
               this.color_ = tag;
               this.location_ = location;
               if (ol == 0) this.oldlocation_ = null;
               this.active_ = 1;
               if (img == 0) this.piece = document.createElement("img");
               this.piece.id   = role + location;
               this.piece.src = getImgSrc(tag);
               this.piece.className = pieceLocation(game, location);
               this.piece.style.display = "block";
               this.piece.style.cursor = "pointer";
               this.piece.addEventListener('mousedown', game.mouseDown);
               this.piece.pclass = this;
               this.piece.game_ = game;
           }

           get role() { return this.role_; }
           get location() { return this.location_; }
           get oldlocation() { return this.oldlocation_; }
           get getpiece() { return this.piece; }
           get color() { return this.color_; }

           set active(s) {
               if (s == 0) {
                  this.piece.style.visibility = "hidden";
                  this.active_ = s;
               }
           }

           set move(what) {
             return move(this.piece.game_, this, what);
           }
       }

       repositionBoard(fen, this_) {  // using  UCI-fen
            if (fen == null) return;
            var Board_ = this_.Board_;
            var Bench_ = this_.Bench_;
            var board_ = this_.board_;
            const ranks = fen.split(' ')[0].split('/');
            this.initializeBoard(this);
 
            for (var r in ranks) {
                const pieces = ranks[r];
                const rank = 8 - parseInt(r);
                var v = 0;
                for (var p in pieces) {
                  var role = null, color = null, location = null;
                  const piece = pieces[p];
                  if (piece.match(/[RNBQKP]/)) { // lt
                     role = piece.toUpperCase();
                     color = piece.toLowerCase() + 'lt';
                     location = horiz[v] + rank;
                     v++;
                  } else
                  if (piece.match(/[rnbqkp]/)) { // dt
                     role = piece.toUpperCase();
                     color = piece.toLowerCase() + 'dt';
                     location = horiz[v] + rank;
                     v++;
                  } else {
                     const spaces = parseInt(piece);
                    v +=  (spaces );
                  }
                  if (role != null) {
                     const Piece_ = new this.Piece(this, role, color, location);
                     board_.appendChild(Piece_.getpiece);
                     Board_[location] = Piece_;
                  }
              }
           }
       }

       initializeBoard(this_) {
         var Board_ = this_.Board_;
         var Bench_ = this_.Bench_;
         var Undo_ = this_.Undo_;
         var MoveHint_ = this.MoveHint_;
         var ecoGame_ = this.ecoGame_;
         // Initialize Board
         for (let v=1; v <= 8; v++) {
             for (let h=0; h < 8; h++) {
                const board = Board_[horiz[h] + v];
                if (board != null) {
                    const elem = board.piece;
                    try {
                      elem.parentNode.removeChild(elem);
                    } catch(e) {}
                }
                Board_[horiz[h] + v] = null;
             }
         }

         for (var p in Bench_) {
              const board = Bench_[p];
              if (board != null) {
                  const elem = board.piece;
                  try {
                     elem.parentNode.removeChild(elem);
                  } catch(e) {}
              }
         }

         for (var p in Undo_) { Undo_.pop(); }
         for (var p in MoveHint_) { MoveHint_.pop(); }
         for (var p in ecoGame_) { ecoGame_.pop(); }
       }

       changeBoard() {
          var selected = this.boardimg_.label_, img_ = null;
          if (!this.GAME_STATE.reverse_) {
              img_ = '/images/chessboard' + selected + '.png';
          } else {
              img_ = '/images/chessboard' + selected + 'b.png';
          }
          this.boardimg_.src = img_;
       }

       reverseBoard() {
         var this_ = this.game_;
         var Board = this_.Board_;
         var Benched = this_.Bench_;
         this_.board_.style.visibility = "hidden";
         this_.GAME_STATE.reverse_ = !this_.GAME_STATE.reverse_;
         this_.changeBoard();
         for (var p in Board) {
            var board = Board[p];
            if (board != null) {
               board.piece.className = pieceLocation(this_, board.location); // "piece " + "p_" + reverseLoc(board.location);
            }
         }
         for (var p in Benched) {
            var board = Benched[p], loc_ = null;
            if (board != null) {
               board.piece.className = pieceLocation(this_, board.location); // "piece " + "p_" + reverseLoc(board.location);
            }
         }
         this_.src_.className = "source " + pieceLocation(this_, this_.src_.loc_); // piece p_" + reverseLoc(source_.loc_);
         this_.dst_.className = "destination " + pieceLocation(this_, this_.dst_.loc_); // piece p_" + reverseLoc(destination_.loc_);
         const game = initHeader(false, false, false);
         // infoHeader(game);
         // setRate();
        this_.board_.style.visibility = "visible";
       /*
        if (NEWGAME_ || ANALYZEGAME_) {
            if (RESIGN_ || FETCHEDGAME_ || PROMOTE_) return;
            playEngine();
        }
        */
      }

    } // end Game class

    const myNewGame1 = new Game('game1', chessdiv, 560, 100, 100);
    const myNewGame2 = new Game('game2', chessdiv, 480, 400, 700);

    // Get King pieces
    var Board = {}, Benched = [], Undo = [];

    async function takeBack() {
      if (MACHINECHOICE_) return;
      if (RESIGN_ || FETCHEDGAME_ || PROMOTE_ || (!NEWGAME_ && !ANALYZEGAME_)) return;
       takeitBack();
       if (WPLAYER_ != MACHINE && BPLAYER_ != MACHINE) return;
       if (WPLAYER_ == MACHINE || BPLAYER_ == MACHINE) {
           await pause(200);
           takeitBack();
       }
    }

    function takeitBack() { 
      var mtype = undoMove(); 
      MOVECOUNT_ = MOVECOUNT_ - ((SIDETOMOVE_ == WHITE ) ? 0 : 1);
      for (var s = 1; s <=5; s++) {
         if (CHESSGAME_.lastChild) {
            CHESSGAME_.removeChild(CHESSGAME_.lastChild);
         }
      } 
      if (mtype == 0) { /* do nothing */ } else
      if (mtype == GOODMOVE) {
         chess_move.currentTime = 0;
         chess_move.play();
      } else {
         chess_castle.currentTime = 0;
         chess_castle.play();
      }
    }

    function undoMove(game, takeback_ = true, switchside = true) {
       var Board = game.Board_;
       var Undo = game.Undo_;
       var Source = game.Source_;
       var ecoGame_ = game.ecoGame_;
       var SIDETOMOVE_ = game.GAME_STATE.sidetomove_;
       var BOARDSIZE_ = game.BOARDSIZE_;
       if (Undo.length ==0 ) return 0;
       var move = Undo[Undo.length - 1], undone = false; 
       if (move.type == GOODMOVE) {
            piece = move.piece;
            Board[move.oloc] =  piece;
            Board[move.nloc] =  null;
            piece.piece.className = pieceLocation(game, move.oloc); // "piece_" + BOARDSIZE_ + " p" + BOARDSIZE_ + "_" + reverseLoc(move.oloc); 
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            if (move.promote) { const color = piece.color_.match(/lt$/);
                                piece.role_ = 'P'; 
                                piece.color_ = (color) ? 'plt' : 'pdt' ;
                                piece.piece.src = getImgSrc(piece.color_);
                              }
            game.unsetMoveHint();
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == EATPIECE) {
            piece = move.piece;
            bpiece = Benched.pop();
            bpiece.active_ = 1;
            bpiece.piece.style.visibility = ""
            bpiece.piece.display = "block"
            Board[move.oloc] =  piece;
            Board[bpiece.location_] =  bpiece;
            piece.piece.className = pieceLocation(game, move.oloc); // "piece_" + BOARDSIZE_ + " p" + BOARDSIZE_ + "_" + reverseLoc(move.oloc); 
            bpiece.piece.className =  pieceLocation(game, bpiece.location); // "piece_" + BOARDSIZE_ + " p" + BOARDSIZE_ + "_" + reverseLoc(bpiece.location); 
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            if (move.promote) { const color = piece.color_.match(/lt$/);
                                piece.role_ = 'P'; 
                                piece.color_ = (color) ? 'plt' : 'pdt' ;
                                piece.piece.src = getImgSrc(piece.color_);
                              }
            game.unsetMoveHint();
            sortBenchedPieces();
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == ENPASSANT) {
            piece = move.piece;
            bpiece = Benched.pop();
            bpiece.active_ = 1;
            bpiece.piece.style.visibility = ""
            bpiece.piece.display = "block"
            Board[move.oloc] =  piece;
            Board[move.nloc] = null;
            Board[bpiece.location_] =  bpiece;
            piece.piece.className = pieceLocation(game, move.oloc); // "piece_" + BOARDSIZE_ + " p" + BOARDSIZE_ + "_" + reverseLoc(move.oloc); 
            bpiece.piece.className = pieceLocation(game, bpiece.location); // "piece_" + BOARDSIZE_ + " p" + BOARDSIZE_ + "_" + reverseLoc(bpiece.location); 
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            game.unsetMoveHint();
            sortBenchedPieces();
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == CASTLESHORT) {
            piece = move.piece;
            // king
            Board[move.oloc] =  piece;
            Board[move.nloc] =  null;
            piece.piece.className =  pieceLocation(game, move.oloc); // "piece_" + BOARDSIZE_ + " p" + BOARDSIZE_ + "_" + reverseLoc(move.oloc); 
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            // rook
            var oloc_ = null, nloc_ = null;
            if (piece.color_.match(/lt$/)) {
                var oloc_ = "h1", nloc_ = "f1";
            } else {
                var oloc_ = "h8", nloc_ = "f8";
            }
            piece = Board[nloc_];
            Board[oloc_] =  piece;
            Board[nloc_] = null;
            Board[oloc_].piece.className = pieceLocation(game, oloc_); // "piece_" + BOARDSIZE_ + " p" + BOARDSIZE_ + "_" +  reverseLoc(oloc_); 
            Board[oloc_].location_ = oloc_;
            Board[oloc_].oldlocation_ = null;
            game.unsetMoveHint();
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == CASTLELONG) {
           piece = move.piece;
            // king
            Board[move.oloc] =  piece;
            Board[move.nloc] =  null;
            piece.piece.className = pieceLocation(game, move.oloc); // "piece_" + BOARDSIZE_ + " p" + BOARDSIZE_ + "_" + reverseLoc(move.oloc); 
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            // rook
            var oloc_ = null, nloc_ = null;
            if (piece.color_.match(/lt$/)) {
                var oloc_ = "a1", nloc_ = "d1";
            } else {
                var oloc_ = "a8", nloc_ = "d8";
            }
            piece = Board[nloc_];
            Board[oloc_] =  piece;
            Board[nloc_] = null;
            Board[oloc_].piece.className = pieceLocation(game, oloc_); // "piece_" + BOARDSIZE_ + " p" + BOARDSIZE_ + "_" +  reverseLoc(oloc_);
            Board[oloc_].location_ = oloc_;
            Board[oloc_].oldlocation_ = null;
            game.unsetMoveHint();
            if (!takeback_) return move.type;
            undone = true; 
       }
       if (undone) {
            if (switchside) game.GAME_STATE.sidetomove_ = (SIDETOMOVE_ == WHITE) ? BLACK: WHITE; 
            ecoGame_.pop(); 
            Undo.pop();
       }
       return move.type;
    }


    /** Remove  = Improve using Class Game - make this generic **/
    function initializeBoard() {
      // Initialize Board
      for (let v=1; v <= 8; v++) {
        for (let h=0; h < 8; h++) {
           const board = Board[horiz[h] + v];
           if (board != null) {
              const elem = board.piece;
              try {
               elem.parentNode.removeChild(elem);
              } catch(e) {}
           }
           Board[horiz[h] + v] = null;
        }
      }

      for (var p in Benched) {
          const board = Benched[p];
          if (board != null) {
             const elem = board.piece;
             try {
               elem.parentNode.removeChild(elem);
             } catch(e) {}
          }
      }
    }

    /** Remove =  Improve using Class Game - make this generic **/
    function repositionBoard(fen) {  // using  UCI-fen
       if (fen != null) {
          var ranks = fen.split(' ')[0].split('/');
          initializeBoard();

          for (r in ranks) {
             const pieces = ranks[r]
             const rank = 8 - parseInt(r);
             var v = 0;
             for (p in pieces) {
               var role = null, color = null, location = null;
               const piece = pieces[p];
               if (piece.match(/[RNBQKP]/)) { // lt
                  role = piece.toUpperCase();
                  color = piece.toLowerCase() + 'lt';
                  location = horiz[v] + rank;
                  v++;
               } else
               if (piece.match(/[rnbqkp]/)) { // dt
                  role = piece.toUpperCase();
                  color = piece.toLowerCase() + 'dt';
                  location = horiz[v] + rank;
                  v++;
               } else {
                 const spaces = parseInt(piece);
                 v +=  (spaces );
               }
               if (role != null) { 
                const Piece_ = new Piece(role, color, location);
                chessboard.appendChild(Piece_.getpiece);
                Board[location] = Piece_;
               }
             }
          } 
       }
    }

    function reloadBoard(fen = null) { // using UCI-fen
      initializeBoard();
      if (fen != null) { repositionBoard(fen); } else { repositionBoard(wINITFEN_); }
    }


    function find_bishop(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       for (var i = 1; i <= diff_nh; i++) {
          const h = (oh < nh) ? String.fromCharCode(oh + i) : String.fromCharCode(oh - i);
          const v = (ov < nv) ? (ov + i) : (ov - i);
          const apiece = Board[h + v];
          if ( i == diff_nh ) {  // same destination
              if (apiece != null && apiece.color_.slice(-2) == color) {
                    blocked = 1; _loc = null;
              } else { // eat or move
                    if (h + v == location)  { // found the target
                        if (src != null) { // now select piece, assuming multiple sources
                          if (loc == src || _oh == src || ov == src) { _loc = loc }
                        } else { _loc = loc } // otherwise, choose the only one source
                    }
             }
          } else { if (apiece != null)   { blocked = 1; _loc = null; } }
       }
       if (!blocked) {return _loc; }
       return null;
    }

    function find_rook(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       if (diff_nv == 0 && diff_nh > 0) {
            for (var i = 1; i <= diff_nh; i++) {
                const h = (oh < nh) ? String.fromCharCode(oh + i) : String.fromCharCode(oh - i);
                const apiece = Board[h + nv];
                  if ( i == diff_nh ) {  // same destination
                      if (apiece != null && apiece.color_.slice(-2) == color) {
                          blocked = 1; _loc = loc;
                      } else { // eat or move
                        if (h + nv == location)  { 
                           if (src != null) { // now select piece, assuming multiple sources
                              if (loc == src || _oh == src || ov == src) { _loc = loc }
                           } else { _loc = loc } // otherwise, choose the only one source
                        }
                      }
                  } else {
                      if (apiece != null) { blocked = 1; _loc = null; } 
                  }
            }
            if (!blocked) {return _loc; }
       } else
       if (diff_nh == 0 && diff_nv > 0) {
            const h = String.fromCharCode(nh);
            for (var i = 1; i <= diff_nv; i++) {
                const v = (ov < nv) ? (ov + i) : (ov - i);
                const apiece = Board[_oh + v];
                if ( i == diff_nv ) {  // same destination
                      if (apiece != null && apiece.color_.slice(-2) == color) {
                          blocked = 1; _loc = null;
                      } else { // eat or move
                        if (h + v == location)  { 
                           if (src != null) { // now select piece, assuming multiple sources
                              if (loc == src || _oh == src || ov == src) { _loc = loc }
                           } else { _loc = loc } // otherwise, choose the only one source
                        }
                      }
                } else { if (apiece != null) { blocked = 1; _loc = null; } }
            }
            if (!blocked) {return _loc; }
       }
       return null;
    }

    function find_knight(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       if ((diff_nh == 1 && diff_nv == 2) || 
           (diff_nh == 2 && diff_nv == 1)) {
         if (bpiece.color_.slice(-2) != color) {
            blocked = 1;
         } else {
            if (src != null) { // now select piece, assuming multiple sources
              if (loc == src || _oh == src || ov == src) { _loc = loc }
            } else { _loc = loc } // otherwise, choose the only one source
         } 
       }
       if (!blocked) { return _loc; }
       return null;
    }

    function find_location(color, role, location, hint = null, src = null) {
      const locs = [];
      for (var p in Board) {
        const bpiece = Board[p];
        if (bpiece != null) {
            const loc = bpiece.location;
            const oh    = loc[0].charCodeAt(0), ov = parseInt(loc[1]);
            const nh    = location[0].charCodeAt(0), nv = parseInt(location[1]);
            diff_nh = Math.abs(nh - oh); diff_nv = Math.abs(nv - ov);
            if ((color == 'lt' && bpiece.color.match(/lt$/)) || (color == 'dt' && bpiece.color.match(/dt$/)))  {
               if (bpiece.role == "K" && role == "K") {
                  locs.push(loc);
                } else 
                if (bpiece.role == "N" && role == "N") {
                  const floc = find_knight(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "B" && role == "B") {
                  const floc = find_bishop(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "R" && role == "R") {
                  const floc = find_rook(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "Q" && role == "Q") {
                  const floc1 = find_bishop(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc1 != null) locs.push(floc1);
                  const floc2 = find_rook(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc2 != null) locs.push(floc2);
                } else 
                if (bpiece.role == "P" && role.match(/[a-h]/) != null) {
                  if (diff_nh == 0 && (diff_nv == 1 || diff_nv == 2)) {
                     const bpiece1 = Board[String.fromCharCode(oh) + ((color == 'lt') ? (ov + 1) : (ov - 1))];
                     if (bpiece1 != null) { continue }; // there is a block.
                     if (hint == null) { // moving
                       if (color == 'dt' && ov > nv) { locs.push(loc); }
                       if (color == 'lt' && ov < nv) { locs.push(loc); }
                    }
                  } else
                  if (diff_nh == 1 && diff_nv == 1) {
                     if (hint != null && hint == "x") { // eating
                        const loc1 = loc[0];
                        if (loc[0] == role) {
                           if (color == 'dt' && ov > nv) { locs.push(loc); }
                           if (color == 'lt' && ov < nv) { locs.push(loc); }
                        }
                     }
                  } 
                }
            }
        }
      }
      return locs;
    }

    // Audio
    function playawalker() {
       // const audio = new Audio("/audio/AlanWalker.mp3");
       const audio = new Audio("/audio/shortawalker.mp3");
       audio.volume = 0.5;
       return audio;
    }

    function chessreset() {
       const audio = new Audio("/audio/chessreset.mp3");
       audio.volume = 1.0;
       return audio;
    }
    function chesscastle() {
       const audio = new Audio("/audio/chesscastle.mp3");
       audio.volume = 1.0;
       return audio;
    }
    function chessmove() {
       const audio = new Audio("/audio/chessmove.mp3");
       audio.volume = 1.0;
       return audio;
    }
    function chesscapture() {
       const audio = new Audio("/audio/chesscapture.mp3");
       audio.volume = 1.0;
       return audio;
    }

    var PLAY_AW_ = false;
    function playAW() {
        PLAY_AW_ = (PLAY_AW_) ? false: true;
        const music_ = document.getElementById("musicid");
        if (PLAY_AW_) { 
            music_.innerHTML = "&#9834;";
            chess_awalker.playbackRate = 1.0;
         } else  { 
            music_.innerHTML = "&#9632;";
            chess_awalker.pause(); chess_awalker.currentTime = 0 
         };
    } 

    // audio objects
    const chess_awalker = playawalker();
    const chess_move = chessmove();
    const chess_capture = chesscapture();
    const chess_castle = chesscastle();
    const chess_reset = chessreset();

    var parser = null;
    async function loadParser() {
        const res = await fetch('/jscripts/pgngrammar.pegjs');
        const grammer = await res.text();
        parser = PEG.buildParser(grammer);
    }


    const pause = time => new Promise(resolve => setTimeout(resolve, time))
    const musictime_ = document.getElementById("musictimeid");
    var MUSIC_TIME = musictime_.value;

    function movePiece(cl, move, spanmove, sound = true) {
        var src_loc = null, dest_loc = null, role = null, src = null, hint = null;
        var piece = (cl == 'lt') ? move.white : move.black;  
        var len = piece.length;
        role = piece[0]; 
        dest_loc = piece.slice(-2);
        if (piece == "O-O") {
             src_loc = [ (cl == 'lt') ? "e1" : "e8" ]; dest_loc = (cl == 'lt') ? "g1" : "g8";
        } else
        if ( piece == "O-O-O") {
             src_loc = [ (cl == 'lt') ? "e1" : "e8" ]; dest_loc = (cl == 'lt') ? "c1" : "c8";
        } else if (len == 2) {
             dest_loc = piece;
             src_loc = find_location(cl, piece[0], dest_loc);
        } else if (len == 3) {
             src_loc = find_location(cl, role, dest_loc);
        } else
        if (len == 4) { // e.g. Rxe1 exd1 Rhe1
             hint = piece[1];
             if (hint != 'x') { hint = null; src = piece[1]; }
             src_loc = find_location(cl, role, dest_loc, hint, src);
        } else
        if (len == 5) { // e.g. Rhxe1 R8xe1  Nh8g6
             hint = piece[2];
             if (hint == 'x') {
                   src = piece[1];
             } else {
                   hint = null;
                   src = piece.slice(1,3).match(/[a-h][1-8]/)[0]
             }
             src_loc = find_location(cl, role, dest_loc, hint, src);
        } else
        if (len == 6) { // e.g. Rh8xe1
             src = piece.slice(1,3); hint = piece[3];
             src_loc = find_location(cl, role, dest_loc, hint, src);
        }
        if (src_loc.length < 1) illegal_move('Illegal move (99)!');
        log("Final " + cl + " location: " + src_loc + " " + dest_loc);
        if (spanmove != null) { spanmove.className = "chesspiecenomove"; }
        const mid = (cl == 'lt') ? "moveidl" : "moveidd"
        spanmove = document.getElementById( mid + move.step);
        if (spanmove != null) spanmove.className = "chesspiecemove";
        piece = place(src_loc, dest_loc, (cl == 'lt') ? move.wpromote : move.bpromote, sound);
        return { piece: piece, spanmove: spanmove };
    }

    
    var F_WELO_OPS_ = null, F_BELO_OPS_ = null, F_MOVES_OPS_ = null, 
        F_WELO_ = null, F_BELO_ = null, F_MOVES_ = null, F_RES1_ = null, F_RES2_ = null, F_RES3_ = null;
    function filterPlay() {
        f_welo_ops = document.getElementById("filter_welo_ops");
        f_belo_ops = document.getElementById("filter_belo_ops");
        f_moves_ops = document.getElementById("filter_moves_ops");
        f_welo = document.getElementById("filter_welo");
        f_belo = document.getElementById("filter_belo");
        f_moves = document.getElementById("filter_moves");

        f_res1 = document.getElementById("filter_res1");
        f_res2 = document.getElementById("filter_res2");
        f_res3 = document.getElementById("filter_res3");

        F_WELO_OPS_ = f_welo_ops.options[f_welo_ops.selectedIndex].value;
        F_BELO_OPS_ = f_belo_ops.options[f_belo_ops.selectedIndex].value;
        F_MOVES_OPS_ = f_moves_ops.options[f_moves_ops.selectedIndex].value;

        F_WELO_ = f_welo.value; F_BELO_ = f_belo.value; F_MOVES_ = f_moves.value;
        F_RES1_ = (f_res1.checked) ? f_res1.value : null;
        F_RES2_ = (f_res2.checked) ? f_res2.value : null;
        F_RES3_ = (f_res3.checked) ? f_res3.value : null;
    }

    var ECO_ = null;
    async function loadECO() {
        const res = await fetch('/jscripts/eco2.pgn');
        var eco = await res.text();
        eco = eco.split(/\n/);
        const eco_ = []
        for (var p in eco) {
            const variation = eco[p].replace(/"/g,"").replace(/[ ]+/g, " ").split("~");
            variation[variation.length-1] = variation[variation.length-1].replace(/([0-9]+\.) /g, "$1");
            eco_.push(variation);
        }
        ECO_ = eco_;
    }

    function findECO(eco, moves) {
        var eco_ = null;
        for (p in ECO_) {
          var peco = ECO_[p];
          if (peco[0] == eco) {
             eco_ = { eco: peco[0], variation: peco[2], opening:  peco[1] }
             break;
          }
        }
        return eco_; 
    }


    
    var LASTMOVE_ = null;
    function moveIt(count_, move, chk = '') {
        const wmove = move.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, '');
        if (ANALYZEGAME_ && ecoGame_.length == 0) { // handle premove for white ...
          if (count_ == 1 && SIDETOMOVE_ == BLACK) {
             const movespan0 = document.createElement("span");
             const movespan1 = document.createElement("span");
             const movespan2 = document.createElement("span");
             const movespace1 = document.createTextNode(" ");
             const movechk1 = document.createElement("span"); movechk1.innerHTML = chk; movechk1.className = 'chesscmt';
             const movecmt1 = document.createElement("span"); movecmt1.innerHTML = ""; movecmt1.className = 'chesscmt';
             movechk1.id = "chk_" + count_ + "_premove";
             movespan0.innerHTML = count_ + ".";
             movespan1.innerHTML = "(...)"; movespan1.id = "moveid" + count_ + "w";
             movespan0.className = "chesspiecestep";
             movespan1.className = "chesspiecenomove";
             CHESSGAME_.appendChild(movespan0);
             CHESSGAME_.appendChild(movespan1);
             CHESSGAME_.appendChild(movechk1);
             CHESSGAME_.appendChild(movecmt1);
             CHESSGAME_.appendChild(movespace1);
             ecoGame_.push( movespan0.innerHTML + "(...)" + chk);
          }

        }
        const movespan0 = document.createElement("span");
        const movespan1 = document.createElement("span");
        const movespan2 = document.createElement("span");
        const movespace1 = document.createTextNode(" ");
        const movechk1 = document.createElement("span"); movechk1.innerHTML = chk; movechk1.className = 'chesscmt';
        const movecmt1 = document.createElement("span"); movecmt1.innerHTML = ""; movecmt1.className = 'chesscmt';
        movechk1.id = "chk_" + count_ + "_" + move;
        LASTMOVE_ = movechk1.id;
        if (SIDETOMOVE_ == WHITE) { movespan0.innerHTML = count_ + "."; }
        movespan1.innerHTML = wmove; movespan1.id = "moveid" + count_ + ((SIDETOMOVE_ == WHITE) ? "w" : "b");
        movespan0.className = "chesspiecestep";
        movespan1.className = "chesspiecenomove";

        CHESSGAME_.appendChild(movespan0);
        CHESSGAME_.appendChild(movespan1);
        CHESSGAME_.appendChild(movechk1);
        CHESSGAME_.appendChild(movecmt1);
        CHESSGAME_.appendChild(movespace1);
        ecoGame_.push( movespan0.innerHTML + move.replace(/P/g, '') + chk);
    } 


    var PLAYBUTTON = null, PLAYING = false, INTERRUPT = false, MOVETRACKER_ = null;
    var CHESSMOVES_ = [], CURRENTGAME_ = null, CURRENTCOLOR_ = null;
    async function initializePlay(n) {
        const game = Games[n];
        if (typeof(game) == "undefined") return;
        const parsed_ = parser.parse(game.moves);
        const pmoves = parsed_[0];
        var RT_ = null;
        if (parsed_[1] != "1-0" && parsed_[1] != "0-1" && parsed_[1] != "1/2-1/2") {
            pmoves.push([parsed_[1],['']]);
        } else {
             RT_ = parsed_[1];
        }
        
        // reload Board
        if (game.fen != null) { reloadBoard(game.fen); } else { reloadBoard(); }
        // populate header
        eventid.innerHTML = game.ev + " (" + game.si + ")";
        dateid.innerHTML = game.dt.replace(/[\.\?\?]/g,"").toUpperCase();
        wplayer.innerHTML = game.wp; bplayer.innerHTML = game.bp;
        wplayertitle.innerHTML = game.wp; bplayertitle.innerHTML = game.bp;
        welo.innerHTML = "(" + game.we + ")";
        belo.innerHTML = "(" + game.be + ")";
        resid.innerHTML = game.rt;

         // get eco
         const eco_ = findECO(game.eco, game.moves);
         if (eco_ != null) {
           ecoid.innerHTML       = eco_.eco;
           openingid.innerHTML   = eco_.opening;
           variationid.innerHTML = eco_.variation.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, '');
         }
        // populate moves
        CHESSGAME_.innerHTML = "";
        var moves = CHESSMOVES_ = [];
        for (g in pmoves) {
           const move = pmoves[g][0];
           var  bmove = null, bpromote = null;
           const wmove = move[2][0].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                       replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                       replace(/R/g,'&#9814;');
           const wpromote = move[2][1].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                       replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                       replace(/R/g,'&#9814;');
           if (typeof(move[4]) == "object") {
                 bmove = move[4][0].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                       replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                       replace(/R/g,'&#9814;');
                  bpromote = move[4][1].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                       replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                       replace(/R/g,'&#9814;');
           } else {
                 resid.innerHTML = game.rt = (RT_ != null) ? RT_ : move[4];
           }
           const comment = pmoves[g][1];
           const movespace1 = document.createTextNode(" ");
           const movespace2 = document.createTextNode("  ");
           const movespan0 = document.createElement("span");
           const movespan1 = document.createElement("span");
           const movespan2 = document.createElement("span");
           const movechk1 = document.createElement("span"); movechk1.innerHTML = move[2][2]; movechk1.className = 'chesscmt';
           const movechk2 = document.createElement("span"); 
           movechk2.innerHTML = (typeof(move[4]) == "object") ? move[4][2] : ""; 
           movechk2.className = 'chesscmt';
           const movecmt1 = document.createElement("span"); movecmt1.innerHTML = move[2][3]; movecmt1.className = 'chesscmt';
           const movecmt2 = document.createElement("span"); 
           movecmt2.innerHTML = (typeof(move[4]) == "object") ? move[4][3] : ""; 
           movecmt2.className = 'chesscmt';

           movespan0.innerHTML = move[0] + ".";
           movespan1.innerHTML = wmove + wpromote; movespan1.id = "moveidl" + move[0];
           movespan2.innerHTML = bmove + bpromote; movespan2.id = "moveidd" + move[0];
           movespan0.className = "chesspiecestep";
           movespan1.className = "chesspiecenomove";
           movespan2.className = "chesspiecenomove";
           movespan1.onclick = jumpPlay; movespan1.internal_ = { tracker_: g, color: 'lt' }
           movespan2.onclick = jumpPlay; movespan2.internal_ = { tracker_: g, color: 'dt' }
           CHESSGAME_.appendChild(movespan0);
           CHESSGAME_.appendChild(movespan1);
           CHESSGAME_.appendChild(movechk1);
           CHESSGAME_.appendChild(movecmt1);
           CHESSGAME_.appendChild(movespace1);
           if (typeof(move[4]) == "object") {
              CHESSGAME_.appendChild(movespan2);
              CHESSGAME_.appendChild(movechk2);
              CHESSGAME_.appendChild(movecmt2);
              CHESSGAME_.appendChild(movespace2);
           }
           if (typeof(move[4]) == "object") {
             CHESSMOVES_.push({ step: move[0], white: move[2][0], black: move[4][0], 
                    wpromote: move[2][1], bpromote: move[4][1], wcheck: move[2][2], bcheck: move[4][2] });
           } else {
             CHESSMOVES_.push({ step: move[0], white: move[2][0], black: null, 
                    wpromote: move[2][1], bpromote: null, wcheck: move[2][2], bcheck: null });
           }
        }
        const movespace3 = document.createTextNode("   ");
        const movespan3 = document.createElement("span");
        movespan3.className = "chesspiecers";
        movespan3.style.color = "#1255b3";
        movespan3.innerHTML = " " + game.rt;
        CHESSGAME_.appendChild(movespace3);
        CHESSGAME_.appendChild(movespan3);
        return moves;
     }

    function place(where, location, promote = null, sound = true) {
        if (where.length > 1) { // multiple
          for (p in where) {
            const where_ = where[p];
            if (Board[where_] != null) {
                Board[where_].move = { location: location, promote: promote } ;
                if (sound) chess_move.play();
                return Board[location];
            }
          }
        } else {
            Board[where].move = { location: location, promote: promote } ;
            if (sound) chess_move.play();
            return Board[location];
        }
    }

    function showGame(obj) {
       var g = obj.innerHTML;
       g = g.replace(". ", ""); 
       const game_ = document.getElementById("gametrid" + g);
       game_.scrollIntoView();
    }

     // start playing
     async function play(bt) {
        if (PLAYING || REPEATPLAY_) { return };
        if (bt != null) CURRENTGAME_ = bt.value;
        var current_ = document.getElementById("currentgameid");
        var movep_ = null;
        PLAYING = true;
        var moves = await initializePlay(CURRENTGAME_);
        if (MOVETRACKER_ != null && moves.length == parseInt(MOVETRACKER_) + 1) { MOVETRACKER_ = '-1' };
        var INT_TRACKER = MOVETRACKER_, spanmove = null;
        current_.innerHTML = (parseInt(CURRENTGAME_) + 1) + ". ";

        emptySource();
        emptyBench();
        initTimer(WHITE);
        initTimer(BLACK);
        sortBenchedPieces();

        if (INT_TRACKER == null || INT_TRACKER == '-1') await pause(MUSIC_TIME);
        chess_move.volume = 1.0;
        bt.parentNode.parentNode.className = "chesstr chesstrcurrent";
        for (g in moves) {
           if (INTERRUPT || LOADPGN_) { break; }
           if (INT_TRACKER != null && INT_TRACKER != '-1') {
              if (moves[g].white == "(...)" || moves[g].white == "..") { /* do nothing */ } else {
                  movep_ =  await movePiece('lt', moves[g], spanmove); spanmove = movep_.spanmove; setSource(movep_.piece);
              }
              if (moves[g].black != null) {
                 movep_ =  await movePiece('dt', moves[g], spanmove); spanmove = movep_.spanmove; setSource(movep_.piece);
                 if (INT_TRACKER == g) {
                    INT_TRACKER = null;
                    if (CURRENTCOLOR_ == 'lt') await pause(MUSIC_TIME); 
                 }
              }
              continue;
           }
           MOVETRACKER_ = g;
           if (moves[g].white == "(...)" || moves[g].white == "..") { /* do nothing */ } else {
             movep_ =  await movePiece('lt', moves[g], spanmove); spanmove = movep_.spanmove; setSource(movep_.piece);
             await pause(MUSIC_TIME); CURRENTCOLOR_ = 'lt';
           }
           if (moves[g].black != null) {
             movep_ =  await movePiece('dt', moves[g], spanmove); spanmove = movep_.spanmove; setSource(movep_.piece);
             if (g > 127 || g == 1) spanmove.scrollIntoView();
             await pause(MUSIC_TIME); CURRENTCOLOR_ = 'dt';
           }
        }

        // chess_awalker.pause();
 
        // release playing status
        PLAYING = false; INTERRUPT = false;  LOADPGN_ = false;
        bt.innerHTML = "&#8594;"
        bt.onclick = proceedPlay;
    }

    // interrupt play
    var int_interval = 0, playtime = null;
    function readyPlay(bt) {
        if (int_interval > 20) { int_interval = 0; clearInterval(playtime)  }
        int_interval ++;
        if (!INTERRUPT) {
           int_interval = 0;
           clearInterval(playtime);
           if (PLAYBUTTON != null && PLAYBUTTON.value != bt.value) {
              PLAYBUTTON.innerHTML = "&#8594;";
              PLAYBUTTON.onclick = proceedPlay;
              MOVETRACKER_ = null; CURRENTCOLOR_ = null;
              PLAYBUTTON.parentNode.parentNode.className = "chesstr";
           }
           bt.innerHTML = "&#9675;";
           bt.onclick = interruptPlay;
           PLAYBUTTON = bt;
           play(bt);
        }
    }

    function proceedPlay() {  
        const bt = this;
        if (!DONEGAME_) { message("There is an active game!", false); return }
        if (REPEATPLAY_) return;
        if (PLAYING && !INTERRUPT) {
            INTERRUPT = true;
            int_interval = 0;
            playtime = setInterval(readyPlay, 50, this);
        } else if (!PLAYING && !INTERRUPT) {
            if (PLAYBUTTON != null && PLAYBUTTON.value != bt.value) {
               MOVETRACKER_ = null; CURRENTCOLOR_ = null;
               PLAYBUTTON.parentNode.parentNode.className = "chesstr";
           }
           if (REPEATBUTTON_ != null) REPEATBUTTON_.parentNode.parentNode.className = "chesstr";
           bt.innerHTML = "&#9675;";
           bt.onclick = interruptPlay;
           PLAYBUTTON = bt;
           play(bt);
        }
    }

    function interruptPlay() {
        if (REPEATPLAY_) return;
        const bt = this;
        bt.innerHTML = "&#8594;";
        bt.onclick = proceedPlay;
        INTERRUPT = true; // this will trigger the async play function to quit
    }

    function keyPress() { document.onkeydown = keyPlay; }

    async function keyPlay(e) {
        e = e || window.event;
       if (PLAYING || REPEATPLAY_) return;
       if (e.keyCode == '38') { // up
       }
       else if (e.keyCode == '40') { // down
       }
       else if (e.keyCode == '37') { // left
         backwardPlay();
       }
       else if (e.keyCode == '39') {  // right
         forwardPlay();
       }
    }

    // calculate time
    function calcTime(timer, start) {
        const sec = ( Date.now() - start ) / 1000;
        const hr = Math.floor(sec / 3600);
        const min = (sec % 3600) / 60;
        timer.innerHTML = hr + ":" + min.toFixed(1);
    }

    function emptyBench() {
       while (Benched.length) Benched.pop();
       wcapture.innerHTML = '';
       bcapture.innerHTML = '';
    }

    // repeat Play
    var REPEATPLAY_ = false, REPEATWHERE_ = null, REPEATBUTTON_ = null;
    async function repeatPlay() {
       if (!DONEGAME_) { message("There is an active game!", false); return }
       if (PLAYING) return;
       var current_ = document.getElementById("currentgameid");
       var limit = document.getElementById("limitmoveid");
       var repeatbt = document.getElementById("repeatid");
       if (Games.length > 0) {
         const len_ = Games.length;
         REPEATPLAY_ = true;
         repeatbt.innerHTML = "&#10074;&#10074;";
         repeatbt.onclick = interruptRepeat;
         if (PLAYBUTTON != null) { REPEATWHERE_ = PLAYBUTTON.value; }
         if (PLAY_AW_) { chess_awalker.volume = 1.0; chess_move.volume = 0.0 } else { chess_move.volume = 1.0 }
         var start = Date.now(), movep_ = null;
         const timer = document.getElementById('timerid');

         initTimer(WHITE);
         initTimer(BLACK);
          
         for (var i=0; i < len_; i++) {
           const bt = document.getElementById("gameid" + i);
           if (bt != null) { 
             if (LOADPGN_) {
                  bt.innerHTML = "&#8594;";
                  bt.onclick = proceedPlay;
                  repeatbt.innerHTML = "&#9654;";
                  repeatbt.onclick = repeatPlay;
                  REPEATWHERE_ = null; LOADPGN_ = false;
                  return;
             } else
             if (REPEATPLAY_ ==  false) { 
                  bt.innerHTML = "&#8594;";
                  bt.onclick = proceedPlay;
                  repeatbt.innerHTML = "&#9654;";
                  repeatbt.onclick = repeatPlay;
                  REPEATWHERE_=i; 
                  return; 
             }
             if (REPEATWHERE_ != null) { if (i!=REPEATWHERE_) { continue; } else { REPEATWHERE_ = null }}
             if (REPEATBUTTON_!= null) {  
                REPEATBUTTON_.parentNode.parentNode.className = "chesstr"; 
                REPEATBUTTON_.scrollIntoView();
             }
             current_.innerHTML  = (parseInt(i) + 1) + ". ";
             bt.innerHTML = "&#9675;"; 
             bt.onclick = interruptPlay;
             bt.parentNode.parentNode.className = "chesstr chesstrcurrent"; 
             REPEATBUTTON_ = bt;

             emptySource();
             emptyBench();

             calcTime(timer, start);
             const moves = await initializePlay(i);
             await pause(MUSIC_TIME * 1);
         
             var spanmove = null, cnt_mv = 0;
             for (g in moves) {
                 if (LOADPGN_) {
                   REPEATWHERE_ = null; LOADPGN_ = false;
                   bt.innerHTML = "&#8594;";
                   bt.onclick = proceedPlay;
                   repeatbt.innerHTML = "&#9654;";
                   repeatbt.onclick = repeatPlay;
                   return;
                 } else
                 if (REPEATPLAY_ ==  false) { 
                      bt.innerHTML = "&#8594;";
                      bt.onclick = proceedPlay;
                      repeatbt.innerHTML = "&#9654;";
                      repeatbt.onclick = repeatPlay;
                      REPEATWHERE_=i; 
                      return; 
                 }
                 if (PLAY_AW_) {  chess_awalker.play(); chess_move.volume = 0.0; } else { chess_move.volume = 1.0 }
                 if (moves[g].white == "(...)" || moves[g].white == "..") { /* do nothing */ } else {
                    movep_ =  await movePiece('lt', moves[g], spanmove); spanmove = movep_.spanmove; setSource(movep_.piece);
                    await pause(MUSIC_TIME); CURRENTCOLOR_ = 'lt';
                 }
                 if (moves[g].black != null) {
                   movep_ =  await movePiece('dt', moves[g], spanmove); spanmove = movep_.spanmove; setSource(movep_.piece);
                   await pause(MUSIC_TIME); CURRENTCOLOR_ = 'dt';
                 }
                 if (g > 127 || g == 1) spanmove.scrollIntoView();
                 cnt_mv += 1;
                 if (cnt_mv >= limit.value) break; 
             }
             bt.innerHTML = "&#8594;";
             bt.onclick = proceedPlay;
             await pause(MUSIC_TIME * 1.124);
           }
         }
         repeatbt.innerHTML = "&#9654;";
         repeatbt.onclick = repeatPlay;
         REPEATWHERE = null;
       }
    }

    function interruptRepeat() {
         REPEATPLAY_ = false;    
         chess_awalker.pause();
    }

    var jmp_interval = 0, jumptime = null;
    async function readyJump(obj) {
        jmp_interval += 1;
        if (jmp_interval > 20) { jmp_interval = 0; clearInterval(jumptime)  }
        if (!PLAYING) {
          jmp_interval = 0;
          clearInterval(jumptime);
          MOVETRACKER_ = obj.internal_.tracker_;
          CURRENTCOLOR_ = obj.internal_.color;
          return await jumpMove();
        }
    } 

    async function jumpPlay() {
        if (REPEATPLAY_) return;
        if (PLAYING) {
          INTERRUPT = true;
          jmp_interval = 0;
          jumptime = setInterval(readyJump, 50, this);
        } else {
          const obj = this;
          MOVETRACKER_ = obj.internal_.tracker_;
          CURRENTCOLOR_ = obj.internal_.color;
          return await jumpMove();
        }
    }

    async function jumpMove(sound=true) {

        moves = await initializePlay(CURRENTGAME_);
        var spanmove = null, stoptracker_ = MOVETRACKER_, movep_;
        emptySource();
        emptyBench();
        for (g in moves) {
           movep_ =  await movePiece('lt', moves[g], spanmove, sound); spanmove = movep_.spanmove; setSource(movep_.piece);
           if (g == stoptracker_) {
               if (CURRENTCOLOR_ == 'dt' & moves[g].black != null) {
                   movep_ =  await movePiece('dt', moves[g], spanmove, sound); spanmove = movep_.spanmove; setSource(movep_.piece);
                }
               break;
           }
           
           spanmove =  await movePiece('dt', moves[g], spanmove, sound).spanmove;
        }
        return { moves: moves, spanmove: spanmove }
    }

    // forward Play
    async function forwardPlay() {
        if (REPEATPLAY_ || PLAYING) return;
        var len_ = CHESSMOVES_.length, tracker_ = parseInt(MOVETRACKER_);
        if (CURRENTCOLOR_ == 'dt') { tracker_ += 1; }
        if (tracker_ < 0) tracker_ = -1;
        if (tracker_ < len_) {
            var new_tracker_ = String(tracker_);
            CURRENTCOLOR_ = (CURRENTCOLOR_ == 'dt') ? 'lt' : 'dt';
            MOVETRACKER_ = new_tracker_;
            await jumpMove();
         }
    }

    async function backwardPlay() {
        if (REPEATPLAY_ || PLAYING) return;
        var tracker_ = parseInt(MOVETRACKER_);
        if (tracker_ < 0) return;
        var len_ = CHESSMOVES_.length, tracker_ = parseInt(MOVETRACKER_);
        if (CURRENTCOLOR_ == 'lt') { tracker_ -= 1; }
        if (tracker_ >= 0 ) {
            var new_tracker_ = String(tracker_);
            CURRENTCOLOR_ = (CURRENTCOLOR_ == 'dt') ? 'lt' : 'dt';
            MOVETRACKER_ = new_tracker_;
            await jumpMove();
        } else {
            resetGame(sound=false);
        }
    }


    async function resetGame(sound=true) {
        if (REPEATPLAY_ || PLAYING) return;
        if (MOVETRACKER_ == '-1' || MOVETRACKER_ == null) return;
        MOVETRACKER_ = '-1'; CURRENTCOLOR_ = 'dt';
        moves = await initializePlay(CURRENTGAME_);
        emptySource();
        emptyBench();
        if (sound) { chess_reset.play();} else { chess_move.play(); }
    }

    async function endGame() {
        if (REPEATPLAY_ || PLAYING) return;
        var len_ = CHESSMOVES_.length;
        MOVETRACKER_ = String(len_ - 1);
        CURRENTCOLOR_ = 'dt';
        await jumpMove();
    }

    function evalFilter(game) {
       var filter_ = true ;
       var moves_ = game.moves.split(' ').length - 4; moves_ = Math.floor(moves_ / 2); 
       if (F_WELO_OPS_ == "=") if (parseInt(game.we) != parseInt(F_WELO_)) filter_ = false;
       if (F_WELO_OPS_ == ">=") if (parseInt(game.we) < parseInt(F_WELO_)) filter_ = false;
       if (F_WELO_OPS_ == "<=") if (parseInt(game.we) > parseInt(F_WELO_)) filter_ = false;

       if (F_BELO_OPS_ == "=") if (parseInt(game.we) != parseInt(F_BELO_)) filter_ = false ;
       if (F_BELO_OPS_ == ">=") if(parseInt(game.we) < parseInt(F_BELO_))  filter_ = false;
       if (F_BELO_OPS_ == "<=") if(parseInt(game.we) > parseInt(F_BELO_))  filter_ = false;

       if (F_MOVES_OPS_ == "=") if (moves_ != parseInt(F_MOVES_))  filter_ = false;
       if (F_MOVES_OPS_ == ">=") if (moves_ < parseInt(F_MOVES_)) filter_ = false;
       if (F_MOVES_OPS_ == "<=") if (moves_ > parseInt(F_MOVES_))  filter_ = false;

       if (F_RES1_ == null) if (game.rt == "1-0")  filter_ = false;
       if (F_RES2_ == null) if (game.rt == "0-1")  filter_ = false;
       if (F_RES3_ == null) if (game.rt == "1/2-1/2")  filter_ = false;

       return filter_;
    }


    function sortGames(g1, g2) {
         var res = 0, ORDER = 0;
         for (var i=1; i<=6; i++) {
           ORDER = ORDERS_[i-1];
           if (ORDER != 0) {
              if (ORDER == 1) {
                  if (i == 1)  res =  ((g2.wp) > (g1.wp)) ? 1 : -1;
                  if (i == 2)  res =  ((g2.we) > (g1.we)) ? 1 : -1;
                  if (i == 3)  res =  ((g2.bp) > (g1.bp)) ? 1 : -1;
                  if (i == 4)  res =  ((g2.be) > (g1.be)) ? 1 : -1;
                  if (i == 5)  res =  ((g2.rt) > (g1.rt)) ? 1 : -1;
                  if (i == 6)  res =  ((g2.ct) > (g1.ct)) ? 1 : -1;
              } else
              if (ORDER == 2) {
                  if (i == 1)  res =  ((g2.wp) < (g1.wp)) ? 1 : -1;
                  if (i == 2)  res =  ((g2.we) < (g1.we)) ? 1 : -1;
                  if (i == 3)  res =  ((g2.bp) < (g1.bp)) ? 1 : -1;
                  if (i == 4)  res =  ((g2.be) < (g1.be)) ? 1 : -1;
                  if (i == 5)  res =  ((g2.rt) < (g1.rt)) ? 1 : -1;
                  if (i == 6)  res =  ((g2.ct) < (g1.ct)) ? 1 : -1;
              }
          }
         }
         return res;
    }

    // order List // &#8593; up // &#8595; down // &#8597; neutral
    // 0 = no order, 1 = descending, 2 = ascending
    const ORDERS_ = [0,0,0,0,0,0];
    const ORDERSDESC_ = ["White Side","Elo","Black Side","Elo","Result","Cnt"];
    function orderGame() {
       if (PLAYING || REPEATPLAY_) return;
       var bt = this; 
       var ORDER_ = 0, HTML = "";
       const OGames = Games;
       for (var i=1; i<=6; i++) {
         if (bt.value == i) {
             ORDER_ = ORDERS_[i-1];
             if (ORDER_ == 0) { HTML = "&#8595;"; ORDER_ = 1; } else  // change to 1
             if (ORDER_ == 1) { HTML = "&#8593;"; ORDER_ = 2; } else // change to 2
             if (ORDER_ == 2) { HTML = "&#8595;"; ORDER_ = 1; } // change to 1
             ORDERS_[i-1] = ORDER_;
             bt.innerHTML = ORDERSDESC_[i-1] + HTML;
         } else { 
             ORDERS_[i-1] = 0;
             bt.innerHTML = ORDERSDESC_[i-1] + "&#8597;";
         }
       }
       const ordered = Games.sort(sortGames);
       Games = ordered;
       refreshGames(true, bt.value);
    }

    // Now load a PGN
    var Games = [];
    async function fetchPGN(pgn_){
        const res = await fetch(pgn_);
        const pgngame = await res.json();
        Games = [];

        class Game {
           constructor (game) {
           var moves_ = game.moves.split(' ').length - 4; moves_ = Math.floor(moves_ / 2); 
           game.ct = moves_;
           this.detail_ = game;
 
         }
           get detail()  { return this.detail_; }
        }

        for (let i=0; i < pgngame.length; i++) {
             const game = new Game(pgngame[i])
             Games.push(game.detail)
        }
        if (Games.length > 0) {   
          // Disable Engine
          NEWGAME_ = false; FETCHEDGAME_ = true;
          refreshGames(false, null);
        }
        const dbid = document.getElementById('choosedatabaseid_');
        dbid.style.visibility = 'hidden';
     }

    function refreshGame() {
        const chesstable = document.getElementById("chesstableid");
        const tbody = document.createElement('tbody');

        if (chesstable.firstChild != null) {
            chesstable.replaceChild(tbody, chesstable.firstChild);
        } else {
            chesstable.appendChild(tbody);
        }
        var td = null, txtnode;
        var game_cnt = 0;
        for (var p in Games) {
            const game = Games[p]
           if (game.we != "" && game.be != "") {

            game_cnt += 1;
            const tr = document.createElement("tr");

            const tdcnt = document.createElement("td"); const cnt = document.createTextNode(game_cnt);
            const tdev = document.createElement("td"); const ev = document.createTextNode(game.ev.slice(0,35));
            const tdwp = document.createElement("td"); const wp = document.createTextNode(game.wp.slice(0,23));
            const tdbp = document.createElement("td"); const bp = document.createTextNode(game.bp.slice(0,23));
            const tdwe = document.createElement("td"); const we = document.createTextNode(game.we);
            const tdbe = document.createElement("td"); const be = document.createTextNode(game.be);
            const tdrt = document.createElement("td"); const rt = document.createTextNode(game.rt);
            const tdbt = document.createElement("td"); const bt = document.createElement("button");
            const tdec = document.createElement("td");
            const ec = document.createTextNode(typeof game.eco === "undefined" ? "" : game.eco);

            const tdct = document.createElement("td"); const ct = document.createTextNode(game.ct);
            tdev.appendChild(ev); tdcnt.appendChild(cnt);
            tdwp.appendChild(wp); tdbp.appendChild(bp); tdwe.appendChild(we);
            tdbe.appendChild(be); tdrt.appendChild(rt); tdbt.appendChild(bt);
            tdct.appendChild(ct); tdec.appendChild(ec);
            tr.id = "gametrid" + p;
            tr.appendChild(tdbt); tr.appendChild(tdcnt); tr.appendChild(tdct);
            tr.appendChild(tdwp); tr.appendChild(tdwe);
            tr.appendChild(tdbp); tr.appendChild(tdbe); tr.appendChild(tdrt);
            tr.appendChild(tdec); tr.appendChild(tdev); tr.appendChild(tdct);
            tr.className = "chesstr";
            tdcnt.className = "chesstdb"; tdev.className = "chesstde";  tdec.className = "chesstce";
            tdwp.className = "chesstdp"; tdbp.className = "chesstdp"; tdwe.className = "chesstdl";
            tdbe.className = "chesstdl"; tdrt.className = "chesstdr";  tdbt.className = "chesstdb";
            tdct.className = "chesstdb";
            tbody.appendChild(tr);

            bt.innerHTML = "&#8594;";
            bt.onclick = proceedPlay;
            bt.value = p;
            bt.id = "gameid" + p;

            bt.innerHTML = "&#8594;";
            bt.onclick = proceedPlay;
            bt.value = p;
            bt.id = "gameid" + p;
            tr.className = "chesstr chesstrcurrent";

            if (p == Games.length - 1) {
              tr.className = "chesstr chesstrcurrent";
              PLAYBUTTON = bt;
              tr.scrollIntoView();
            } else {
              tr.className = "chesstr";
            }
           }
        }
        var current_ = document.getElementById("currentgameid");
        current_.innerHTML = Games.length + '. ';
    }

     var FETCHEDGAME_ = false;
     function refreshGames(sorted = false, bttn_ = null) {
        // populate html
        const chesstable = document.getElementById("chesstableid");
        const tbody = document.createElement('tbody');

        if (chesstable.firstChild != null) {
            chesstable.replaceChild(tbody, chesstable.firstChild);
        } else {
            chesstable.appendChild(tbody);
        }

        var td = null, txtnode;
        var game_cnt = 0;
        filterPlay();
        for (var p in Games) {
            const game = Games[p]
           if (game.we != "" && game.be != "") {
            if (evalFilter(game) ==  false) continue;
            game_cnt += 1;
            // var moves_ = game.moves.split(' ').length - 4; moves_ = Math.floor(moves_ / 2); 
            if (game_cnt == 1) {
              const tr1 = document.createElement("tr");
              const td1 = document.createElement("td"); td1.appendChild(document.createTextNode(""));
              const td2 = document.createElement("td"); td2.appendChild(document.createTextNode(""));
              const td3 = document.createElement("td"); td3.appendChild(document.createTextNode(""));
              const td4 = document.createElement("td"); td4.appendChild(document.createTextNode(""));
              const tdowp  = document.createElement("td"); const owp = document.createElement("button");
              const tdowe  = document.createElement("td"); const owe = document.createElement("button");
              const tdobp  = document.createElement("td"); const obp = document.createElement("button");
              const tdobe  = document.createElement("td"); const obe = document.createElement("button");
              const tdort  = document.createElement("td"); const ort = document.createElement("button");
              const tdocnt = document.createElement("td"); const ocnt = document.createElement("button");
              // #8593; up // &#8595; down
              tdowp.appendChild(owp); tdowe.appendChild(owe); tdobp.appendChild(obp); 
              tdobe.appendChild(obe); tdort.appendChild(ort); tdocnt.appendChild(ocnt);
              const bts_ = [ owp, owe, obp, obe, ort, ocnt ];
              for (var i=1; i<=6; i++ ) {
                  const bt_ = bts_[i-1];
                  bt_.onclick = orderGame;
                  bt_.value = i;
                  bt_.innerHTML = ORDERSDESC_[i-1] + "&#8597;"; 
                  if (sorted && bttn_ == i) {
                    if (ORDERS_[i-1] == 1) bt_.innerHTML = ORDERSDESC_[i-1] + "&#8595;"; else
                    if (ORDERS_[i-1] == 2) bt_.innerHTML = ORDERSDESC_[i-1] + "&#8593;"; 
                  }
              }
              tr1.appendChild(td1);
              tr1.appendChild(td2);
              tr1.appendChild(tdowp); tr1.appendChild(tdowe);
              tr1.appendChild(tdobp); tr1.appendChild(tdobe);
              tr1.appendChild(tdort); 
              tr1.appendChild(td3);
              tr1.appendChild(td4);
              tr1.appendChild(tdocnt);
              tdowp.className = "chesstdp"; tdobp.className = "chesstdp"; 
              tdowe.className = "chesstdl"; tdobe.className = "chesstdl"; 
              td1.className = "chesstdb"; td2.className = "chesstdb";
              td3.className = "chesstce"; td4.className = "chesstde";
              tdort.className = "chesstdb";
              tr1.className = "chesstr"; 
              tbody.appendChild(tr1);
            }

            const tr = document.createElement("tr");

            const tdcnt = document.createElement("td"); const cnt = document.createTextNode(game_cnt);
            const tdev = document.createElement("td"); const ev = document.createTextNode(game.ev.slice(0,35));
            const tdwp = document.createElement("td"); const wp = document.createTextNode(game.wp.slice(0,23));
            const tdbp = document.createElement("td"); const bp = document.createTextNode(game.bp.slice(0,23));
            const tdwe = document.createElement("td"); const we = document.createTextNode(game.we);
            const tdbe = document.createElement("td"); const be = document.createTextNode(game.be);
            const tdrt = document.createElement("td"); const rt = document.createTextNode(game.rt);
            const tdbt = document.createElement("td"); const bt = document.createElement("button"); 
            const tdec = document.createElement("td"); 
            const ec = document.createTextNode(typeof game.eco === "undefined" ? "" : game.eco); 

            const tdct = document.createElement("td"); const ct = document.createTextNode(game.ct);
            tdev.appendChild(ev); tdcnt.appendChild(cnt);
            tdwp.appendChild(wp); tdbp.appendChild(bp); tdwe.appendChild(we); 
            tdbe.appendChild(be); tdrt.appendChild(rt); tdbt.appendChild(bt);
            tdct.appendChild(ct); tdec.appendChild(ec);
            tr.id = "gametrid" + p;
            tr.appendChild(tdbt); tr.appendChild(tdcnt); tr.appendChild(tdct); 
            tr.appendChild(tdwp); tr.appendChild(tdwe); 
            tr.appendChild(tdbp); tr.appendChild(tdbe); tr.appendChild(tdrt);
            tr.appendChild(tdec); tr.appendChild(tdev); tr.appendChild(tdct); 
            tr.className = "chesstr";
            tdcnt.className = "chesstdb"; tdev.className = "chesstde";  tdec.className = "chesstce";
            tdwp.className = "chesstdp"; tdbp.className = "chesstdp"; tdwe.className = "chesstdl";
            tdbe.className = "chesstdl"; tdrt.className = "chesstdr";  tdbt.className = "chesstdb";
            tdct.className = "chesstdb";
            tbody.appendChild(tr);

            bt.innerHTML = "&#8594;";
            bt.onclick = proceedPlay;
            bt.value = p;
            bt.id = "gameid" + p;

            if (p == '0') {
              tr.className = "chesstr chesstrcurrent";
              tr.scrollIntoView();
              PLAYBUTTON = bt;
            }
           }
        }
        var current_ = document.getElementById("currentgameid");
        var repeatbt = document.getElementById("repeatid");
        current_.innerHTML = '1. ';
        repeatbt.value = "&#9654;"; repeatbt.innerHTML = "&#9654;";
        const totalid = document.getElementById("totalid"); totalid.innerHTML = game_cnt;
        MOVETRACKER_ = null; CURRENTCOLOR_ = null; LOADPGN_ = false; INTERRUPT = false;
        REPEATPLAY_ = false; REPEATWHERE_ = null; REPEATBUTTON_ = null; 
        chess_awalker.pause(); chess_awalker.currentTime = 0
        initializePlay(0);
   }

   var pgn_interval = 0;
   function readyPGN(pgn_) {
     if (pgn_interval > 20) { pgn_interval = 0; clearInterval(pgntime); message("Loading database ...", false); fetchPGN(pgn_);return  }
     pgn_interval ++;
     if (LOADPGN_ == false) {
          pgn_interval = 0;
          clearInterval(pgntime);
          LOADPGN_ = false;
          message("Loading database ...", false);
          fetchPGN(pgn_);
     }
   }

   var pgntime = null , LOADPGN_ = false;
   async function loadPGN(pgn_){
        INTERRUPT = true; LOADPGN_ = true;
        pgn_interval = 0;
        pgntime = setInterval(readyPGN, 50, pgn_);
   }

  // log("Sizing Board ...");
  // sizeBoard();
  // log("Render Board ...");
  // reloadBoard();
  // log(Board);
  // log("Expand");
 //  resizeBoard(); 
   log("Load Parser ...");
   loadParser();
   log("Load ECO ...");
   loadECO();
   log("Load Stockfish ...");
   loadStockfish();
   log("Enable Key Event Capture ...");
   keyPress();
</script>
</body>
</html>
