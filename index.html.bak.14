<!DOCTYPE html>
<html lang="en" Cross-Origin-Embedder-Policy: require-corp>
<head>
  <meta charset="UTF-8">
  <title>Chess Repertoire</title>

<style type="text/css" id="genericpieceid" >
.piece { position: absolute; width: 0px; height: 0px; margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; border: 0px solid #00ff00; }
}
</style>

<style type="text/css" id="chesstable" >
.chessdiv { position: absolute; top: 0px; left: 0px; width: 5000px; height: 5000px; background-color: #24262A; margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px }
.chesscontainer { position: absolute; border: 3px solid #dedede; margin: 0px 0px 0px; padding: 0px 0px 0px 0px; border-radius: 0px 5px 5px 5px; }
.chessbox  { position: absolute; margin: 0px; padding: 14px; width: 640px; height: 640px; background-color: #a7b093 }
.chesstable { border-collapse: collapse; width: 100%; height: 100%; margin: 0px; padding: 0px; }
.chessboard { position: absolute; top: 0px; left: 0px;  margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px }
.chessboardimg { position: absolute; top: 0px; left: 0px; width: 840px; height: 840px;; margin: 0px 0px 0px 0px  }
.chessheader { position: absolute; top: 0px; left: 0px; width: 0px; height: 25px; background-color: #dedede; 
					margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; visibility: hidden }
.chessfooter { position: absolute; top: 0px; left: 0px; width: 0px; height: 25px; background-color: #dedede;
					margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; visibility: hidden }
.chessrow { margin: 0px; padding: 0px }
.chessimg { margin: 0px; padding: 0px; }
.cellcontainer { margin: 0px; padding: 0px; top: 0px; left: 0px; font-size: 0.8em }
.darksquare { background-color: #669104; margin: 0px; padding: 0px; }
.lightsquare { background-color: #e9efdc; margin: 0px; padding: 0px; }

.rboardno { font-family: helvetica; margin: 2px 2px 2px 2px; resize: both; display: block;  position: absolute; right: 14px } /* due to tbox padding */
.bboardno { font-family: helvetica; margin: 2px 2px 2px 2px; resize: both; display: block;  position: absolute; bottom: 5px } */ due to tbox padding */
.tooltip { } /* for the collapseTool Button */
.setpieces { position: absolute; cursor: pointer; left: 10px; }
.pieceid { position: absolute; border: 1px solid #dedede; text-align: center; white-space: nowrap; font-family: helvetica }
.inputclass { position: absolute; border: 0px solid #dedede; font-family: helvetica; font-size: 12pt;  border-radius: 5px;
              box-shadow: 1px 1px 1px 1px rgb(80, 80, 80, 0.5) }
.inputclass:focus { outline: 2px solid #4FA48F; }
.defaultbtn { position: absolute; font-family: helvetica; font-weight: bold; font-size: 12pt; border-radius: 2px; cursor: pointer; background-color: #81d765; color: #252525 }
.defaultspn { position: absolute; font-family: helvetica; font-weight: bold; font-size: 12pt; border-radius: 2px; cursor: pointer; color: #252525 }
</style>
</style>

<style type="text/css">
.source { position: absolute; width: 0px; height: 0px; background-color: #000080;  opacity: 0.2; z-index: 0 }
.destination { position: absolute; width: 0px; height: 0px; background-color: #A08080;  opacity: 0.2; z-index: 0 }

.popupdiv { position: absolute; top: 0px; left: 0px; width: 0px; height: 0px; background-color: #d0d0d0; box-shadow: 3px 3px 3px 3px rgb(50, 50, 50, 0.5);
             padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px; border: 1px solid #dedede; }
.popup { position: absolute; top: 0px; left: 0px; bottom: 0px; right: 0px; font-weight: normal; 
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; }
.popspan { display: block; width: 0px; height: 20px; background-color: #efefef; cursor: pointer; white-space: nowrap; padding: 0px 0px 0px 10px}

.chessside0 { position: absolute; top: 0px; left: 0px; border: 0px solid #afafaf; background-color: #FFFFFF;
			width: 0px; height: 0px; margin: 0px 0px 0px 0px }
.chessside1 { position: absolute; top: 0px; left: 0px; width: 850px; height: 10px; background-color: #d0d0d0; }
.chesstitle { position: absolute; top: 0px; left: 0px; width: 98.5%; height: 80px;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px; ; background-color: #EFEFEF }
.chessgame1 { position: absolute; top: 80px; left: 0px; bottom: 23px; right: 0px; font-weight: bold;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px; ; background-color: #EFEFEF }
.chessmoves { position: absolute; top: 0px; left: 0px; width: 0px; height: 0px; background-color: #d0d0d0; 
             padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px }
.chessmovesbtn { position: absolute; bottom: 13px; left: 0px; width: 85px; height: 18px; margin: 0px 0px 0px 7px }
.chessgame { position: absolute; top: 0px; left: 0px; bottom: 0px; right: 0px; font-weight: bold;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px ; background-color: #EFEFEF }
.chessrate  { position: absolute; top: 0px; left: 0px; width: 100%; height: 50%; background-color: #404040; margin: 0px 0px 0px 0px }
.chesslisting { position: fixed; top: 0px; left: 0px; background-color: #24262A; margin: 0px 0px 0px 0px; z-index: 60000 }  /* see sidepanel for z-index */
.chesslistcv { position: absolute; margin: 0px 0px 0px 0px; background-color: #4A4C4F; z-index: 5; border: 2px solid #3a3a3a; color: #dacaca;
				width: 100px; height: 25px; top: -29px; left: 0px; }
.chesslistor { position: absolute; margin: 0px 0px 0px 0px; background-color: #4A4C4F; z-index: 5; border: 2px solid #3a3a3a;  color: #dacaca;
				width: 856px; height: 26px; top: 0px; left: 0px; padding: 0px 0px 0px 0px; }
.chesslistid { position: absolute; padding: 5px 5px 5px 5px; overflow-y:scroll; background-color: #2A2C2F; /* d0d0d0 */
			 border-collapse: collapse; top: 25px; left: 0px;  width: 850px; height: 255px; }
.chesstableid { display: block; table-layout: fixed; width: 840px; padding: 2px 2px 2px 2px; color: #D0E050; border-collapse: collapse; }
.popfilter { position: absolute; top: 300px; left: 580px; border: 1px solid #ABABAB; width: 190px; height: 180px; background-color: #EFEFEF; visibility: hidden }
.chesspiece  { font-weight: bold; font-size: 14pt; margin: 5px 5px 5px 5px; }
.chesspiecestep { color: #00AA44; font-weight: normal }
.chesspiecemove { color: #FFFFFF; background-color: #288BA8;  cursor: pointer }
.chesspiecenomove { color: #440000; cursor: pointer }
.chesscmt { color: #FF0000; font-weight: normal }
.chesstrcurrent { background-color: #afafaf; width: 850px; }
.chesstr { margin: 0px 0px 0px 0px; border: 2px solid #2A2C2F; width: 850px; }
.chesstdp { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 220px; white-space: nowrap; font-size: 11pt; color: #afafaf; }
.chesstde { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 220px; white-space: nowrap; font-size: 11pt; color: #afafaf; }
.chesstce { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 32px; white-space: nowrap; font-size: 11pt; }
.chesstdr { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 55px; white-space: nowrap; font-size: 11pt; color: #afafaf; }
.chesstdl { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 38px; white-space: nowrap; font-size: 11pt; }
.chesstdb { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 32px; }
.chessplaybtn { position: absolute; display: block; margin: 0px 0px 0px 0px }
.chessbutton { margin: 5px 5px 5px 5px }
.chessbutton1 { margin: 1px 0px 1px 0px }
.player { font-weight: bold; color: #1255b3;  }
.playerelo { font-weight: normal; color: #880000; font-family: helvetica; font-size: 12pt }
.playerrnd { font-weight: normal; color: #880000; font-family: helvetica; font-size: 12pt }
.gresult { color: #880000; font-weight: bold }
.opening { font-weight: normal; color: #000000;  }
.variation { font-weight: normal; color: #000000;  }
.playerside   { color: #12626A; font-weight: normal; font-family: helvetica; font-size: 12pt } 
.playertimer   { color: #800000; font-weight: normal; font-family: helvetica; font-size: 12pt } 
.playercapture   { color: #12626A; font-weight: bold; font-family: helvetica; font-size: 12pt } 
.sidetomove  { font-size: 16pt; font-weight: bold; color: #7E3348 }
.promocontain { font-size: 50px; position: absolute; top: 10px; left: 25px; visibility: hidden }
.promoclass { cursor: pointer; z-index: 20; border: 1px solid #ababab }
.engineclass  { margin: 0px }
.sidepanel { position: fixed; top: 0px; left: 0px; width: 120px; height: 5000px; visibility: visible; z-index: 55000; /* see chesslisting for z-index */
            background-color: #343434 }
.cubicle  { position: absolute; background-color: #343434; top: 150px; left: 60px; width: 50px; height: 600px; padding: 5px 5px 5px 5px;  }
.cubelet  { position: relative; width: 40px; height: 40px; margin: 5px 5px 5px 5px;  background-color: #393939 }
.cubelast { position: relative; width: 40px; height: 25px; margin: 5px 5px 5px 5px;  background-color: #dadada }
.disableselect { user-select: none; -webkit-user-select: none; -moz-user-select: none; }

.center { position: absolute; 25%; transform: translateY(-50%); -ms-transform: translateY(-50%); text-align; middle; width: 70%; border: 1px solid #ff0000 }
.messageid { position: absolute; border: 1px solid #81d765; text-align: center; white-space: nowrap; font-family: helvetica }
</style>
<link rel="shortcut icon" href="images/favicon.ico">
</head>
<body style="background-color: #24262A; top: 0px; left: 0px; margin: 0px 0px 0px 0px">
<div id="chessdiv" class="chessdiv disableselect"> 

<div id="sidepanel" class="sidepanel">
<div id="cubicleid" class="cubicle">
 <div class="cubelet"></div> <div class="cubelet"></div> <div class="cubelet"></div> <div class="cubelet"></div>
 <div class="cubelet"></div> <div class="cubelet"></div> <div class="cubelet"></div> <div class="cubelet"></div>
 <div class="cubelet"></div> <div class="cubelet"></div> <div class="cubelet"></div> <div class="cubelet"></div>
 <div class="cubelast"><span style="position: absolute; margin: 5px 5px 5px 5px; font-size: 10pt; 
                           cursor: pointer; font-family: Helvetica; font-weight: bold; " onclick="newBoard(event)">New</span></div>
</div>
</div>

<div id="chessboard" class="chessboard"></div> 

<div id="chessheader" class="chessheader">
 <div style="position:absolute; top: 0px; left: 0px;" ><button onclick="collapseTools(this)" id="collapseid" class="tooltip"
      style="font-size: 12pt; border: 0px; margin: 2px 2px 2px 2px" alt="Tooltips" title="Tooltips">&#8801</button></div>
 <div style="position:absolute; top: 2px; left: 35px;">
    <span id="blackrnd" class="playerrnd"></span>
    <span id="bplayer" class="playerside">Home Player</span>
    <span id="blackelo" class="playerelo">(1800)</span>
</div>
 <div style="position:absolute; top: 0px; right: 75px;"><span id="bcapture" class="playercapture">&#9813; &#9814; &#9815; &#9816; &#9817;</span></div>
 <div style="position:absolute; top: 2px; right: 10px;"><span id="btimer" class="playertimer">1:00:00</span></div>
</div>

<div id="chessfooter" class="chessfooter">
 <div style="position:absolute; top: -2px; left: 5px;" ><span class="sidetomove" id="sidetomoveid" >&#9679;</span> </div>
 <div style="position:absolute; top: 2px; left: 35px;">
    <span id="whiternd" class="playerrnd"></span>
    <span id="wplayer" class="playerside">Guest Player</span>
    <span id="whiteelo" class="playerelo">(1700)</span>
  </div>
 <div style="position:absolute; top: 0px; right: 75px;"><span id="wcapture" class="playercapture">&#9819; &#9820; &#9821; &#9822; &#9823;</span></div>
 <div style="position:absolute; top: 2px; right: 10px;"><span id="wtimer" class="playertimer">1:00:00</span></div>
</div>

<div id="chessside0" class="chessside0"> 
      <div class="chessrate" id="chessrate"></div> 
</div>

<div id="chessside1" class="chessside1" style="visibility: hidden">
      <div id="chesstitle" class="chesstitle"">
         <div style="position: absolute; margin: 5px 5px 5px 5px">
         <span id="currentgameid" class="player" style="cursor: pointer" onclick="showGame(this)"></span>
         <span id="wplayertitle" class="playerside">Guest Player</span> - <span id="bplayertitle" class="playerside">Home Player</span>
         <span id="resultid" class="gresult">1/2-1/2</span> <br>
         <span style="font-weight: bold"></span> <span id="eventid" class="variation">Event</span> (<span id="dateid" class="player">Date</span>)<br>
         <span style="font-weight: bold"></span><span id="ecoid" class="player">ECO</span>: <span id="openingid" class="opening">Opening</span>
         <span style="font-weight: bold"></span> - <span id="variationid" class="variation">Variation</span><br>
         </div>
      </div>
       <div class="chessgame1">
          <div id="chessgame1" class="chessgame1" style="margin: 5px 5px 5px 5px; overflow-y:scroll; top: 0px"></div>
      </div>

      <div id="playitid1" style="position: absolute; bottom: 36px; left: 0px; width: 85px; height: 18px;
            visibility: visible; margin: 0px 0px 0px 7px ">
          <div  style="position: absolute;   width: 100%; height: 100%; background-color: #dedede; border: 3px solid #dedede">
             <span class="chessplaybtn" onclick="resetGame()" style="top: 0px; left: 5px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; color: #808080; font-size: 10pt">&#x258E;</span>
             <span style="position:absolute; display: block; top: 0px; left: 2px; color: #808080; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="backwardPlay()" style="top: 0px; left: 25px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; color: #808080; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="forwardPlay()" style="top: 0px; left: 45px">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px; color: #808080; font-size: 10.5pt">&#9654;</span>
             </span>
             <span class="chessplaybtn" onclick="endGame()" style="top: 0px; left: 65px">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px; color: #808080; font-size: 10.5pt">&#9654;</span>
             <span style="position:absolute; display: block; top: 0px; left: 12px; color: #808080; font-size: 10pt">&#x258E;</span>
             </span>
           </div>
     </div>


     <div style="position: absolute; margin: 5px 5px 5px 5px; bottom: 20px"/>
      <div style="position:absolute; top: 0px; left: 0px;" ><button onclick="newGame()" id="newgameid" style="font-size: 12pt; border: 0px" alt="New Game" title="New Game">n</button></div>
      <div style="position:absolute; top: 0px; left: 29px;" ><button onclick="resignGame()" id="resignid" style="font-size: 12pt; border: 0px" alt="Resign" title="Resign">r</button></div>
      <div style="position:absolute; top: 0px; left: 85px;" ><button onclick="machineChoice()" id="engineid" style="font-size: 12pt; border: 0px" alt="Play Engine" title="Play Engine">e</button></div>
      <div style="position:absolute; top: 0px; left: 110px;" ><button onclick="takeBack()" id="undoid" style="font-size: 12pt; border: 0px" alt="Takeback" title="Takeback">&#8592;</button></div>
      <div style="position:absolute; top: 0px; left: 140px;" ><button onclick="" id="choosecolorid" style="font-size: 12pt; border: 0px" alt="Board" title="Board">c</button></div>
      <div style="position:absolute; top: 0px; left: 170px;" ><button onclick="" id="choosesizeid" style="font-size: 12pt; border: 0px" alt="Board" title="Board">s</button></div>
      <div style="position:absolute; top: 0px; left: 200px;" ><button onclick=""  id="choosedatabaseid" style="font-size: 12pt; border: 0px" alt="Board" title="Board">d</button></div>
      <div style="position:absolute; top: 0px; left: 230px;" ><button onclick="" id="chooseanalyzeid" style="font-size: 12pt; border: 0px" alt="Board" title="Board">a</button></div>
      <div style="position:absolute; top: 0px; left: 260px;" ><button onclick="reverseBoard()"  alt="Reverse" title="Reverse">&#8634;</button></div>
      <div style="position:absolute; top: 0px; left: 290px;" ><button onclick="switchGame()" id="switchid" alt="Switch Game" title="Switch Game">g</button></div>
      <div style="position:absolute; top: 0px; left: 320px;" ><button onclick="" id="filterid" alt="Filter Game" title="Filter Game">f</button></div>
      <div style="position:absolute; top: 0px; left: 360px;" ><button onclick="repeatPlay()" id="repeatid" alt="Reverse" title="Reverse">&#9654;</button></div>
      <div style="position:absolute; top: 0px; left: 390px;"> <input type="text" value="25" id="limitmoveid" size=3 maxlength=3/></div>
      <div style="position:absolute; top: 0px; left: 425px;" ><button onclick="playAW()" id="musicid" alt="Reverse" title="Reverse">&#9632;</button></div>
      <div style="position:absolute; top: 0px; left: 450px;"> <input type="text" value="330.924" id="musictimeid" size=7 maxlength=6 onchange="MUSIC_TIME=this.value"/> </div>
      <div style="position:absolute; top: 0px; left: 650px; white-space: nowrap;"><span class="playertimer"> Total: </span><span id="totalid" class="playertimer">0</span></div>
      <div style="position:absolute; top: 0px; left: 750px; white-space: nowrap;"> <span class="playertimer"> Time: </span> <span id="timerid" class="playertimer">00:00</span>
      </div>
     </div>
 </div>

<div id="chessmoves" class="chessmoves">
      <div class="chessgame">
          <div id="chessgame" class="chessgame" style="margin: 5px 5px 5px 5px; overflow-y:scroll; top: 0px"></div>
      </div>
      <div id="playitid" class="chessmovesbtn">
          <div style="position: absolute;   width: 100%; height: 100%; background-color: #dedede; border: 3px solid #dedede">
             <span class="chessplaybtn" onclick="jumpToStart(this)" style="top: 0px; left: 5px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; color: #808080; font-size: 10pt">&#x258E;</span>
             <span style="position:absolute; display: block; top: 0px; left: 2px; color: #808080; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="backwardPlay(this)" style="top: 0px; left: 25px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; color: #808080; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="forwardPlay(this)" style="top: 0px; left: 45px">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px; color: #808080; font-size: 10.5pt">&#9654;</span>
             </span>
             <span class="chessplaybtn" onclick="jumpToEnd(this)" style="top: 0px; left: 65px">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px; color: #808080; font-size: 10.5pt">&#9654;</span>
             <span style="position:absolute; display: block; top: 0px; left: 12px; color: #808080; font-size: 10pt">&#x258E;</span>
             </span>
           </div>
     </div>
</div>

<div id="chesslisting" class="chesslisting" style="visibility: hidden; width: 860px; height: 280px; ">
 <div id="chesslistcv"  class="chesslistcv" ></div>
 <div id="chesslistor"  class="chesslistor" >
   <table><tr id="chesslisttrid" class="chesstr" style="border-collapse: collapse;">
   <td class="chesstdb" style=" width: 32px; border: 1px solid #3a3a3a"></td>
   <td class="chesstdb" style=" border: 1px solid #3a3a3a; font-size: 12pt">No</td>
   <td class="chesstdp" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 12pt; cursor: pointer" onclick="orderWhite(this)">White</td>
   <td class="chesstdl" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 10pt; cursor: pointer" onclick="orderWhiteElo(this)">ELO</td>
   <td class="chesstdp" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 12pt; cursor: pointer" onclick="orderBlack(this)">Black</td>
   <td class="chesstdl" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 10pt; cursor: pointer" onclick="orderBlackElo(this)">ELO</td>
   <td class="chesstdr" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 12pt; cursor: pointer" onclick="orderResult(this)">Result</td>
   <td class="chesstce" style="font-size: 12pt;  border: 1px solid #3a3a3a" >ECO</td>
   <td class="chesstde" style="font-size: 12pt;  border: 1px solid #3a3a3a; white-space; nowrap">Event</td>
   <td class="chesstdb" style="white-space: nowrap;  border: 1px solid #3a3a3a; font-size: 12pt; cursor: pointer" onclick="orderCount(this)">Cnt</td>
  </tr></table>
</div>
 <div id="chesslistid"  class="chesslistid" ><table class="chesstableid" id="chesstableid"></table> </div>
</div>


<div id="messagedivid"  style="position: absolute; top: 0px; left: 0px; width: 240px; height: 250px; visibility: hidden; border-radius: 10px; 
        box-shadow: 4px 4px 4px 4px rgb(50, 50, 50, 0.5);
        border: 3px solid #787060; background-color: #FBF5ED; margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15000;">
 <div id="messageid" class="messageid" style="width: 240px; height: 250px;">
 </div>
 <span  style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer;
             border: 0px solid #ababab; position: absolute; top: 12px; left: 237px" onclick="closeMessage(this.parentNode)" >&#x2715</span>
</div>

<div id="signupdivid"  style="position: absolute; top: 200px; left: 300px; width: 440px; height: 250px; visibility: visible; border-radius: 10px;
        box-shadow: 4px 4px 4px 4px rgb(50, 50, 50, 0.5);
        border: 3px solid #787060; background-color: #FBF5ED; margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15000;">
<div id="signupid" class="messageid" style="width: 440px; height: 250px;">
     <span class="defaultspn" style="top: 30px; left: 74px">Username</span><input type="text" class="inputclass" style="top: 30px; left: 180px" id="su_usernameid" />
     <span class="defaultspn" style="top: 60px; left: 69px">First Name</span><input type="text" class="inputclass" style="top: 60px; left: 180px" id="su_firstnameid" />
     <span class="defaultspn" style="top: 90px; left: 71px">Last Name</span><input type="text" class="inputclass" style="top: 90px; left: 180px" id="su_lastnameid" />
     <span class="defaultspn" style="top: 120px; left: 40px">Email Address</span><input type="text" class="inputclass" style="top: 120px; left: 180px" id="su_emailid" />
     <span class="defaultspn" style="top: 150px; left: 75px">Password</span><input type="text" class="inputclass" style="top: 150px; left: 180px" id="su_passwdid" />
     <button class="defaultbtn" style="top: 190px; left: 20px; width: 400px; height: 45px; border: 0px" onclick=">Sign Up</button>
</div>
 <span  style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer;
             border: 0px solid #ababab; position: absolute; top: 12px; left: 437px" onclick="closeMessage(this.parentNode)" >&#x2715</span>
</div>

<div id="logindivid"  style="position: absolute; top: 600px; left: 300px; width: 440px; height: 160px; visibility: visible; border-radius: 10px;
        box-shadow: 4px 4px 4px 4px rgb(50, 50, 50, 0.5);
        border: 3px solid #787060; background-color: #FBF5ED; margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15000;">
<div id="loginid" class="messageid" style="width: 440px; height: 160px;">
     <span class="defaultspn" style="top: 30px; left: 74px">Username</span><input type="text" class="inputclass" style="top: 30px; left: 180px" id="si_usernameid" />
     <span class="defaultspn" style="top: 60px; left: 75px">Password</span><input type="text" class="inputclass" style="top: 60px; left: 180px" id="si_passwdid" />
     <button class="defaultbtn" style="top: 100px; left: 20px; width: 400px; height: 45px; border: 0px" >Login</button>
</div>
 <span  style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer;
             border: 0px solid #ababab; position: absolute; top: 12px; left: 437px" onclick="closeMessage(this.parentNode)" >&#x2715</span>
</div>


<div id="machineid" style="visibility: hidden;  margin: 0px 0px 0px 0px; z-index: 50;">
 <div style="position: absolute; top: 40px; left: 50px; width: 420px; height: 100px;
        border: 3px solid #000000; background-color: #DEDEDE; margin: 0px 0px 0px 0px; z-index: 30;">
    <div style="position: absolute; top: 10px; left: 25px; width: 400px; z-index: 25" id="blackpromotionid">
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 50px; position: absolute; top: 0px; left: 0">&#9818;</span>
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 12pt; padding: 2px; position: absolute; top: 11px; left: 65px">
           <input class="engineclass" type="radio" name="blackplayer" id="blackplayerid" value="human" checked />Human<br>
           <input class="engineclass" type="radio" name="blackplayer" id="blackplayerid" value="machine" />Machine
         </span>
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 50px; position: absolute; top: 0px; left: 200px">&#9812;</span>
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 12pt; padding: 2px; position: absolute; top: 11px; left: 265px">
           <input class="engineclass" type="radio" name="whiteplayer" id="whiteplayerid" value="human" checked />Human<br>
           <input class="engineclass" type="radio" name="whiteplayer" id="whiteplayerid" value="machine"/>Machine
         </span>
    </div>
    <span class="engineclass" id="engineid" style="cursor: pointer; z-index: 20; color: #8a8a8a; font-weight: bold; font-size: 10pt; cursor: pointer;
             border: 0px solid #ababab; position: absolute; top: 0px; left: 402px">&#x2715</span>
 </div>
</div>

<div id="setpositionid"  style="position: absolute; width: 40px; height: 500px; visibility: hidden; border-radius: 0px 10px 10px 0px;
        border: 0px 3px 3px 3px solid #787060; background-color: #FBF5ED; margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15000;">
 <div id="pieceid" class="pieceid" style="width: 40px; height: 500px;"> </div>
</div>

<div id="promoteid" style="position: absolute; visibility: hidden;  margin: 0px 0px 0px 0px; top: 100px; left: 100px">
 <div style="position: absolute; top: 0px; left: 0px; width: 300px; height: 100px; 
        border: 3px solid #000000; background-color: #DEDEDE; margin: 0px 0px 0px 0px; z-index: 10;">
    <div class="promocontain" id="blackpromotionid" > 
         <span id='Q' class="promoclass">&#9819;</span>
         <span id='R' class="promoclass">&#9820;</span>
         <span id='B' class="promoclass">&#9821;</span>
         <span id='N' class="promoclass">&#9822;</span>
    </div>
    <div class="promocontain" id="whitepromotionid">
         <span id='Q' class="promoclass">&#9813;</span>
         <span id='R' class="promoclass">&#9814;</span>
         <span id='B' class="promoclass">&#9815;</span>
         <span id='N' class="promoclass">&#9816;</span>
    </div>
 </div>
</div>

<div id="tooltipsid" style="visibility: hidden; position: absolute; top: 25px; left: 0px; width: 250px; height: 50px; 
                background-color: #DEDEDE; border: 1px solid #808080; z-index: 15000; white-space: nowrap;">
  <div style="margin: 10px 10px 10px 10px">
   Profiles/Login (coming soon)!
  </div>
</div>

<div id="popfilterid" class="popfilter"> 
 <div style="margin: 5px 5px 5px 5px">
<br>
White elo:
<select id="filter_welo_ops">
<option>=</option>
<option selected>>=</option>
<option><=</option>
<option>not =</option>
</select>
<input value="1500" placeholder="1500" maxlength="4" size="4" type="text" id="filter_welo" />
Black elo:
<select id="filter_belo_ops">
<option>=</option>
<option selected>>=</option>
<option><=</option>
<option>not =</option>
</select>
<input value="1500" placeholder="1500" maxlength="4" size="4" type="text" id="filter_belo" />
Moves:
<select id="filter_moves_ops">
<option>=</option>
<option selected>>=</option>
<option><=</option>
<option>not =</option>
</select>
<input value="5" placeholder="5" maxlength="3" size="3" type="text" id="filter_moves" /><br>
Result:<br>
<input type="checkbox" id="filter_res1" value="1-0" checked>1-0
<input type="checkbox" id="filter_res2" value="0-1" checked>0-1
<input type="checkbox" id="filter_res3" value="1/2-1/2" checked>1/2-1/2
</div>
</div>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pegjs/0.9.0/peg.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript">

    var RMOO_PIECES_   = true;
    var HDR_FTR_HSIZE = 25;
    var BOARDSIZE_ =  840;
    var BOARDOFFSET_ = 0;
    var PIECESIZE_ = 0;
    const bINITFEN_ = "RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbkqbnr w KQkq - 0 1";
    const wINITFEN_ = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQKq - 0 1";
    // var   _REPEAT_DRAW_ = initRepeatDraw();
    var   _NO_POSSIBLE_MOVES_ = false;
    var   _POSSIBLE_STALE_MATE_ = false;
    var   _POSSIBLE_CHECK_MATE_ = false;
    var   _CHECK_MATE_ = false;
    var   _STALE_MATE_ = false;
    var   CHESSGAME_   = null;
    const HUMAN        = "human";
    const MACHINE      = "machine";
    const WHITE        =  97;
    const BLACK        =  98;
    const UNMOVE       = 100;
    const GOODMOVE     = 101;
    const ENPASSANT    = 102;
    const EATPIECE     = 103;
    const CASTLESHORT  = 104;
    const CASTLELONG   = 105;
    const TIMER_BULLET_ = 1200; // ( 1000 ms * 60 sec * 1 min ) / 50 ms callback 
    const TIMER_BLITZ_ = 3600;  // ( 1000 ms * 60 sec * 3 min ) / 50 ms callback 
    const TIMER_RAPID_ = 12000; // ( 1000 ms * 60 sec * 10 min ) / 50 ms callback
    const TIMER_CLASSIC_ = 60000; // ( 1000 ms * 60 sec * 50 min ) / 50 ms callback (should be able to play 40 moves in 50 min.
    const horiz = [ "a", "b", "c", "d", "e", "f", "g", "h" ];
    const chessdiv   = document.getElementById("chessdiv");
    const sidepanel  = document.getElementById("sidepanel");
    const cubicle  = document.getElementById("cubicleid");
    const chessboard = document.getElementById("chessboard");
    const chessgame = document.getElementById("chessgame");
    const chessgame1 = document.getElementById("chessgame1");
    const chessheader = document.getElementById("chessheader");
    const chessfooter = document.getElementById("chessfooter");
    const chessmoves = document.getElementById("chessmoves");
    const moveid = document.getElementById("moveid");
    const chessrate = document.getElementById("chessrate");
    const chessside0 = document.getElementById("chessside0");
    const engineid = document.getElementById("engineid");
    const whitepromotionid = document.getElementById("whitepromotionid");
    const blackpromotionid = document.getElementById("blackpromotionid");
    const btimer = document.getElementById("btimer");
    const wtimer = document.getElementById("wtimer");

    // populate header
    // const machineid = document.getElementById("machineid");
    // const whiteplayerid = document.getElementById("whiteplayerid");
    // const blackplayerid = document.getElementById("blackplayerid");
    // const wplayer = document.getElementById("wplayer");
    // const bplayer = document.getElementById("bplayer");
    // const wplayertitle = document.getElementById("wplayertitle");
    // const bplayertitle = document.getElementById("bplayertitle");
   // const welo    = document.getElementById("whiteelo");
   // const belo    = document.getElementById("blackelo");
   // const eventid = document.getElementById("eventid");
   // const dateid  = document.getElementById("dateid");
   // const resid   = document.getElementById("resultid");

    // opening header
   // const ecoid   = document.getElementById("ecoid");
   // const openingid   = document.getElementById("openingid");
   // const variationid   = document.getElementById("variationid");

    // chesslisting
    const chessls = document.getElementById('chesslisting');
    const chessid = document.getElementById('chesslistid');
    const chesscv = document.getElementById('chesslistcv');
    const chessor = document.getElementById('chesslisttrid');
    const condiv = document.getElementById('playcontrolid');

    // setposition
    const setpositionid = document.getElementById('setpositionid');

    // message window
    const messagedivid = document.getElementById('messagedivid');

    // promotion template
    const promoteid = document.getElementById("promoteid")


    // Controlling window display
    var ZINDEX_ = 50;

    const BOARDCOLOR_ = { "Green" :      { sd: '#a7b093', dt: '#669104', lt: '#e9efdc', hdt: '#467104', hlt: '#b9bfac' },
                         "Brown" :       { sd: '#a19686', dt: '#c79361', lt: '#fbf2e9', hdt: '#a77341', hlt: '#cbc2b9' },
                         "New Brown" :   { sd: '#a19686', dt: '#a47a4f', lt: '#e5d8cc', hdt: '#845a2f', hlt: '#b5a89c' },
                         "Grey" :        { sd: '#aaa7b5', dt: '#929195', lt: '#ebeaed', hdt: '#727175', hlt: '#bbbabd' },
                         "Purple" :      { sd: '#ae9ba3', dt: '#bf819e', lt: '#faf4f7', hdt: '#9f617e', hlt: '#cac4c7' },
                         "Cyan" :        { sd: '#81b4ad', dt: '#50938a', lt: '#ebfcfa', hdt: '#30736a', hlt: '#bbdcda' },
                         "Dark Blue" :   { sd: '#7c939c', dt: '#418196', lt: '#eaf8fd', hdt: '#216176', hlt: '#bac8cd' },
                         "Dark Brown" :  { sd: '#ac7b6d', dt: '#915444', lt: '#e5c6bd', hdt: '#713424', hlt: '#b5969d' },
                         "Dark Red" :    { sd: '#b5787f', dt: '#97585f', lt: '#e8cdd0', hdt: '#75383f', hlt: '#b89da0' },
                         "Light Green" : { sd: '#a0ab89', dt: '#64835b', lt: '#e9efdc', hdt: '#44633b', hlt: '#b9bfac' },
                         "Light Blue" :  { sd: '#9fbcdc', dt: '#6b86a4', lt: '#e3e9ef', hdt: '#4b6684', hlt: '#b3b9bf' }
                       };

    // Game status
    STATUS = { DONE: 1100, RESIGN: 1200, NEW: 1300, PLAYING: 1400, INIT: 1500, INTERRUPTED: 1600, STOPPED: 1700, ILLEGAL: 1800, HALTED: 1900, SET: 2000 }
    GAMEOVER = { CHECKMATE: 1100, STALEMATE: 1200, ABANDONED: 1300, TIMEOUT: 1400, REPETITION: 1500, DRAWACCEPTED: 1600, RESIGNED: 1700, INSUFFICIENT: 1800 }

    // const INIT_BTIMER_ = { last_time: 0, watch: '00:00:00', timer: null, int_timer: 0, elapsed: 0},
    //      INIT_WTIMER_ = { last_time: 0, watch: '00:00:00', timer: null, int_timer: 0, elapsed: 0 };

    // Engine Move
    var ENGINEMOVE_ = null;

    // Engine commands
    _UCI_ = 'uci';
    _ISREADY_ = 'isready';  // set engine options prior to readiness
    _GO_ = 'go';  // after ucinewgame and position

    // styleSheets
    const sheet = document.styleSheets[0]

    // log
    function log(msg) { console.log(msg); } 

    function message(this_, msg, err = true, stick = false) {
        var msgwin = this_.tbox.msgwin_;
        int_message = 0;
        msgwin.style.visibility = 'visible';
        //func(this_.tbox.msgid_, "Good");
        if (!stick) msgtime = setTimeout(showMessage, 1000, msgwin);
        if (err) throw "Error.";
    }

    function showMessage(msgwin) {
       msgwin.style.visibility = 'hidden';
       while(msgwin.lastChild) { 
          msgwin.removeChild(msgwin.lastChild); 
       }
    }

    function closeMessage(this_) {
      this_.style.visibility = 'hidden';
    }

    function pageSize() {
        var w = window.innerWidth;
        var h = window.innerHeight;

        if (!w) {
             w = document.documentElement.clientWidth;
             h = document.documentElement.clientHeight;
             if (!w) {
                 w = document.body.clientWidth;
                 h = document.body.clientHeight;
             }
        }
        return {width: w, height: h};
    }

    // popups
    function mousehover(e) { e.preventDefault(); this.style.backgroundColor = "#A6C39E"; }
    function mousehout(e) { e.preventDefault(); this.style.backgroundColor = this.bcolor_; }
    function mousehdown(e) { e.preventDefault(); this.style.backgroundColor = "#8f8f8f"; }
    function mousehup(e) { e.preventDefault(); this.style.backgroundColor = "#A6C39E"; }

    function leavePopup(e) {
       if (this.className.match('popupdiv')) {
         this.style.visibility = 'hidden';
       }
    }

    function addPopupSpan(this_, func, width, item) {
        var s = document.createElement('span');
        s.className = 'popspan';
        s.style.width = width ;
        s.style.color = '#4A4A4A';
        s.addEventListener("mouseover", mousehover, true);
        s.addEventListener("mouseout", mousehout, true);
        s.addEventListener("mousedown", mousehdown, true);
        s.addEventListener("mouseup", mousehup, true);
        s.onclick = func;
        s.game_ = this_;
        if (item.nm != null) {
            s.innerHTML = item.lab; ;
            s.value_ = item.nm;
        } else {
            s.innerHTML = item;
            s.value_ = item ;
        }
        return s;
    }

    function createPopup(id, this_, top, left, width, height, list = null, func = null) {
      if (list != null) {
        var d1 = document.createElement('div');
        var d2 = document.createElement('div');
        var d3 = document.createElement('div');
        var dark = '#D7E6D3', light = '#E6F1E3';
        d1.className = "popupdiv";
        d2.className = "popup";
        d3.className = "popup";
        d3.style = "margin: 5px 5px 5px 5px; overflow-y:scroll";
        d1.style.top = top + 'px'; 
        d1.style.left = left + 'px'; 
        d1.style.width = width + 'px'; 
        d1.style.height = height + 'px'; 
        d1.style.zIndex = 15000;
        d1.appendChild(d2);  
        d2.appendChild(d3);  
        this_.container_.appendChild(d1);
        for (p in list) { 
           const item = list[p];
           var s = addPopupSpan(this_, func, width + 'px', item);
           s.style.backgroundColor = (parseInt(p) % 2) ? light : dark;
           s.bcolor_ = (parseInt(p) % 2) ? light : dark;
           d3.appendChild(s);
        }
        d1.id = id;
        d3.id = 'pop_' + id;
        d1.addEventListener('mouseleave', leavePopup, false);
      }
    }


    function padTime(elapsed) {
       var s = ~~(elapsed / 1000); 
       var m = ~~(s / 60);
       var h = ~~(m / 60);
       m = m % 60; 
       s = s % 60 ; 
       var t = ("00" + s).slice(-2); 
       if (h == 0) t = m + ':' + t; else t = ("00" + m).slice(-2) + t; 
       if (h > 0) t = h + ':' + t; 
       return t;
    }

    function typeTimer() {
      if (PLAYCNT_ == TIMER_BULLET_) { return '1:00'; }
      if (PLAYCNT_ == TIMER_BLITZ_) { return '3:00'; }
      if (PLAYCNT_ == TIMER_RAPID_) { return '10:00'; }
      if (PLAYCNT_ == TIMER_CLASSIC_) { return '50:00'; }
      return '00:00:00';
    }

    function stopTimer() {
        if (PTIMER_ != null) { clearInterval(PTIMER_); PTIMER_ = null }
    }

    function initTimer(side_) {
      stopTimer();
      if (side_ == WHITE) {
          WTIMER_.last_time = 0;
          WTIMER_.watch = typeTimer();
          WTIMER_.timer = null;
          WTIMER_.int_timer = 0;
          WTIMER_.elapsed = 0;
          WTIMER_.watch = padTime(PLAYTIME_)
          wtimer.innerHTML = WTIMER_.watch;
      } else {
          BTIMER_.last_time = 0;
          BTIMER_.watch = typeTimer();
          BTIMER_.timer = null;
          BTIMER_.int_timer = 0;
          BTIMER_.elapsed = 0;
          BTIMER_.watch = padTime(PLAYTIME_)
          btimer.innerHTML = BTIMER_.watch;
      }
    }


    // Remove - obsoleted  (Board Selection) 
    var imageboard_ = [
                       { lab: 'Dark Brown', nm: 'darkbrown' }, { lab: 'Dark Red',    nm: 'darkred' },
                       { lab: 'Dark Blue',  nm: 'darkblue' },  { lab: 'Light Green', nm: 'lightgreen' },
                       { lab: 'Dark Green', nm: 'darkgreen' }, { lab: 'Green',       nm: 'green' },
                       { lab: 'Brown',      nm: 'brown' },     { lab: 'Blue',        nm: 'blue' },
                       { lab: 'Grey',       nm: 'grey' },      { lab: 'Cyan',        nm: 'cyan' },
                       { lab: 'Purple',     nm: 'purple' } ];


    function chooseBoardColor(this_, pos) {
      var id = 'choosecolorid_' + this_.id;
      const elem = document.getElementById(id);
      const colors = [];
      for (var p in BOARDCOLOR_) { colors.push(p); }
       if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
            return 
       }
      createPopup(id, this_, top = pos.y, left =  pos.x + 6, width = 200, height = 200, colors, this_.changeBoardColor );
    }


    function chooseAnalyze(this_, pos) {
       var id = 'chooseanalyzeid_' + this_.id;
       const elem = document.getElementById(id);
       if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
           return 
       }
       const fens = ["K7/8/3R4/4k3/8/8/8/8 b - - 0 1",
        "3qk3/5p2/8/8/8/8/8/3QK3 w KQkq - 0 1",
        "rnbqk1nr/ppp2ppp/8/4b3/2p5/2N1P3/PP3PPP/N1BQKBNR w KQkq - 0 1",
        "8/8/8/1B6/8/1k6/8/1K6 b - - 0 1",
        "8/R7/6kp/4b1p1/8/8/5PK1/8 w - - 0 1",
        "2kr4/ppp5/8/6p1/3Pp1q1/2B5/PP6/R3RK2 b - - 0 1",
        "2kr4/ppp5/8/6p1/3Pp1q1/2B5/PP6/R1K2R2 b - - 0 1",
        "1q4r1/p3pk1P/2p1bp2/2Bp3p/N1P1n3/1P1P1N2/P2Q1P2/2R3K1 w - - 0 1",
        "r1bqkbnr/ppp2ppp/2np4/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 0 1",
  	"8/8/4K3/4R3/8/4Pk2/7Q/8 w - - 0 1",
  	"8/8/8/1k7/8/1b7/8/4K2R b KQkq - 0 1",
  	"5n2/6P2/8/8/5K2/7k/8/8 w - - 0 1",
  	"5N2/6p2/8/8/5k2/8/8/7K b - - 0 1",
  	"rn2kb1r/ppp1qppp/4bn2/3p4/3P4/1PP2N2/P3BPPP/RNBQ1RK1 w Kq - 0 1",
  	"r1bqkb1r/pp2pp2/2np1n1p/2p3p1/4P3/P2P1N2/1PP1BPPP/RNBQ1RK1 w Kq - 0 1",
  	"r1b1k2r/pp3p2/2np1q2/8/1P1bP1pp/P2Q4/4BPPP/1RB2RK1 w kq - 0 1",
  	"r2qkb1r/pp2nppp/3p4/2pNN1B1/2BnP3/3P4/PPP2PPP/R2bK2R w KQkq - 0 1",
  	"8/8/7K/8/5k2/8/6p2/8 b - - 0 1",
  	"RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbkqbnr w KQkq - 0 1",
  	"RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rPbkqbnr w KQkq - 0 1",
  	"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQKq - 0 1",
  	"rnbqkb1r/ppp1pppp/3p1n2/8/4P3/5N2/PPPPBPPP/RNBQK2R b KQKq - 0 1",
  	"4n3/5P2/8/8/K7/7k/8/8 w - - 0 1",
  	"8/8/8/8/k7/7K/4p3/8 b - - 0 1",
  	"1nb5/8/8/8/3K4/k7/8/8 w - - 0 1",
  	"k7/8/2K5/8/8/8/8/8 w - - 0 1",
  	"4k3/8/8/8/8/8/8/4K3 w - - 0 1",
  	"1nb5/8/8/2k6/8/4K3/8/8 w - - 0 1"];
        createPopup(id, this_, top = pos.y, left =  pos.x + 6, width = 600, height = 200, fens, this_.analyzePosition );
    }

    function chooseDatabase(this_,pos) {
      var id = 'choosedatabaseid_' + this_.id;
      const elem = document.getElementById(id);
      if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
           return 
      }
       const dbs = [
        { nm: "broken", lab: "broken.pgn" },
        { nm: "broken1", lab: "broken1.pgn" },
        { nm: "broken2", lab: "broken2.pgn" },
        { nm: "broken3", lab: "broken3.pgn" },
        { nm: "broken4", lab: "broken4.pgn" },
        { nm: "broken5", lab: "broken5.pgn" },
        { nm: "demo2", lab: "demo2.pgn" },
        { nm: "demo4", lab: "demo4.pgn" },
        { nm: "demo5", lab: "demo5.pgn" },
        { nm: "demo10", lab: "demo10.pgn" },
        { nm: "demo11", lab: "demo11.pgn" },
        { nm: "mygames", lab: "mygames.pgn" },
        { nm: "alek", lab: "Alek" },
        { nm: "AlekhineExchange", lab: "Alekhine Exchange" },
        { nm: "Alekhine2Nc3-d5", lab: "Alekhine (2.Nc3 d5)" },
        { nm: "BenkoGambit", lab: "Benko Gambit" },
        { nm: "CatalanClosed", lab: "Catalan Closed" },
        { nm: "CatalanOpen", lab: "Catalan Open" },
        { nm: "FrenchAdvance", lab: "French Advance" },
        { nm: "FrenchExachange", lab: "French Exchange" },
        { nm: "FrenchRubinstein", lab: "French Rubinstein" },
        { nm: "FrTarrasch3c5", lab: "French Tarrasch (3.c5)" },
        { nm: "FrTarrasch3Nf6", lab: "French Tarrasch (3.Nf6)" },
        { nm: "FrTarraschOther3", lab: "French Tarrasch (3.Other)" },
        { nm: "FrWinawerMain", lab: "French Winawer (Main)" },
        { nm: "GiuocoPiano", lab: "Giuoco Piano" },
        { nm: "KIDClassical", lab: "King's Indian (Classic)" },
        { nm: "KIDFianchetto", lab: "King's Indian (Fianchetto)" },
        { nm: "KIDSaemisch", lab: "King's Indian (Saemisch)" },
        { nm: "KIDPetrosian", lab: "King's Indian (Petrosian)" },
        { nm: "QID4a3", lab: "Queen's Indian (4.a3)" },
        { nm: "QID4e3", lab: "Queen's Indian (4.e3)" },
        { nm: "QID4g3-Ba6", lab: "Queen's Indian (4.g3 Ba6)" },
        { nm: "QID4Nc3", lab: "Queen's Indian (4.Nc3)" },
        { nm: "RuyLopezBerlin", lab: "Ruy Lopez (Berlin)" },
        { nm: "RuyLopezBreyer", lab: "Ruy Lopez (Breyer)" },
        { nm: "RuyLopezChigorin", lab: "Ruy Lopez (Chigorin)" },
        { nm: "RuyLopezMarshall", lab: "Ruy Lopez (Marshall)" },
        { nm: "RuyLopezAntiMarshall", lab: "Ruy Lopez (AntiMarshall)" },
        { nm: "PetroffMain", lab: "Petroff Main" },
        { nm: "PetroffOther3", lab: "Petroff Other 3." },
        { nm: "Scotch4Bc5", lab: "Scotch (4.Bc5)" },
        { nm: "Scotch4Nf6", lab: "Scotch (4.Nf6)" },
        { nm: "SicilianAlapin2Nf6", lab: "Sicilian Alapin (2.Nf6)" },
        { nm: "SicilianAlapin2d5", lab: "Sicilian Alapin (2.d5)" },
        { nm: "SicilianLowenthal", lab: "Sicilian Lowenthal" },
        { nm: "SicilianNajdorf6f3", lab: "Sicilian Najdorf (f6 f3)" },
        { nm: "SicilianNajdorf6f4", lab: "Sicilian Najdorf (f6 f4)" },
        { nm: "SicilianNajdorf6Bg5", lab: "Sicilian Najdorf (f6 Bg5)" },
        { nm: "SicilianNajdorf6Be3", lab: "Sicilian Najdorf (f6 Be3)" },
        { nm: "SicilianNajdorf6Be2", lab: "Sicilian Najdorf (f6 Be2)" },
        { nm: "SicilianNajdorf6Bc4", lab: "Sicilian Najdorf (f6 Bc4)" },
        { nm: "SicilianRossolimo", lab: "Sicilian Rossolimo" },
        { nm: "SicilianScheveningen", lab: "Sicilian Scheveningen" },
        { nm: "SicilianSveshnikov", lab: "Sicilian Sveshnikov" },
        { nm: "SicilianTaimanov5Nb5", lab: "Sicilian Talmanov (5.Nb5)" },
        { nm: "SicilianTaimanovMain", lab: "Sicilian Talmanov (Main)" } ];
         createPopup(id, this_, top = pos.y, left = pos.x + 6, width = 240, height = 200, dbs, this_.changeDatabase );
    }

    function collapseTools(tool) {
      var this_ = tool.game_;
      if (this_ != null && this_.control_ != null) {
          const vis = this_.control_.style.visibility;
          this_.control_.style.visibility = (vis == 'visible') ? 'hidden' : 'visible';
      }
    }

    // Reverse Board
    var reverse_ =  { a:"h", b:"g", c:"f", d:"e", e:"d", f:"c", g:"b", h:"a",
                      1:8, 2:7, 3:6, 4:5, 5:4, 6:3, 7:2, 8:1 }
    function reverseLoc(location, reversed = true) {  /** Generic **/
        if (reversed) {
           return reverse_[location[0]] + reverse_[location[1]];
        } else {
           return location
        }
    }


    function illegal_move(msg) { throw {msg: msg, cause: "illegal move"}; }

    const SOURCE_HIST_ = []
    function emptySource() { 
          while (SOURCE_HIST_.length) SOURCE_HIST_.pop(); 
          source_.style.visibility = 'hidden';
          destination_.style.visibility = 'hidden';
     }

    var SIDETOMOVE_ = WHITE, MOVECOUNT_ = 0;
    var sidetoid = document.getElementById("sidetomoveid");

    function searchGame() {
        return ecoGame_.join(' ');
    }

    
    /* Remove obsolete */
    function infoHeader(game) {
        // populate header
         eventid.innerHTML = game.ev + " (" + game.si + ")";
         dateid.innerHTML = game.dt;
         if (!REVERSE) {
            wplayer.innerHTML = game.wp; bplayer.innerHTML = game.bp;
            wplayertitle.innerHTML = game.wp; bplayertitle.innerHTML = game.bp;
            welo.innerHTML = "(" + game.we + ")";
            belo.innerHTML = "(" + game.be + ")";
         } else {
            wplayer.innerHTML = game.bp; bplayer.innerHTML = game.wp;
            wplayertitle.innerHTML = game.bp; bplayertitle.innerHTML = game.wp;
            welo.innerHTML = "(" + game.be + ")";
            belo.innerHTML = "(" + game.we + ")";
         }
         resid.innerHTML = game.rt;
         ecoid.innerHTML       = game.eco;
         openingid.innerHTML   = game.opening;
         variationid.innerHTML = game.variation.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, '');
    }

    /* Remove - obsolete
    function initHeader(resign = false, draw = false, rating = false) {
        const game = {}
        game.wp = (WPLAYER_ == HUMAN) ? "Human (Me)" : "Stockfish 15"
        game.bp = (BPLAYER_ == HUMAN) ? "Human (Me)" : "Stockfish 15"
        if (WPLAYER_ == HUMAN && BPLAYER_ == HUMAN) {
             game.wp =  "Home Player"; game.bp = "Guest Player";
             game.ev = "Human vs Human";
        } else
        if (WPLAYER_ == MACHINE && BPLAYER_ == MACHINE) {
             game.ev = "Machine vs Machine";
        } else {
             game.ev = "Human vs Machine";
        }
        game.we = String((WPLAYER_ == HUMAN) ? 1800 : 2800);
        game.be = String((BPLAYER_ == HUMAN) ? 1800 : 2800);
        game.dt = new Date(Date.now()).toLocaleString();
        game.eco = 'ECO'; game.opening = 'Opening'; game.variation = 'Variation';
        game.si = "Home";
        game.win = null;
        if (!rating) { game.rt = ""; } else {
          if (resign) {
             game.rt = (REVERSE) ? "1-0" : "0-1";
             game.win = (REVERSE) ? "WHITE" : "BLACK";
          } else {
             game.rt = (SIDETOMOVE_ == WHITE) ? "0-1" : "1-0";
             game.win = (SIDETOMOVE_ == WHITE) ? "BLACK" : "WHITE";
          }
          if (draw) { game.rt = "1/2-1/2"; game.win = "DRAW"}
        }
        return game;
    }

   /* Remove */
    function initRepeatDraw() { 
         return  { wmove: [], bmove: [], fen: [] }
    }

    /* Remove - obsolete */
    function initGame(newgame, analyzegame) {
        MOVECOUNT_ = 0; SIDETOMOVE_ = WHITE; 
        RESIGN_ = false; 
        NEWGAME_ = newgame; ANALYZEGAME_ = analyzegame; 
        FETCHEDGAME_ = false; 
        // DONEGAME_ = false; set this during the first move.
       _POSSIBLE_CHECK_MATE_ = false; _POSSIBLE_STALE_MATE_ = false; GAMEFEN_ = null;
       _CHECK_MATE_ = false; _STALE_MATE_ = false; _NO_POSSIBLE_MOVES_ = false; BOOKADDED_ = false;
       _REPEAT_DRAW_ = initRepeatDraw();

       const game = initHeader(false, false, false);
       infoHeader(game);

       // For playing
       MOVETRACKER_ = null;

       // Timer
       initTimer(WHITE);
       initTimer(BLACK);

       // Source
       emptySource();

       // empty bench;
       emptyBench();
    }


    var CHESSGAME_ = chessgame;
    const playitid = document.getElementById("playitid");
    const playitid1 = document.getElementById("playitid1");
    playitid.style.visibility = 'visible';
    playitid1.style.visibility = 'hidden';
    function switchGame() {
      if (!NEWGAME_) return;
       if (CHESSGAME_.id == 'chessgame') {
          CHESSGAME_ = chessgame1;
          playitid1.style.visibility = 'visible';
          playitid.style.visibility = 'hidden';
 
       } else {
          CHESSGAME_ = chessgame;
          playitid1.style.visibility = 'hidden';
          playitid.style.visibility = 'visible';
       }
    }

    const popfilterid = document.getElementById("popfilterid");
    const filterid = document.getElementById("filterid");
    filterid.addEventListener('mouseup', filterGameMU);
    filterid.addEventListener('mousedown', filterGameMD);
    popfilterid.addEventListener('mouseleave', filterGameLV, false);
    var FILTERPOP_ = false;
    function filterGame(pos) {
        FILTERPOP_ = (FILTERPOP_) ? false : true;
        if (FILTERPOP_) {
            popfilterid.style.visibility = 'visible';
            popfilterid.style.top = pos.y + 'px';
            popfilterid.style.left = pos.x + 'px';
        } else {
            popfilterid.style.visibility = 'hidden';
        } 
    }

    function filterGameLV(e) {
      if (this.className.match('popfilter')) {
         this.style.visibility = 'hidden';
         FILTERPOP_ = false;
       }
    }

    function filterGameMD(e) {
        e.preventDefault();
       this.targetchoose_ = true;
    }

    function filterGameMU(e) {
       if (this.targetchoose_) {
          var pos = eventOffset(e);
          filterGame(pos);
       }
    }

    function addFEN(fen) {
       const analyzeid = document.getElementById('pop_chooseanalyzeid_');
       var found_ = false;
       var next = analyzeid.firstChild, fen_, width = null, func = null;
       while (next) {
         fen_ = next.innerHTML;
         width = next.style.width;
         func = next.onclick;
         if (fen == fen_) { found_  = true; break }
         next = next.nextSibling;
       }
       if (!found_) {
          var s = addPopupSpan(func, width, fen);
          analyzeid.appendChild(s);
      }
    }

    function checkPositionLegality(this_, fen) {
       if (fen == null) fen =  generateFEN('w', enpassant = "-") 
       var fens_ = fen.split(' ');
       var initfen_ = fens_[0];
       var nside_ = fens_[1];
       var binitfen_ = bINITFEN_.split(' ')[0];
       var winitfen_ = wINITFEN_.split(' ')[0];
       var fen_ = initfen_.split('/');
       var cntP = initfen_.match(/[Pp]/g)
       var cntK = initfen_.match(/[K]/g)
       var cntk = initfen_.match(/[k]/g)
       var Kk  = initfen_.match(/Kk|kK/g)
       var un_ = initfen_.match(/[ACDEFGHIJLMOSTUVWXZY\.\!\#\$\%\^\&\*\(\)\_\-\+\=\[\{\]\}\;\'\:\"\<\>\>\<\?\\\~\`09]/ig)
       var my8thrank = fen_[0]; my1strank = fen_[7];
       var castl = fens_[2];
       if (fens_[2] == null) { message(this_, "Incorrect Notation."); return } 
       castl = castl.match(/^(KQkq|Qkq|KQk|Kkq|KQq|KQ|Kk|Kq|Qk|Qq|kq|Q|q|K|k|-)$/g);
       if (fen_.length != 8) message(this_, "invalid number of ranks");
       if (nside_ != 'w' && nside_ != 'b') message(this_, "Incorrect side option. Use (w or b).");
       if (castl == null) message(this_, "Invalid Castling options");
       if (un_ != null && un_.length > 0) message(this_, "Invalid Notation. Unknown characters found!");
       if (Kk != null && Kk.length > 0) message(this_, "Kings cannot be close to each other!");
       if (cntK != null && cntK.length != 1) message(this_, cntK.length + " White Kings not allowed!");
       if (cntk != null && cntk.length != 1) message(this_, cntk.length + " Black Kings not allowed!");
       if (cntK == null || cntk == null) message(this_, "Missing king.");
       if (cntP != null && cntP.length > 16) message(this_,  cntP.length + " Pawns not allowed!");
       if ((my8thrank != null && my8thrank.match(/[Pp]/)) || 
           (my1strank != null && my1strank.match(/[Pp]/)) )
             message(this_, "Cannot have Pawns in the 1st and 8th ranks!");
       if (initfen_ == binitfen_) {
           if (nside_ == 'b') {
             message(this_, "Black cannot start the game first!");
           } else {
             return 1; 
           }
        }
       return null; 
    }
        
    function generateFEN(this_, whichside) {
      var Board = this_.ChessBoard.Board;
      var enpassant = this_.isEnpassant();
      var piece = null;
      var fen = "", spc = 0, cmp = "";
      var castling = [0,0,0,0,0,0], cst = "";
      for (var v=8; v>=1; v--) {
         spc = 0;
         for (p in horiz) {
            piece = Board[horiz[p] + v].piece;
            if (piece != null) {
                cmp =  (piece.color_.match(/dt$/)) ? piece.role_.toLowerCase() : piece.role_;
                fen = fen + ((spc > 0) ? (spc + cmp) : cmp);
                spc = 0;
                // check for castling availability
                if (cmp == 'K' && piece.location_ == 'e1' && piece.oldlocation_ == null) castling[0] =  1;
                if (cmp == 'k' && piece.location_ == 'e8' && piece.oldlocation_ == null) castling[1] =  1;
                if (cmp == 'R' && piece.location_ == 'h1' && piece.oldlocation_ == null) castling[2] =  1;
                if (cmp == 'R' && piece.location_ == 'a1' && piece.oldlocation_ == null) castling[3] =  1;
                if (cmp == 'r' && piece.location_ == 'h8' && piece.oldlocation_ == null) castling[4] =  1;
                if (cmp == 'r' && piece.location_ == 'a8' && piece.oldlocation_ == null) castling[5] =  1;
            } else { spc ++; }
         }
         fen = fen + ((spc > 0) ? spc : "");
         if (v > 1) fen = fen + "/";
       } 
       if (castling[0] == 1 && castling[2] == 1) cst = cst + "K";
       if (castling[0] == 1 && castling[3] == 1) cst = cst + "Q";
       if (castling[1] == 1 && castling[4] == 1) cst = cst + "k";
       if (castling[1] == 1 && castling[5] == 1) cst = cst + "q";
       if (cst == "") cst = "-";
       fen = fen + " " + whichside + " " + cst + " " + enpassant + " " + "0 1";
       return fen;
    }

    function post(msg)      { ENGINE_.postMessage(msg); }

    var ENGINE_ = null, ANALYZE_ = [];
    var ENGINE_UCI_RESPONSE_ = null, ENGINE_READY_RESPONSE_ = null, ENGINE_NEW_RESPONSE_ = null, ENGINE_NEXT_RESPONSE_ = null;
    var ENGINE_STATE_REQ_ = false;
    async function loadStockfish() {
       ENGINE_ = await new Worker('/wasm/stockfish.js');
       ENGINE_.posted = {}; 
       ENGINE_.id     = "stockfish15";
       ENGINE_.onmessage = function(event) {
             var engine_ = ENGINE_.ENGINEMOVE_;
             var load = event.data ? event.data : event;
             if (typeof(load.match) == "undefined") return;
             if (load.match(/^uciok$/)) {
                ENGINE_UCI_RESPONSE_ = 'uciok'; 
                return;
             } 
             if (load.match(/^readyok$/)) {
                ENGINE_READY_RESPONSE_ = 'readyok'; 
                return;
             }
             var sdata = load.split(' ');
             var mate = sdata[8];
             var xcp   = parseInt(sdata[9]);
             var draw = Math.floor(parseInt(sdata[12]) / 2);
             var win = ( parseInt(sdata[11])) / 1000;
             var draw = (parseInt(sdata[12])) / 1000;
             var loss = (parseInt(sdata[13])) / 1000;
             var wscore = (parseInt(sdata[11]) + parseInt(sdata[12])/2) / 1000;
             var bscore = (parseInt(sdata[13]) + parseInt(sdata[12])/2) / 1000;
             var srate = 1 / (1 + Math.exp(-0.004*xcp)); // formula from Landon Lehman blog site.
             var pv = load.lastIndexOf("pv");
             if (!isNaN(srate))  {
                        ANALYZE_.push({ srate: srate, mt: mate, wscore: wscore, bscore: bscore, cp: xcp,
                                        win: win, draw: draw, loss: loss, moves: load.slice(pv+3) } );
              }
             if (load.includes("info depth 0 score cp 0")) {
                 _POSSIBLE_STALE_MATE_ = true;  
                 log("possible stale mate ...");
             } else
             if (load.includes("mate 0")) {
                 _POSSIBLE_CHECK_MATE_ = true;  
                 log("possible check mate ...");
             } else
             if (load.includes("mate 1 ")) {
                 _CHECK_MATE_ = true;  
                 log("check mate ...");
             } else
             if (load.includes('bestmove')) {
                ENGINEMOVE_ = sdata[1];
                PONDER_ = sdata[3];
                if (ENGINE_STATE_REQ_) {
                  ENGINE_NEXT_RESPONSE_ = true;
                  ENGINE_STATE_REQ_ = false;
                  return;
                }
                if (ENGINEMOVE_ == "(none)" && _POSSIBLE_CHECK_MATE_ == true) {
                  _CHECK_MATE_ = true;
                  _NO_POSSIBLE_MOVES_ = true;
                  log("mate ...");
                } else
                if (ENGINEMOVE_ == "(none)" && _POSSIBLE_STALE_MATE_ == true) {
                  _STALE_MATE_ = true;
                  log("stalemate ...");
                } else
                if (typeof(PONDER_) == "undefined") { 
                  // _NO_POSSIBLE_MOVES_ = true;
		  log(_CHECK_MATE_);
                  log("(possible mate ...)");
                } 
             } 
       };
  
    }

    var BOOK_ = null;
    function searchECO() {
       var randmove = 0, book_ = "";
       var game_ = searchGame();
       const ecoran_ = [];
       BOOK_ = null;
       for (p in ECO_) {
          var eco = ECO_[p][2];
          if (typeof(eco) != "undefined") {
            if (eco.match(game_)) {
               ecoran_.push(ECO_[p]);
            } 
          }
       }
       randmove = Math.floor(Math.random() * ecoran_.length)
       if (ecoran_.length > 0 ) {
         var idx = (SIDETOMOVE_ == WHITE) ? (MOVECOUNT_ * 2): (MOVECOUNT_ * 2 + 1) , 
             move_ = null;
         BOOK_ = ecoran_[randmove]
         ecoid.innerHTML = BOOK_[0] 
         openingid.innerHTML = BOOK_[1] 
         variationid.innerHTML = BOOK_[2].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, ''); 
         move_ = BOOK_[2].split(' ')[idx]
         if (typeof(move_) != "undefined") { 
           move_ = move_.replace(/^[0-9]+\./g, "");
         } else BOOK_ = null; 
         if (BOOK_ != null && BOOK_[2].lastIndexOf("(") >=0 ) BOOK_ = null;
         return move_;
       }
       return null;
    }

    var ANALYZERATE_ = 50;
    function setRate() {
        var height = (!REVERSE) ? ANALYZERATE_ : 100 - ANALYZERATE_;
        chessrate.style.height = height + "%";
        chessside0.style.backgroundColor = (!REVERSE) ? "#FFFFFF" : "#404040";
        chessrate.style.backgroundColor = (!REVERSE) ? "#404040" : "#FFFFFF";
    }


    function updateMate()  {
      const chk = document.getElementById(LASTMOVE_);
      if (chk != null) {
        const cnt_ = LASTMOVE_.split('_')[1];
        const move_ = LASTMOVE_.split('_')[2];
        chk.innerHTML = (_CHECK_MATE_ || _NO_POSSIBLE_MOVES_) ? '#' : (_CHECK1_KING_ ? '+' : '');
        for (p in ecoGame_) {
           const eco_ = ecoGame_[p];
           if (eco_ == cnt_ + '.' + move_ + '+') {
                ecoGame_[p] = cnt_ + '.' + move_ + '#';
           } else
           if (eco_ == move_ + '+') {
                ecoGame_[p] = move_ + '#';
            }
        }
      }
    }

    const bcapture = document.getElementById("bcapture");
    const wcapture = document.getElementById("wcapture");
    const wicon_ = { Q:'&#9813;', R:'&#9814;', B:'&#9815;', N:'&#9816;', P:'&#9817;' }
    const bicon_ = { Q:'&#9819;', R:'&#9820;', B:'&#9821;', N:'&#9822;', P:'&#9823;' }
    function sortBenchedPieces() {
log("deal with this later ...");
return;
        const white_ = { Q: 0, R: 0, B: 0, N: 0, P: 0 };
        const black_ = { Q: 0, R: 0, B: 0, N: 0, P: 0 };
        if (BOARDSIZE_ < 480) {
          bcapture.innerHTML = '';
          wcapture.innerHTML = '';
          return
        }
        for (p in Benched) {
           const piece = Benched[p];
           if (piece.color_.match(/lt$/)) {
             white_[piece.role] ++ ;
           } else {
             black_[piece.role_] ++ ;
           }
        }
        const pieces_ = ['Q','R','B','N','P'];
        var wpcs_ = '', bpcs_ = '';
        for (h in pieces_) {
           const pcs = pieces_[h];
           const wpiece = white_[pcs]; bpiece = black_[pcs];
           if (wpiece > 0) for (var i=1; i<=wpiece; i++) wpcs_ = wpcs_ + wicon_[pcs];
           if (bpiece > 0) for (var i=1; i<=bpiece; i++) bpcs_ = bpcs_ + bicon_[pcs];
        }
        bcapture.innerHTML = wpcs_; 
        wcapture.innerHTML = bpcs_; 
    }


    function scrollOffset(e, clientXY = true) {
          e = e || window.event;
           edoc = (e.target && e.target.ownerDocument) || document;
           doc = edoc.documentElement;
           body = edoc.body;

           x = (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
               (doc && doc.clientLeft || body && body.clientLeft || 0);
           y = (doc && doc.scrollTop  || body && body.scrollTop  || 0) -
               (doc && doc.clientTop  || body && body.clientTop  || 0 );
           if (clientXY) {
              x += e.clientX;
              y += e.clientY;
           }
          return { x: x, y: y }
    }

    function identifySource(Board, piece_) {
       var src_ = '', srch_ = '', srcv_ = '';
       for (var p in Board) {
         const piece = Board[p].piece;
         if (src_.length == 2) break; // we got the full source
         if (piece != null && piece.role_ == piece_.role_) {
             if (piece_ !== piece) {
               if (piece_.color_ == piece.color_) {
                  const ro_ = piece_.role_, oh_ = (piece_.oldlocation_ != null) ? piece_.oldlocation_[0] : null, 
                                            ov_ = (piece_.oldlocation_ != null) ? piece_.oldlocation_[1] : null, 
                       nh_ = piece_.location_[0], nv_ = piece_.location_[1];
                  const ro = piece.role_, oh = (piece.oldlocation_ != null) ? piece.oldlocation_[0] : null, 
                                          ov = (piece.oldlocation_ != null) ? piece.oldlocation_[1] : null, 
                        nh = piece.location_[0], nv = piece.location_[1];
             
                  for (y in ['R', 'Q']) {
                    const mro = ['R', 'Q'][y];
                    if (ro_ == mro) {
                      var blk_ = false;
                      if (nv_ == nv) {
                          const d1 = oh_.charCodeAt(0), d2 = nh.charCodeAt(0);
                          const mi = (d1 < d2) ? d1 : d2, mx = (d1 < d2) ? d2 : d1
                          for (var i = mi;  i <= mx; i++) { 
                               const hv = String.fromCharCode(i) + nv_;
                               if (Board[hv].piece != null && Board[hv].role_ != mro ) { blk_ = true; break }
                          }
                      } else // end if ov_ == ov
                      if (nh_ == nh) {
                          const mi = (ov_ < nv) ? ov_ : nv, mx = (ov_ < nv) ? nv : ov_ 
                          for (var i = mi;  i <= mx; i++) {
                               const hv = nh_ + i;
                               if (Board[hv].piece != null && Board[hv].role_ != mro ) { blk_ = true; break }
                          }
                      } 
                      if (!blk_ && (nv_ == nv || nh_ == nh)) { 
                            if (src_.length == 0) {
                               if (oh_ != nh) src_ = oh_; else src_ = ov_;
                            } else
                            if (src_.length == 1) {
                                   if (src_ == oh_) src_ = src_ + ov_;
                                   if (src_ == ov_) src_ = oh_ + src_ ;
                            }
                      }
                    } // end ro == 'R'
                  } // end for mro

                  for (y in ['B', 'Q']) {
                    const mro = ['B', 'Q'][y];
                    if (ro_ == mro) {
                      var blk_ = false;
                      const d1 = nh.charCodeAt(0), d2 = nh_.charCodeAt(0), diff_h = Math.abs(d1 - d2), diff_v = Math.abs(nv - nv_);
                      if (diff_h == diff_v) {
                         const mi = (d1 < d2) ? d1 : d2, mx = (d1 < d2) ? d2 : d1
                         for (var i=1; i<=diff_h; i++) {
                             const hv = String.fromCharCode(mi + i) + (parseInt(nv) < parseInt(nv_) ? (parseInt(nv) + i) : (parseInt(nv) - i));
                             if (Board[hv].piece != null && Board[hv].role_ != mro ) { blk_ = true; break }
                         }
                         if (!blk_) {
                            if (src_.length == 0) {
                               if (oh_ != nh) src_ = oh_; else src_ = ov_;
                            } else
                            if (src_.length == 1) {
                                   if (src_ == nh) src_ = src_ + ov_;
                                   if (src_ == nv) src_ = oh_ + src_ ;
                            }
                         } 
                      }
                    } // end ro == 'B'
                  } // end for mro

                  if (ro_ == 'N') {
                      const d1 = nh.charCodeAt(0), d2 = nh_.charCodeAt(0), diff_h = Math.abs(d1 - d2), diff_v = Math.abs(nv - nv_);
                      if ((diff_h == 1 && diff_v == 2) || (diff_h == 2 && diff_v == 1)) { 
                        if (src_.length == 0) {
                               if (oh_ != nh) src_ = oh_; else src_ = ov_;
                        } else
                        if (src_.length == 1) {
                               if (src_ == nh) src_ = src_ + ov_;
                               if (src_ == nv) src_ = oh_ + src_ ;
                        }
                      }
                  }


                } // end if piece.color
              } // end if piece != piece
          } // end if piece null
       } // end for
       return src_;
    }

    function getImgSrc(tag) {
      if (RMOO_PIECES_ == true ) {
        const piece_path = "/images/rmoo_";
        return piece_path + tag + ".svg";
      } else {
        const piece_path = "/images/Chess_";
        return piece_path + tag + "45.svg";
      }
    }

    function threat_by_bishop(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, Queen = 0) {
            var Board = game.ChessBoard.Board;
            var this_ = pclass;
            var threat = 0;
            var colorl = (Queen) ? 'qlt' : 'blt';
            var colord = (Queen) ? 'qdt' : 'bdt';
            if (diff_kdh == diff_kdv && Piece.color_ == colorl) {  var bthreat = 1;
                 for (var v = 1; v < diff_kdv; v++) {
                     const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + v) : (KD_loc.nv - v);
                     const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + v) : (KD_loc.nh - v);
                     const nh = String.fromCharCode(dist);
                     if (Board[nh + nv].piece  != null)  { bthreat = 0; break }
                 }
                 threat = bthreat;
            }
            if (diff_klh == diff_klv && Piece.color_ == colord) {  var bthreat = 1;
                 for (var v = 1; v < diff_klv; v++) {
                     const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + v) : (KL_loc.nv - v);
                     const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + v) : (KL_loc.nh - v);
                     const nh = String.fromCharCode(dist);
                     if (Board[nh + nv].piece  != null)  { bthreat = 0; break }
                 }
                 threat = bthreat;
            }
             game.GAME_STATE._check_king_ = game.GAME_STATE._check_king_ || (threat && this_.color_.slice(-2) == Piece.color_.slice(-2))
             threat = game.GAME_STATE._check_king_ ? 0 : threat; // not endangering itself
             return  threat;
    }

    function threat_by_rook(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, Queen = 0) {
             var Board = game.ChessBoard.Board;
             var this_ = pclass;
             var nh = null, nv = null, threat = 0;
             var colorl = (Queen) ? 'qlt' : 'rlt';
             var colord = (Queen) ? 'qdt' : 'rdt';
             if (diff_kdh == 0 && diff_kdv > 0 && Piece.color_ == colorl ) { var rthreat = 1;
                 for (var v = 1; v < diff_kdv; v++) {
                     const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + v) : (KD_loc.nv - v);
                     const nh = String.fromCharCode(KD_loc.nh);
                     if (Board[nh + nv].piece  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             } else
             if (diff_kdv == 0 && diff_kdh > 0 && Piece.color_ == colorl) { var rthreat = 1;
                 for (var h = 1; h < diff_kdh; h++) {
                     const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + h) : (KD_loc.nh - h);
                     const  nh = String.fromCharCode(dist);
                     if (Board[nh + KD_loc.nv].piece  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             }
             if (diff_klh == 0 && diff_klv > 0 && Piece.color_ == colord) { var rthreat = 1;
                 for (var v = 1; v < diff_klv; v++) {
                     const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + v) : (KL_loc.nv - v);
                     const nh = String.fromCharCode(KL_loc.nh);
                     if (Board[nh + nv].piece  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             }  else
             if (diff_klv == 0 && diff_klh > 0 && Piece.color_ == colord) { var rthreat = 1;
                 for (var h = 1; h < diff_klh; h++) {
                     const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + h) : (KL_loc.nh - h);
                     const  nh = String.fromCharCode(dist);
                     if (Board[nh  + KL_loc.nv].piece  != null)  { rthreat = 0; break }
                 }
                 threat = rthreat;
             }
             game.GAME_STATE._check_king_ = game.GAME_STATE._check_king_ || (threat && this_.color_.slice(-2) == Piece.color_.slice(-2))
             threat = game.GAME_STATE._check_king_ ? 0 : threat; // not endangering itself
             return threat;
    }

    function threat_by_knight(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv) {
             var Board = game.ChessBoard.Board;
             var this_ = pclass;
             var nthreat = 0;
             if (diff_kdv == 2 && diff_kdh == 1 && Piece.color_ == 'nlt') {
                 const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + 1) : (KD_loc.nh - 1);
                 const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + 2) : (KD_loc.nv - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv].piece  != null)  { nthreat = 1; }
             } else
             if (diff_kdh == 2 && diff_kdv == 1 && Piece.color_ == 'nlt') {
                 const nv = (KD_loc.nv < ploc.nv) ? (KD_loc.nv + 1) : (KD_loc.nv - 1);
                 const dist = (KD_loc.nh < ploc.nh) ? (KD_loc.nh + 2) : (KD_loc.nh - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv].piece  != null)  { nthreat = 1; }
             }
             if (diff_klv == 2 && diff_klh == 1 && Piece.color_ == 'ndt') {
                 const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + 1) : (KL_loc.nh - 1);
                 const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + 2) : (KL_loc.nv - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv].piece  != null)  { nthreat = 1; }
             } else
             if (diff_klh == 2 && diff_klv == 1 && Piece.color_ == 'ndt') {
                 const nv = (KL_loc.nv < ploc.nv) ? (KL_loc.nv + 1) : (KL_loc.nv - 1);
                 const dist = (KL_loc.nh < ploc.nh) ? (KL_loc.nh + 2) : (KL_loc.nh - 2);
                 const nh = String.fromCharCode(dist);
                 if (Board[nh + nv].piece  != null)  { nthreat = 1; }
             }
             game.GAME_STATE._check_king_ = game.GAME_STATE._check_king_ || (nthreat && this_.color_.slice(-2) == Piece.color_.slice(-2))
             nthreat = game.GAME_STATE._check_king_ ? 0 : nthreat; // not endangering itself
             return nthreat;
    }

    function get_location(obj) {
         var oh = null, ov = null;
         if (obj == null) illegal_move('Possibly no available king.');
         const oldlocation = obj.oldlocation;
         oh = (oldlocation != null) ? oldlocation[0].charCodeAt(0) : null;
         ov = (oldlocation != null) ? oldlocation[1] : null;
         return { nh: obj.location[0].charCodeAt(0 ), nv: parseInt(obj.location[1]), oh: oh, ov: ov };
    }


    function  evaluate_king_threat(game, pclass, RES) {
          var Board = game.ChessBoard.Board;
          var this_ = pclass;
          var KD = null, KL = null;
          // find the kings
          for (var p in Board) {
               const Piece = Board[p].piece;
               if (Piece != null) {
                  if (Piece.role == 'K') {
                     if (Piece.color_ == 'klt') {
                         KL = Piece;
                     } else
                     if (Piece.color_ == 'kdt') {
                         KD = Piece;
                     }
                  }
               }
          }
          var KDR_loc = null,  KLR_loc = null;
          if (RES == CASTLESHORT) {
              const KDR = new game.Piece(game, "K", "kdt", "f8");
              const KLR = new game.Piece(game, "K", "klt", "f1");
              KDR_loc = get_location(KDR);
              KLR_loc = get_location(KLR);
          } else
          if (RES == CASTLELONG) {
              const KDR = new game.Piece(game, "K", "kdt", "d8");
              const KLR = new game.Piece(game, "K", "klt", "d1");
              KDR_loc = get_location(KDR);
              KLR_loc = get_location(KLR);
          }
          const KD_loc = get_location(KD); const KL_loc = get_location(KL);
          // evaluate the pieces
          var threat = 0;
          game.GAME_STATE._check_king_ = false;
          for (var p in Board) {
               const Piece = Board[p].piece;
               // if (Piece === this_) continue;
               if (Piece != null) {
                  const ploc = get_location(Piece);
                  const diff_kdh = Math.abs(KD_loc.nh - ploc.nh); const diff_kdv = Math.abs(KD_loc.nv - ploc.nv);
                  const diff_klh = Math.abs(KL_loc.nh - ploc.nh); const diff_klv = Math.abs(KL_loc.nv - ploc.nv);
                  var diff_kdrh = 0, diff_kdrv = 0, diff_klrh = 0, diff_klrv = 0;
                  if (KDR_loc != null && KLR_loc != null) {
                    diff_kdrh = Math.abs(KDR_loc.nh - ploc.nh); diff_kdrv = Math.abs(KDR_loc.nv - ploc.nv);
                    diff_klrh = Math.abs(KLR_loc.nh - ploc.nh); diff_klrv = Math.abs(KLR_loc.nv - ploc.nv);
                  }
                  if (Piece.role == 'K') {
                      var kthreat = 0;
                      if (Piece.color_ == 'klt') {
                         if ((diff_kdh == 0 && diff_kdv == 1) || (diff_kdv == 0 && diff_kdh == 1)) { kthreat = 1; }
                         if ((diff_kdh ==  diff_kdv && diff_kdv == 1)) { threat = 1; }
                      } else {
                         if ((diff_klh == 0 && diff_klv == 1) || (diff_klv == 0 && diff_klh == 1)) { kthreat = 1; }
                         if ((diff_klh ==  diff_klv && diff_klv == 1)) { threat = 1; }
                      }
                      game.GAME_STATE._check_king_ = game.GAME_STATE._check_king_ || (kthreat && this_.color_.slice(-2) == Piece.color_.slice(-2))
                      kthreat = game.GAME_STATE._check_king_ ? 0 : kthreat; // not endangering itself
                      threat = (kthreat) ? -1 : threat;

                  } else
                  if (Piece.role == 'Q') {
                      const bthreat = threat_by_bishop(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, 1);
                      const rthreat = threat_by_rook(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv, 1);
                      threat = (bthreat || rthreat) ? 2 : threat;
                      if (KDR_loc != null && KLR_loc != null) { // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const bthreat1 = threat_by_bishop(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv, 1);
                        const rthreat1 = threat_by_rook(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv, 1);
                        threat = (bthreat1 || rthreat1) ? -2 : threat;
                      }
                  } else
                  if (Piece.role == 'B') {
                      const bthreat = threat_by_bishop(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv);
                      threat = (bthreat) ? 3 : threat;
                      if (KDR_loc != null && KLR_loc != null) { // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const bthreat1 = threat_by_bishop(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv);
                        threat = (bthreat1) ? -3 : threat;
                      }
                  } else
                  if (Piece.role == 'R') {
                      const rthreat = threat_by_rook(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv);
                      threat = (rthreat) ? 4 : threat;
                      if (KDR_loc != null && KLR_loc != null) {  // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const rthreat1 = threat_by_rook(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv);
                        threat = (rthreat1) ? -4 : threat;
                      }
                  } else
                  if (Piece.role == 'N') {
                      const nthreat = threat_by_knight(game, pclass, Piece, KD_loc, KL_loc, ploc, diff_kdh, diff_kdv, diff_klh, diff_klv);
                      threat = (nthreat) ? 5 : threat;
                      if (KDR_loc != null && KLR_loc != null) {  // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                        const nthreat1 = threat_by_knight(game, pclass, Piece, KDR_loc, KLR_loc, ploc, diff_kdrh, diff_kdrv, diff_klrh, diff_klrv);
                        threat = (nthreat1) ? -5 : threat;
                      }
                  } else
                  if (Piece.role == 'P') {
                     var pthreat = 0, pthreat1 = 0;
                     if (diff_klh == 1 && diff_klv == 1) {
                       if (KL_loc.nv < ploc.nv && Piece.color_ == 'pdt') { pthreat = 1; }
                     }
                     if (diff_kdh == 1 && diff_kdv == 1) {
                       if (KD_loc.nv > ploc.nv && Piece.color_ == 'plt') { pthreat = 1; }
                     }
                     game.GAME_STATE._check_king_ = game.GAME_STATE._check_king_ || (pthreat && this_.color_.slice(-2) == Piece.color_.slice(-2))
                     pthreat = game.GAME_STATE._check_king_ ? 0 : pthreat; // not endangering itself
                     threat = (pthreat) ? 6 : threat;
                     if (KDR_loc != null && KLR_loc != null) {  // check castle threat
                        if (this_.color_ == 'klt') {  diff_kdrh = 10; diff_kdrv = 20; }
                        if (this_.color_ == 'kdt') {  diff_klrh = -10; diff_klrv = -20; }
                       if (diff_klrh == 1 && diff_klrv == 1) {
                         if (KLR_loc.nv < ploc.nv && Piece.color_ == 'pdt') { pthreat1 = 1; }
                       }
                       if (diff_kdrh == 1 && diff_kdrv == 1) {
                         if (KDR_loc.nv > ploc.nv && Piece.color_ == 'plt') { pthreat1 = 1; }
                       }
                       threat = (pthreat1) ? -6 : threat;
                     }
                  }
                  if (threat)  illegal_move("Move is endangering its own king (" + threat + ")!"); 
               }
          }
          return threat;
    }


    function take_piece(Board, location, color, code) {
           if (Board[location].piece != null ) { // Check if something to eat!
                 var piece_ = Board[location].piece;
                 if (piece_.color_.match(color)) {
                     if (piece_.role == 'K') {
                       illegal_move("Cannot eat king!");
                     } else
                     return EATPIECE;
                 }
           }
           illegal_move("Illegal move " + code + "!");
    }

    function isKingsProximity(Board, this_, loc_) {
       if (!loc_[0].match(/[a-h]/)) return false;
       if (!loc_[1].match(/[1-8]/)) return false;
       return (Board[loc_].piece != null && Board[loc_].piece.role_.match(/[Kk]/) && this_.location_ != loc_); 
    }

    function assertMove(game, pclass, location, promote) {
         const Board = game.ChessBoard.Board;
         const LASTPIECE_ = game.GAME_STATE.lastpiece_;
         const this_ = pclass;
         const locations = { oh: this_.location_[0], ov: parseInt(this_.location_[1]),
                             nh: location[0],       nv: parseInt(location[1]) }
         // assert Promotion
         if (promote != null || promote != null) {
             if (this_.role.match(/[QKRNB]/g)) illegal_move("Illegal promotion ..."); 
             if (this_.color=='plt' && locations.nv != 8) illegal_move("Illegal promotion (11) ...");
             if (this_.color=='pdt' && locations.nv != 1) illegal_move("Illegal promotion (12) ...");
         } 
         if (this_.role_ == "K") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h == 1) ||
                (diff_h == 0 && diff_v == 1) ||
                (diff_v == diff_h && diff_v == 1)) {
                if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "klt") {
                         return take_piece(Board, location, /dt$/, '22');
                      } else
                      if (this_.color_ == "kdt") {
                         return take_piece(Board, location, /lt$/, '21');
                      }
                } else {
                  const oh = this_.location_;
                  const nh = locations.nh, nv = locations.nv
                  const nh1 = String.fromCharCode(this_nh + 1);
                  const nh2 = String.fromCharCode(this_nh - 1);
                  const nv1 = locations.nv + 1;
                  const nv2 = locations.nv - 1;
                  if ( 
                       isKingsProximity(Board, this_, nh1 + nv1 ) || isKingsProximity(Board, this_, nh1 + nv2 ) ||
                       isKingsProximity(Board, this_, nh2 + nv1 ) || isKingsProximity(Board, this_, nh2 + nv2 ) ||
                       isKingsProximity(Board, this_, nh + nv1 ) || isKingsProximity(Board, this_, nh + nv2 ) ||
                       isKingsProximity(Board, this_, nh1 + nv ) || isKingsProximity(Board, this_, nh2 + nv ) 
                  ) {
                      illegal_move("King faces king!");
                  }
                  return GOODMOVE;
                }
            } else // consider castling
            if (diff_v == 0 && diff_h == 2) {
                 if (this_oh < this_nh) {
                     const oh1 = String.fromCharCode(this_oh + 1);
                     const oh2 = String.fromCharCode(this_oh + 2);
                     if ((Board[oh1 + locations.nv].piece == null) &&
                         (Board[oh2 + locations.nv].piece == null) &&
                           this_.oldlocation_ == null ) {
                        if (game.GAME_STATE._check_king_) illegal_move("King is under check!");
                        if ((oh1 + locations.nv != 'f1' && oh2 + locations.nv != 'g1') &&
                            (oh1 + locations.nv != 'f8' && oh2 + locations.nv != 'g8')) {
                              illegal_move("Illegal move (50k)!");
                        };
                        return CASTLESHORT;
                     } else { illegal_move("Illegal move (50)!"); }
                 } else {
                     const oh1 = String.fromCharCode(this_oh - 1);
                     const oh2 = String.fromCharCode(this_oh - 2);
                     if ((Board[oh1 + locations.nv].piece == null) &&
                         (Board[oh2 + locations.nv].piece == null) &&
                          this_.oldlocation_ == null) {
                       if (game.GAME_STATE._check_king_) illegal_move("King is under check!");
                       if ((oh1 + locations.nv != 'd1' && oh2 + locations.nv != 'c1') &&
                           (oh1 + locations.nv != 'd8' && oh2 + locations.nv != 'c8')) {
                              illegal_move("Illegal move (51k)!");
                       };
                       return CASTLELONG;
                     } else { illegal_move("Illegal move (51)!"); }
                 }
            }
            else { illegal_move("Illegal move (20)!"); }
         } else // Queen
         if (this_.role_ == "Q") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h > 0) ||
                (diff_h == 0 && diff_v > 0) ||
                (diff_v == diff_h && diff_v != 0)) {

                // check bishop-like obstruction
                if (diff_v == diff_h && diff_v != 0)
                for (let i=1; i < diff_v; i++) {
                  var oh = null, ov = null;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else {
                     oh = String.fromCharCode(this_oh - i);
                  }
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else {
                     ov = locations.ov - i;
                  }
                  if (Board[oh + ov].piece != null) {
                     illegal_move("Illegal move (33)!");
                  }
                }

                // check root-like obstruction
                if ((diff_v == 0 && diff_h > 0) ||
                   (diff_h == 0 && diff_v > 0))
                for (let i=1; i < ( (diff_v < diff_h) ? diff_h : diff_v ); i++) {
                  var oh = String.fromCharCode(this_oh), ov = locations.ov;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else
                  if (this_oh >this_nh) {
                     oh = String.fromCharCode(this_oh - i);
                  } else
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else
                  if (locations.ov > locations.nv) {
                     ov = locations.ov - i;
                  } else {
                     illegal_move("Illegal move (34)!");
                  }
                  if (Board[oh + ov].piece != null) {
                     illegal_move("Illegal move (35)!");
                  }
                }


                if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "qlt") {
                         return take_piece(Board, location, /dt$/, '18');
                      } else
                      if (this_.color_ == "qdt") {
                         return take_piece(Board, location, /lt$/, '19');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (17)!"); }
         } else // Rook
         if (this_.role_ == "R") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h > 0) ||
                (diff_h == 0 && diff_v > 0)) {

                // check rook obstruction
                for (let i=1; i < ( (diff_v < diff_h) ? diff_h : diff_v ); i++) {
                  var oh = String.fromCharCode(this_oh), ov = locations.ov;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else
                  if (this_oh >this_nh) {
                     oh = String.fromCharCode(this_oh - i);
                  } else
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else
                  if (locations.ov > locations.nv) {
                     ov = locations.ov - i;
                  } else {
                     illegal_move("Illegal move (31)!");
                  }
                  if (Board[oh + ov].piece != null) {
                     illegal_move("Illegal move (32)!");
                  }
                }
                if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "rlt") {
                         return take_piece(Board, location, /dt$/, '15');
                      } else
                      if (this_.color_ == "rdt") {
                         return take_piece(Board, location, /lt$/, '16');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (14)!"); }
         } else // Bishop
         if (this_.role_ == "B") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const aha1 = String.fromCharCode(this_oh);
            const aha2 = String.fromCharCode(this_nh);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if (diff_v == diff_h && diff_v != 0) {
                // check bishop obstruction
                for (let i=1; i < diff_v; i++) {
                  var oh = null, ov = null;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else {
                     oh = String.fromCharCode(this_oh - i);
                  }
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else {
                     ov = locations.ov - i;
                  }
                  if (Board[oh + ov].piece != null) {
                     illegal_move("Illegal move (31)!");
                  }
                }
                if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "blt") {
                         return take_piece(Board, location, /dt$/, '12');
                      } else
                      if (this_.color_ == "bdt") {
                         return take_piece(Board, location, /lt$/, '13');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (11)!"); }

         } else // if Knight
         if (this_.role_ == "N") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            if (locations.ov + 2 == locations.nv ||
                locations.ov == locations.nv + 2) {
                if (this_nh == this_oh + 1 || this_nh + 1 == this_oh) {
                   if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "nlt") {
                         return take_piece(Board, location, /dt$/, '8');
                      } else
                      if (this_.color_ == "ndt") {
                         return take_piece(Board, location, /lt$/, '9');
                      }
                   } else {
                       return GOODMOVE;
                   }
                } else { return take_piece(Board, location, "na", "5"); }
            } else
            if (this_nh + 2 == this_oh ||
                this_nh == this_oh + 2) {
                if (locations.nv == locations.ov + 1 || locations.nv + 1 == locations.ov) {
                   if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "nlt") {
                         return take_piece(Board, location, /dt$/, '10');
                      } else
                      if (this_.color_ == "ndt") {
                         return take_piece(Board, location, /lt$/, '11');
                      }
                   } else {
                       return GOODMOVE;
                   }
                } else { return take_piece(Board, location, "na", "6"); }
            }
            else { return take_piece(Board, location, "na", "7"); }
         } else // if Pawn
         if (this_.role_ == "P") {
             if (locations.oh == locations.nh) {
               if (this_.color_ == "plt") {
                  if (( locations.ov == 2 && ( locations.nv == 3 || locations.nv == 4 ))) {
                     // check obstruction
                     if (locations.nv == 3 && Board[locations.oh + 3].piece != null) {
                          illegal_move("Illegal move (40)!");
                     } else
                     if (locations.nv == 4 && ( Board[locations.oh + 3].piece != null ||
                                                Board[locations.oh + 4].piece != null )) {
                          illegal_move("Illegal move (41)!");
                     }
                     return GOODMOVE;
                  } else if (locations.ov >= 3 && locations.ov + 1 == locations.nv && locations.nv <= 8) {
                     if ( Board[locations.oh + locations.nv].piece != null) {
                          illegal_move("Illegal move (42)!");
                     }
                     return GOODMOVE;
                  } else {
                     illegal_move("Illegal pawn move (42a)!");
                  }
                } else {
                  if (( locations.ov == 7 && ( locations.nv == 6 || locations.nv == 5 ))) {
                     // check obstruction
                     if (locations.nv == 6 && Board[locations.oh + 6].piece != null) {
                          illegal_move("Illegal move (43)!");
                     } else
                     if (locations.nv == 5 && ( Board[locations.oh + 6].piece != null ||
                                                Board[locations.oh + 5].piece != null )) {
                          illegal_move("Illegal move (44)!");
                     }
                     return GOODMOVE;
                  } else if (locations.ov <= 6 && locations.ov - 1 == locations.nv && locations.nv >= 1) {
                     if ( Board[locations.oh + locations.nv].piece != null) {
                          illegal_move("Illegal move (45)!");
                     }
                     return GOODMOVE;
                  } else {
                    illegal_move("Illegal pawn move (46)!");
                  }
                }
             } else { // (locations.oh != locations.nh) -- diagonal means eat
                 const this_nh = locations.nh.charCodeAt(0);
                 const this_oh = locations.oh.charCodeAt(0);
                 const diff_h = Math.abs(this_nh - this_oh);
                 const diff_v = Math.abs(locations.ov - locations.nv);
                 if (diff_h > 1 || diff_v > 1) { illegal_move("Illegl pawn move (47)!"); }
                 if (Board[location].piece != null) { // something to eat?
                   if (this_.color_ == "plt") {
                      if (locations.ov < locations.nv) {
                        return take_piece(Board, location, /dt$/,'48');
                      } else { illegal_move("Illegal move(54)"); }
                    } else {
                      if (locations.ov > locations.nv) {
                         return take_piece(Board, location, /lt$/,'49');
                      } else { illegal_move("Illegal move(55)"); }

                    }
                 } else { // en passant?
                    log("en passant!!!");
                    if (LASTPIECE_ != null) {
                        const that = LASTPIECE_;
                        const that_location = { nh: that.location_[0], nv: parseInt(that.location[1]),
                                                oh: that.oldlocation[0], ov: parseInt(that.oldlocation[1]) }
                        const this_nh = locations.nh.charCodeAt(0);
                        const this_oh = locations.oh.charCodeAt(0);
                        const that_nh = that_location.nh.charCodeAt(0);
                        const that_oh = that_location.oh.charCodeAt(0);
                        const diff_v = Math.abs(that_location.ov - that_location.nv);
                        const diff_h = Math.abs(that_nh - this_nh);
                        if (that_oh != that_nh || that.role != 'P' ||
                            diff_v != 2 || diff_h != 0 || that_location.nv != locations.ov )
                                { illegal_move("Illegal move(53)"); }

                        if (this_.color_ == "plt") {
                            if (locations.ov < locations.nv) {
                                return ENPASSANT;
                            } else { illegal_move("Illegal move(56)"); }
                        } else {
                            if (locations.ov > locations.nv) {
                                return ENPASSANT;
                             } else { illegal_move("Illegal move(57)"); }
                        }
                    } else {
                       illegal_move("Illegal pawn move (52)!");
                    }
                 }
             }
         }
         return UNMOVE;
    }

    function getImage(dv) {
       const img = dv.getElementsByClassName("chessimg")[0];
       return img;
    }

    function removeChild(board) {
        try {
           const img = getImage(board.td_);
           if (img != null) board.td_.removeChild(img);
        } catch(e) {} // no child to remove
    }

    function switchPiece(game, loc_, this_) {
        var Board = game.ChessBoard.Board;
        var board = Board[loc_];
        var tbox  = game.tbox;
        var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
        var board_ui = Board[rloc_];
        removeChild(board_ui);
        board.piece = this_;
        board_ui.td_.appendChild(this_.img_);
    }

    function initCell(game, loc_) {
         var Board = game.ChessBoard.Board;
         var board = Board[loc_];
         var tbox  = game.tbox;
         var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
         var board_ui = Board[rloc_];
         board.piece = null;
    }

    function isProtected(Board, piece, lastpiece_) {
        // No need to search for pieces that oversee the King.
        if (piece.role == 'K') return  false;
        for (var p in Board) {
           const bpiece = Board[p].piece;
           if (bpiece != null) {
              // Gather path and blocking status
      //         log("check protection from " + bpiece.role + " " + bpiece.color + " " + bpiece.location + " for " + piece.role + " " + piece.color + " " + piece.location);
              if (bpiece.color.slice(-2) == piece.color.slice(-2)) {
      //   log("of course, same color ...: " + piece.color.slice(-2));
                if (bpiece.role != piece.role && bpiece.location != piece.location) {
      // log("of course, not same roles ...: " + bpiece.role + ' ' + bpiece.location);
                  const Result = PossibleMoves[bpiece.role](Board, piece, lastpiece_, true);
       //           log("Is protected by " + bpiece.role + " " + bpiece.color + " " + bpiece.location + " protected: " + Result.protected);
                  if (Result.protected) return true;
                }
              }
           }
        }
// log("so no protection ... for the " + piece.role + ' ' + piece.location);
        return false;
    }

    function BishopMove(Board, piece, lastpiece_ = null, isprotected = false) {
        var loc = piece.location;
        var color = piece.color.slice(-2);
        var h = loc[0].charCodeAt(0) - 96, v = loc[1] - 0, uv = 0, dv = 0, lblk = false, rblk = false;
        var location = [];
        var status = { check_king_lt: false, check_king_dt: false };
        uv = v; dv = v;
        lblk = false; rblk = false;
        for (var i = h; i >= 1; i--) {
           if (i == h) continue;
           const oh = horiz[i - 1];
           uv++; dv--;  
           if (uv <= 8) {
               const bpiece = Board[oh + uv].piece;
               if (lblk) status[oh + uv] = true; else status[oh + uv] = false;
               if (bpiece != null && !lblk) { 
                  lblk = true; 
                  if (bpiece.color.slice(-2) == color) {
                     if (isprotected) 
                     if (bpiece.role == 'B' || bpiece.role == 'Q') return { path: null, status: null, protected: true };
                     status[oh + uv] = true;
                  } else
                  if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + uv] = true;
                  }
               }
               location.push(oh + uv);
           }
           if (dv >= 1) {
               const bpiece = Board[oh + dv].piece;
               if (rblk) status[oh + dv] = true; else status[oh + dv] = false;
               if (bpiece != null && !rblk) { 
                    rblk = true; 
                    if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
                       if (bpiece.role == 'B' || bpiece.role == 'Q') return { path: null, status: null, protected: true };
                       status[oh + dv] = true;
                    } else
                    if (!isprotected  && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + dv] = true;
                    }
	       }
               location.push(oh + dv);
           }
        }
        uv = v; dv = v;
        lblk = false; rblk = false;
        for (var i = h; i <= 8; i++) {
           if (i == h) continue;
           const oh = horiz[i - 1];
           uv++; dv--;  
           if (uv <= 8) {
               const bpiece = Board[oh + uv].piece;
               if (lblk) status[oh + uv] = true; else status[oh + uv] = false;
               if (bpiece != null && !lblk) { 
		    lblk = true; 
                    if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
                       if (bpiece.role == 'B' || bpiece.role == 'Q') return { path: null, status: null, protected: true };
                       status[oh + uv] = true;
                    } else
                    if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + uv] = true;
                    }
               }
               location.push(oh + uv);
           }
           if (dv >= 1) {
               const bpiece = Board[oh + dv].piece;
               if (rblk) status[oh + dv] = true; else status[oh + dv] = false;
               if (bpiece != null && !rblk) { 
                    rblk = true;
                    if (bpiece.color.slice(-2) == color) {
                        if (isprotected) 
                        if (bpiece.role == 'B' || bpiece.role == 'Q') return { path: null, status: null, protected: true };
                        status[oh + dv] = true;
                    } else
                    if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                        status[oh + dv] = true;
                    }
               }
               location.push(oh + dv);
           }
        }
        // check king
        for (var p in location) {
           const loc = location[p];
           if (!status[loc]) { // not blocked.
               const bpiece = Board[loc].piece; 
               if (bpiece != null)
               if (bpiece.role == 'K') {
                  const color = bpiece.color.slice(-2);
                  if (color == 'lt') status.check_king_lt = true; 
                  if (color == 'dt') status.check_king_dt = true; 
               }
           }
        }
        return { path: location, status: status, protected: null };
    }

    function RookMove(Board, piece, lastpiece_ = null, isprotected = false) {
        var loc = piece.location;
        var color = piece.color.slice(-2);
        var h = loc[0].charCodeAt(0) - 96, v = loc[1] - 0, blk = false;
        var location = [];
        var status = { check_king_lt: false, check_king_dt: false };
        blk = false; 
        for (var i = h; i >= 1; i--) {
           if (i == h) continue;
           const oh = horiz[i - 1];
           const bpiece = Board[oh + v].piece;
           if (blk) status[oh + v] = true; else status[oh + v] = false;
           if (bpiece != null && !blk) {
                blk = true;
                if (bpiece.color.slice(-2) == color) {
                    if (isprotected) 
                    if (bpiece.role == 'R' || bpiece.role == 'Q') return { path: null, status: null, protected: true };
                    status[oh + v] = true;
                } else
                  if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + v] = true;
                  }
           }
           location.push(oh + v);
        }
        blk = false; 
        for (var i = h; i <= 8; i++) {
           if (i == h) continue;
           const oh = horiz[i - 1];
           const bpiece = Board[oh + v].piece;
           if (blk) status[oh + v] = true; else status[oh + v] = false;
           if (bpiece != null && !blk) {
                blk = true;
                if (bpiece.color.slice(-2) == color) {
                    if (isprotected) 
                    if (bpiece.role == 'R' || bpiece.role == 'Q') return { path: null, status: null, protected: true };
                    status[oh + v] = true;
                } else
                if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                    status[oh + v] = true;
                }
           }
           location.push(oh + v);
        }
        blk = false; 
        for (var i = v; i >= 1; i--) {
           if (i == v) continue;
           const oh = horiz[h - 1];
           const bpiece = Board[oh + i].piece;
           if (blk) status[oh + i] = true; else status[oh + i] = false;
           if (bpiece != null && !blk) {
                blk = true;
                if (bpiece.color.slice(-2) == color) {
                    if (isprotected) 
                    if (bpiece.role == 'R' || bpiece.role == 'Q') return { path: null, status: null, protected: true };
                    status[oh + i] = true;
                } else
                if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                    status[oh + i] = true;
                }
           }
           location.push(oh + i);
        }
        blk = false; 
        for (var i = v; i <= 8; i++) {
           if (i == v) continue;
           const oh = horiz[h - 1];
           const bpiece = Board[oh + i].piece;
           if (blk) status[oh + i] = true; else status[oh + i] = false;
           if (bpiece != null && !blk) {
                blk = true;
                if (bpiece.color.slice(-2) == color) {
                    if (isprotected) 
                    if (bpiece.role == 'R' || bpiece.role == 'Q') return { path: null, status: null, protected: true };
                    status[oh + i] = true;
                } else
                if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                    status[oh + i] = true;
                }
           }
           location.push(oh + i);
        }
        // check king
        for (var p in location) {
           const loc = location[p]
           if (!status[loc]) { // not blocked.
               const bpiece = Board[loc].piece;
               if (bpiece != null)
               if (bpiece.role == 'K') {
                  const color = bpiece.color.slice(-2);
                  if (color == 'lt') status.check_king_lt = true;
                  if (color == 'dt') status.check_king_dt = true;
               }
           }
        }
        return { path: location, status: status, protected: false };
    }

    function KnightMove(Board, piece, lastpiece_ = null, isprotected = false) {
        var loc = piece.location;
        var color = piece.color.slice(-2);
        var h = loc[0].charCodeAt(0) - 96, v = loc[1] - 0, nh = 0, nv = 0;
        var location = [];
        var status = { check_king_lt: false, check_king_dt: false };
        if (h - 2 >= 1)  {
             const oh = horiz[h - 3];
             if (v - 1 >= 1) {
                const bpiece = Board[oh + (v-1)].piece;
                status[oh + (v - 1)] = false;
                if (bpiece != null) {
		   if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
		       if (bpiece.role == 'N') return { path: null, status: null, protected: true };
                       status[oh + (v - 1)] = true;
                   } else
                   if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v - 1)] = true;
                   }
                }
		location.push(oh + (v - 1));
             }
             if (v + 1 <= 8) {
                const bpiece = Board[oh + (v+1)].piece;
                status[oh + (v + 1)] = false;
                if (bpiece != null) {
		   if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
		       if (bpiece.role == 'N') return { path: null, status: null, protected: true };
                       status[oh + (v + 1)] = true;
                   } else
                   if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v + 1)] = true;
                   }
                }
		location.push(oh + (v + 1));
             }
        }
        if (h + 2 <= 8)  {
             const oh = horiz[h + 1];
             if (v - 1 >= 1) {
                const bpiece = Board[oh + (v-1)].piece;
                status[oh + (v - 1)] = false;
                if (bpiece != null) {
                   if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
		       if (bpiece.role == 'N') return { path: null, status: null, protected: true };
                       status[oh + (v - 1)] = true;
                   } else
                   if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v - 1)] = true;
                   }
                }
		location.push(oh + (v - 1));
             }
             if (v + 1 <= 8) {
                const bpiece = Board[oh + (v+1)].piece;
                status[oh + (v + 1)] = false;
                if (bpiece != null) {
                   if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
		       if (bpiece.role == 'N') return { path: null, status: null, protected: true };
                       status[oh + (v + 1)] = true;
                   } else
                   if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v + 1)] = true;
                   }
                }
		location.push(oh + (v + 1));
             }
        }
        if (v - 2 >= 1)  {
             if (h - 1 >= 1) {
                const oh = horiz[h - 2];
                const bpiece = Board[oh + (v-2)].piece;
                status[oh + (v - 2)] = false;
                if (bpiece != null) {
                   if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
		       if (bpiece.role == 'N') return { path: null, status: null, protected: true };
                       status[oh + (v - 2)] = true;
                   } else
                   if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v - 2)] = true;
                   }
                }
		location.push(oh + (v - 2));
             }
             if (h + 1 <= 8) {
                const oh = horiz[h + 0];
                const bpiece = Board[oh + (v-2)].piece;
                status[oh + (v - 2)] = false;
                if (bpiece != null) {
                   if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
		       if (bpiece.role == 'N') return { path: null, status: null, protected: true };
                       status[oh + (v - 2)] = true;
                   } else
                   if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v - 2)] = true;
                   }
                }
		location.push(oh + (v - 2));
             }
        }
        if (v + 2 <= 8)  {
             if (h - 1 >= 1) {
                const oh = horiz[h - 2];
                const bpiece = Board[oh + (v+2)].piece;
                status[oh + (v + 2)] = false;
                if (bpiece != null) {
                   if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
		       if (bpiece.role == 'N') return { path: null, status: null, protected: true };
                       status[oh + (v + 2)] = true;
                   } else
                   if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v - 2)] = true;
                   }
                }
		location.push(oh + (v + 2));
             }
             if (h + 1 <= 8) {
                const oh = horiz[h + 0];
                const bpiece = Board[oh + (v+2)].piece;
                status[oh + (v + 2)] = false;
                if (bpiece != null) {
                   if (bpiece.color.slice(-2) == color) {
                       if (isprotected) 
		       if (bpiece.role == 'N') return { path: null, status: null, protected: true };
                       status[oh + (v + 2)] = true;
                   } else
                   if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v + 2)] = true;
                   }
                }
		location.push(oh + (v + 2));
             }
        }
        // check king
        for (var p in location) {
           const loc = location[p]
           if (!status[loc]) { // not blocked.
               const bpiece = Board[loc].piece;
               if (bpiece != null)
               if (bpiece.role == 'K') {
                  const color = bpiece.color.slice(-2);
                  if (color == 'lt') status.check_king_lt = true;
                  if (color == 'dt') status.check_king_dt = true;
               }
           }
        }
        return { path: location, status: status, protected: false };
    }

    function PawnMove(Board, piece, lastpiece_ = null, isprotected = false, recursive = false) {
        var loc = piece.location;
        var oloc = piece.oldlocation;
        var color = piece.color.slice(-2);
        var h = loc[0].charCodeAt(0) - 96, v = loc[1] - 0, promote = false;
        var location = [];
        var status = { check_king_lt: false, check_king_dt: false };
        if (color == 'lt')  {
           if (oloc == null && v == 2) {
               const oh = horiz[h - 1];
               const bpiece1 = Board[oh +(v+1)].piece;
               const bpiece2 = Board[oh +(v+2)].piece;
               status[oh + (v+2)] = false;
               if (!(bpiece1 == null && bpiece2 == null)) {
                  status[oh + (v+2)] = true;
               }
               location.push(oh + (v + 2));
           } 
           if (v + 1 <= 8) {
               const oh = horiz[h - 1];
               var bpiece = Board[oh +(v+1)].piece;
               status[oh + (v+1)] = false;
               if (bpiece != null) {
                   if (bpiece.color.slice(-2) != color) {
                        status[oh + (v+1)] = true;
                   }
               }
               location.push(oh + (v + 1));
               if (v + 1 == 8) promote = true;

               // eating position & enpassant
               if (h - 1 >= 1) {
                 const oh = horiz[h - 2];
                 bpiece = Board[oh +(v + 1)].piece;
                 status[oh + (v+1)] = true;
                 location.push(oh + (v + 1));
                 if (bpiece != null) {
                     if (bpiece.color.slice(-2) != color) {
                          status[oh + (v+1)] = false;
                     } else {
                          if (isprotected) 
			  if (bpiece.role == 'P') return { path: null, status: null, protected: true };
                     }
                 } else
                 if (lastpiece_ != null && lastpiece_.location[0] == oh && v==5) {
                     bpiece = lastpiece_;
                     if (bpiece.color.slice(-2) != color) {
                          status[oh + (v+1)] = false;
                     } 
                 }
                 
               } 
               if (h + 1 <= 8) {
                 const oh = horiz[h + 0];
                 bpiece = Board[oh +(v+1)].piece;
                 status[oh + (v+1)] = true;
                 location.push(oh + (v + 1));
                 if (bpiece != null) {
                     if (bpiece.color.slice(-2) != color) {
                          status[oh + (v+1)] = false;
                     } else {
                          if (isprotected) 
			  if (bpiece.role == 'P') return { path: null, status: null, protected: true };
                     }
                 } else
                 if (lastpiece_ != null && lastpiece_.location[0] == oh && v==5) {
                     bpiece = lastpiece_;
                     if (bpiece.color.slice(-2) != color) {
                          status[oh + (v+1)] = false;
                     }
                 }
               }
           }
        } else 
        if (color == 'dt') {
           if (oloc == null && v == 7) {
               const oh = horiz[h - 1];
               const bpiece1 = Board[oh +(v-1)].piece;
               const bpiece2 = Board[oh +(v-2)].piece;
               status[oh + (v-2)] = false;
               if (!(bpiece1 == null && bpiece2 == null)) {
                  status[oh + (v-2)] = true;
               }
               location.push(oh + (v - 2));
           }
           if (v - 1 >= 1) {
               const oh = horiz[h - 1];
               var bpiece = Board[oh +(v-1)].piece;
               status[oh + (v-1)] = false;
               if (bpiece != null) {
                   if (bpiece.color.slice(-2) != color) {
                        status[oh + (v-1)] = true;
                   } 
               }
               location.push(oh + (v - 1));
               if (v - 1 == 1) promote = true;

               // eating position 
               if (h - 1 >= 1) {
                 const oh = horiz[h - 2];
                 bpiece = Board[oh +(v-1)].piece;
                 status[oh + (v - 1)] = true;
                 location.push(oh + (v - 1));
                 if (bpiece != null) {
                     if (bpiece.color.slice(-2) != color) {
                          status[oh + (v - 1)] = false;
                     } else {
                          if (isprotected) 
			  if (bpiece.role == 'P') return { path: null, status: null, protected: true };
                     }
                 } else
                 if (lastpiece_ != null && lastpiece_.location[0] == oh && v==4) {
                     bpiece = lastpiece_;
                     if (bpiece.color.slice(-2) != color) {
                          status[oh + (v - 1)] = false;
                     }
                 }
               }
               if (h + 1 <= 8) {
                 const oh = horiz[h + 0];
                 var bpiece = Board[oh +(v-1)].piece;
                 status[oh + (v - 1)] = true;
                 location.push(oh + (v - 1));
                 if (bpiece != null) {
                     if (bpiece.color.slice(-2) != color) {
                          status[oh + (v - 1)] = false;
                     } else {
                          if (isprotected) 
			  if (bpiece.role == 'P') return { path: null, status: null, protected: true };
                     }
                 } else
                 if (lastpiece_ != null && lastpiece_.location[0] == oh && v==4) {
                     bpiece = lastpiece_;
                     if (bpiece.color.slice(-2) != color) {
                          status[oh + (v - 1)] = false;
                     }
                 }
               }
           }
        }
        // check king
        for (var p in location) {
           const loc = location[p]
           if (!status[loc]) { // not blocked.
               const bpiece = Board[loc].piece;
               if (bpiece != null)
               if (bpiece.role == 'K') {
                  const color = bpiece.color.slice(-2);
                  if (color == 'lt') if (piece.location[0] != loc[0]) status.check_king_lt = true;
                  if (color == 'dt') if (piece.location[0] != loc[0]) status.check_king_dt = true;
               }
           }
        }
        return { path: location, status: status, protected: false };
    }

    function KingMove(Board, piece, lastpiece_ = null, isprotected = false) {
        var loc = piece.location;
        var oloc = piece.oldlocation;
        var color = piece.color.slice(-2);
        var h = loc[0].charCodeAt(0) - 96, v = loc[1] - 0;
        var location = [];
        var status = { check_king_lt: false, check_king_dt: false, longcastle: false, shortcastle: false };
        if (h - 1 >= 1) {
            const oh = horiz[h - 2];
            if (v - 1 >= 1) { 
              var bpiece = Board[oh +(v-1)].piece;
              status[oh + (v - 1)] = false;
              if (bpiece != null) {
                 if (bpiece.color.slice(-2) == color) {
                     if (isprotected) 
		     if (bpiece.role == 'K') return { path: null, status: null, protected: true };
                     status[oh + (v - 1)] = true;
                 } else
                 if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v - 1)] = true;
                 }
              }
              location.push(oh + (v - 1));
            }
            if (v + 1 <= 8) { 
              var bpiece = Board[oh +(v+1)].piece;
              status[oh + (v + 1)] = false;
              if (bpiece != null) {
                 if (bpiece.color.slice(-2) == color) {
                     if (isprotected) 
		     if (bpiece.role == 'K') return { path: null, status: null, protected: true };
                     status[oh + (v + 1)] = true;
                 } else
                 if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v + 1)] = true;
                 }
              }
              location.push(oh + (v + 1));
            }
        } 
        if (h + 1 <= 8) {
            const oh = horiz[h + 0];
            if (v - 1 >= 1) { 
              var bpiece = Board[oh +(v-1)].piece;
              status[oh + (v - 1)] = false;
              if (bpiece != null) {
                 if (bpiece.color.slice(-2) == color) {
                     if (isprotected) 
		     if (bpiece.role == 'K') return { path: null, status: null, protected: true };
                     status[oh + (v - 1)] = true;
                 } else
                 if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v - 1)] = true;
                 }
              }
              location.push(oh + (v - 1));
            }
            if (v + 1 <= 8) { 
              var bpiece = Board[oh +(v+1)].piece;
              status[oh + (v + 1)] = false;
              if (bpiece != null) {
                 if (bpiece.color.slice(-2) == color) {
                     if (isprotected) 
		     if (bpiece.role == 'K') return { path: null, status: null, protected: true };
                     status[oh + (v + 1)] = true;
                 } else
                 if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v + 1)] = true;
                 }
              }
              location.push(oh + (v + 1));
            }
        } 
        if (v - 1 >= 1) {
              const oh = horiz[h - 1];
              var bpiece = Board[oh +(v-1)].piece;
              status[oh + (v - 1)] = false;
              if (bpiece != null) {
                 if (bpiece.color.slice(-2) == color) {
                     if (isprotected) 
		     if (bpiece.role == 'K') return { path: null, status: null, protected: true };
                     status[oh + (v - 1)] = true;
                 } else
                 if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v - 1)] = true;
                 }
              }
              location.push(oh + ( v - 1));
        }
        if (v + 1 <= 8) {
              const oh = horiz[h - 1];
              var bpiece = Board[oh +(v+1)].piece;
              status[oh + (v + 1)] = false;
              if (bpiece != null) {
                 if (bpiece.color.slice(-2) == color) {
                     if (isprotected) 
		     if (bpiece.role == 'K') return { path: null, status: null, protected: true };
                     status[oh + (v + 1)] = true;
                 } else
                 if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v + 1)] = true;
                 }
              }
              location.push(oh + ( v + 1));
        }
        if (h - 1 >= 1) {
              const oh = horiz[h - 2];
              var bpiece = Board[oh +(v)].piece;
              status[oh + (v)] = false;
              if (bpiece != null) {
                 if (bpiece.color.slice(-2) == color) { 
                     if (isprotected) 
		     if (bpiece.role == 'K') return { path: null, status: null, protected: true };
                     status[oh + (v)] = true;
                 } else
                 if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v)] = true;
                 }
              }
              location.push(oh + v);
        }
        if (h + 1 <= 8) {
              const oh = horiz[h + 0];
              var bpiece = Board[oh +(v)].piece;
              status[oh + (v)] = false;
              if (bpiece != null) {
                 if (bpiece.color.slice(-2) == color) {
                     if (isprotected) 
		     if (bpiece.role == 'K') return { path: null, status: null, protected: true };
                     status[oh + (v)] = true;
                 } else
                 if (!isprotected && isProtected(Board, bpiece, lastpiece_)) {
                     status[oh + (v)] = true;
                 }
              }
              location.push(oh + v);
        }
        /* castling */
        if (oloc == null && color == 'lt' && loc == 'e1') {
             const rook1 =  Board['a1'].piece;
             const b1 = Board['b1'].piece;
             const c1 = Board['c1'].piece;
             const d1 = Board['d1'].piece;
             const rook2 =  Board['h1'].piece;
             const f1 = Board['f1'].piece;
             const g1 = Board['g1'].piece;

             status['c1'] = true; 
             status['g1'] = true; 

             location.push('c1');
             location.push('g1');
             
             if (b1 == null && c1 == null && d1 == null)
             if (rook1 != null && rook1.oldlocation == null) { status['c1'] = false; status.longcastle = true; }
             if (f1 == null && g1 == null)
             if (rook2 != null && rook2.oldlocation == null) { status['g1'] = false; status.shortcastle = true; }
        }
        if (oloc == null && color == 'dt' && loc == 'e8') {
             const rook1 =  Board['a8'].piece;
             const b8 = Board['b8'].piece;
             const c8 = Board['c8'].piece;
             const d8 = Board['d8'].piece;
             const rook2 =  Board['h8'].piece;
             const f8 = Board['f8'].piece;
             const g8 = Board['g8'].piece;

             status['c8'] = true; 
             status['g8'] = true;

             location.push('c8');
             location.push('g8');
             if (b8 == null && c8 == null && d8 == null)
             if (rook1 != null && rook1.oldlocation == null) { status['c8'] = false; status.longcastle = true; }
             if (f8 == null && g8 == null)
             if (rook2 != null && rook2.oldlocation == null) { status['g8'] = false; status.shortcatle = true; }

        }
        // check king
        for (var p in location) {
           const loc = location[p]
           if (!status[loc]) { // not blocked.
               const bpiece = Board[loc].piece;
               if (bpiece != null)
               if (bpiece.role == 'K') {
                  const color = bpiece.color.slice(-2);
                  if (color == 'lt') status.check_king_lt = true;
                  if (color == 'dt') status.check_king_dt = true;
               }
           }
        }
        return { path: location, status: status, protected: false };
    }

    function QueenMove(Board, piece, lastpiece_ = null, isprotected = false) {
       const B = BishopMove(Board, piece, lastpiece_, isprotected);
       const R = RookMove(Board, piece, lastpiece_, isprotected);
       if (isprotected) return { path: null, status: null, protected: B.protected || R.protected }
       B.status.check_king_lt =  R.status.check_king_lt || B.status.check_king_lt;
       B.status.check_king_dt =  R.status.check_king_dt || B.status.check_king_dt;
       delete R.status.check_king_lt;
       delete R.status.check_king_dt;
       for (var p in R.status) {
          B.status[p] = R.status[p];
       }
       return { path: B.path.concat(R.path), status: B.status, protected: false }
    }

    function useNewBoard(Board) {
         const DBoard = {}
         for (var p in Board) {
            const piece = Board[p].piece;
            DBoard[p] = {}
            if (piece != null)
                DBoard[p].piece = { role: piece.role, color: piece.color, location: piece.location, oldlocation: piece.oldlocation };
            else
                DBoard[p].piece = null
         }
         return DBoard;
    }

    const PossibleMoves = { B: BishopMove, R: RookMove, N: KnightMove, P: PawnMove, K: KingMove, Q: QueenMove };
    function assertNextMoves(Board, piece, Result, lastpiece_, side_) {
         const DBoard = useNewBoard(Board);
 //log("----------------------------------------------------");
 //log("assert next moves ...");
         var srcpiece = null, dstpiece = null, Result1 = null;
         var cnt_lt = Result.path.length, cnt_dt = Result.path.length, blocked = 0;
// log("*******************" + cnt_lt + " " + cnt_dt);
         for (var p in Result.path) {
            var check_king_lt = false, check_king_dt = false;
            const loc = Result.path[p];
// log("piece: " + piece.role + " " + piece.color + " " + piece.location + " going for " + loc);
// log("------------------------------------");
// log("status: " + Result.status[loc]);
            const status = Result.status[loc];
 //            log("path " + loc + " ..." + cnt_lt + " " + cnt_dt);
            if (!status) { // good square
               srcpiece = DBoard[piece.location].piece;
               dstpiece = DBoard[loc].piece;
               DBoard[piece.location].piece = null;
               DBoard[loc].piece = { role: piece.role, color: piece.color, location: loc, oldlocation: piece.location }
               for (var m in DBoard) {
                   const mpiece = DBoard[m].piece;
                   if (mpiece != null && (mpiece.role + mpiece.color) != (piece.role + piece.color)) {
                       Result1 = PossibleMoves[mpiece.role](DBoard, mpiece, lastpiece_, false, true);
  //                     log("mpiece: " + mpiece.role + " " + mpiece.color + " " + mpiece.location);
                       check_king_lt = Result1.status.check_king_lt || check_king_lt;
                       check_king_dt = Result1.status.check_king_dt || check_king_dt;
   //                    log("A recursive check: " + mpiece.role + " " + mpiece.color + " " + mpiece.location + " " + Result1.status.check_king_lt + " " + Result1.status.check_king_dt
    //                      + " at " + piece.role + " " + piece.color + " " + loc);
                   }
               }
               if (check_king_lt) cnt_lt --;
               if (check_king_dt) cnt_dt --;
               DBoard[piece.location].piece = srcpiece;
               DBoard[loc].piece = dstpiece;
            } else blocked ++
         }
     //   log("----> path checked ..." + (cnt_lt - blocked)  + " " + (cnt_dt - blocked));
     //   log("recursive check: " + check_king_lt + " " + check_king_dt);
         delete DBoard; 
         return { cnt_lt: cnt_lt - blocked,  cnt_dt: cnt_dt - blocked }
     }

    function assertMateDraw(game) {
         const Board = game.ChessBoard.Board;
         const side_ = game.GAME_STATE.sidetomove_ == WHITE ? 'lt' : 'dt';
         const lastpiece_ = game.GAME_STATE.lastpiece_;
         var white_move = false, black_move = false;
         var Result1 = null, Result2 = null;
         var rs1_check_king_lt = false, rs1_check_king_dt = false, draw_ = true;
         var lt_pieces = { B:0, N:0, R:0, Q:0, P:0 };
         var dt_pieces = { B:0, N:0, R:0, Q:0, P:0 };
         var rs_cnt_lt = 0;  rs_cnt_dt = 0;
         for (var p in Board) {
           const piece = Board[p].piece;
           if (piece != null) {
              var color = piece.color.slice(-2);
              if (color == 'lt') lt_pieces[piece.role] ++;
              if (color == 'dt') dt_pieces[piece.role] ++;
              // Gather path and blocking status
 // log("let's gather ...");
 // log(piece);
              Result1 = PossibleMoves[piece.role](Board, piece, lastpiece_);
 // log(Result1);
              rs1_check_king_lt = Result1.status.check_king_lt || rs1_check_king_lt;
              rs1_check_king_dt = Result1.status.check_king_dt || rs1_check_king_dt;
              if (piece.color.slice(-2) != side_) {
                Result2 = assertNextMoves(Board, piece, Result1, lastpiece_, side_);
                rs_cnt_lt += Result2.cnt_lt;
                rs_cnt_dt += Result2.cnt_dt;
              }
           }
         }
           log("Do we have a check: " + rs1_check_king_lt + " " + rs1_check_king_dt);
          log("Number of mobility: " + rs_cnt_lt + " " + rs_cnt_dt);
          log("what side: " + side_);
         game.GAME_STATE.gameover_ = 0;
         if (rs_cnt_lt == 0 && rs1_check_king_lt)  {
              game.GAME_STATE.checkmate_ = true;
              game.GAME_STATE.gameover_ = GAMEOVER.CHECKMATE;
log("yes mate 1 ...");
              game.GAME_STATE.checkmatemobility_ = rs_cnt_dt;
              game.GAME_STATE.checkmateside_ = game.GAME_STATE.gameoverside_ = WHITE;
         } else 
         if (rs_cnt_dt == 0 && rs1_check_king_dt)  {
              game.GAME_STATE.checkmate_ = true;
              game.GAME_STATE.gameover_ = GAMEOVER.CHECKMATE;
log("yes mate 2 ...");
              game.GAME_STATE.checkmateside_ = game.GAME_STATE.gameoverside_ = BLACK;
              game.GAME_STATE.checkmatemobility_ = rs_cnt_lt;
         } else
         if (rs_cnt_lt == 0 && !rs1_check_king_lt)  {
              game.GAME_STATE.stalemate_ = true;
              game.GAME_STATE.gameover_ = GAMEOVER.STALEMATE;
              game.GAME_STATE.stalemateside_ = game.GAME_STATE.gameoverside_ = WHITE;
              game.GAME_STATE.stalematemobility_ = rs_cnt_dt;
         } else
         if (rs_cnt_dt == 0 && !rs1_check_king_dt)  {
              game.GAME_STATE.stalemate_ = true;
              game.GAME_STATE.gameover_ = GAMEOVER.STALEMATE;
              game.GAME_STATE.stalemateside_ = game.GAME_STATE.gameoverside_ = BLACK;
              game.GAME_STATE.stalematemobility_ = rs_cnt_lt;
         } else
         if (rs_cnt_lt < rs_cnt_dt && rs1_check_king_lt) {
              game.GAME_STATE.checkking_ = true;
              game.GAME_STATE.checkkingside_ = WHITE;
              if (side_ == 'lt') illegal_move('Move is endangering its own king (111)!');
         } else
         if (rs_cnt_dt < rs_cnt_lt && rs1_check_king_dt) {
              game.GAME_STATE.checkking_ = true;
              game.GAME_STATE.checkkingside_ = BLACK;
              if (side_ == 'dt') illegal_move('Move is endangering its own king (112)!');
         } 
         
         if (!game.GAME_STATE.gameover_) { 
         /* Check for draws based on pieces */
           if ( lt_pieces.P > 0 || dt_pieces.P > 0) draw_ = false; else
           if (!( lt_pieces.R == 0 && lt_pieces.Q == 0 && dt_pieces.R == 0 && dt_pieces.Q == 0 && lt_pieces.P == 0 && dt_pieces.P == 0)) draw_ = false;
           if (lt_pieces.B == 2 || dt_pieces.B == 2) draw_ = false;
           if (lt_pieces.N > 0 && lt_pieces.B > 0) draw_ = false;
           if (dt_pieces.N > 0 && dt_pieces.B > 0) draw_ = false;
log('yes draw 3 ...');
           game.GAME_STATE.drawinsufficient_ = draw_;
log(draw_);
           game.GAME_STATE.gameover_ = (draw_) ? GAMEOVER.INSUFFICIENT : 0;
         }
    }

    function move(game, pclass, what) {
         const Board = game.ChessBoard.Board;
         const Benched = game.ChessBoard.Bench;
         const this_ = pclass;
         const location = what.location;
         const promote = what.promote;
         const Undo = game.Undo_;
         const GAME_STATE = game.GAME_STATE;
         var LASTPIECE_ = GAME_STATE.lastpiece_;
         const RES = assertMove(game, pclass, location, promote);
         if (RES == ENPASSANT) {
                  var len = Benched.length;
                  this_.restype_ = RES;
                  Benched.push ( LASTPIECE_ );
                  switchPiece(game, location, this_);
                  initCell(game, this_.location_);
                  initCell(game, LASTPIECE_.location_);
                  Undo.push( { type: RES, color: this_.color_, piece: this_, benched: LASTPIECE_,
                                oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                  sortBenchedPieces();
         } else
         if (RES == EATPIECE) {
                  var len = Benched.length;
                  this_.restype_ = RES;
                  Benched.push ( Board[location].piece );
                  if (promote != null && promote != "") { 
                       this_.role_ = promote;
                       this_.color_ =  (this_.color_ == 'plt') ? promote.toLowerCase() + 'lt' : promote.toLowerCase() + 'dt';
                       this_.img_.src = getImgSrc(this_.color_);
		       this_.promote_piece = promote;
                  }
                  switchPiece(game, location,this_);
                  initCell(game, this_.location_);
                  Undo.push( { type: RES, color: this_.color_, piece: this_, benched: Benched[Benched.length - 1],
                                oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_, promote: promote } )
                  sortBenchedPieces();
         } else
         if (RES == CASTLELONG) {
                      var goodcastle_ = false;
                      for (var p in Board) {
                         const Piece = Board[p].piece;
                         if (Piece == null) continue;
                         if (Piece.role_ != 'R' || this_.role_ != 'K') continue;
                         if (Piece.oldlocation_ == null && this_.oldlocation_ == null) {
                                              // Rook and King have not moved before
                             if (this_.color_ == "klt") {
                                 if (location == "c1") {
                                   if (Piece.location_ == "a1" && Piece.color == "rlt") {
                                     this_.restype_ = RES;
                                     Piece.oldlocation_ = "a1";
                                     Piece.location_ = "d1";
                                     switchPiece(game, location, this_);
                                     initCell(game, this_.location_);
                                     switchPiece(game, "d1",  Piece);
                                     initCell(game, "a1");
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              } else
                              if (this_.color_ == "kdt") { // dark
                                 if (location == "c8") {
                                   if (Piece.location_ == "a8" && Piece.color == "rdt") {
                                     this_.restype_ = RES;
                                     Piece.oldlocation_ = "a8";
                                     Piece.location_ = "d8";
                                     switchPiece(game, location, this_);
                                     initCell(game, this_.location_);
                                     switchPiece(game, "d8", Piece);
                                     initCell(game, "a8");
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              }
                          }
                       }
                       if (!goodcastle_) illegal_move("Not able to find proper pieces for long castling!");
         } else
         if (RES == CASTLESHORT) {
                      var goodcastle_ = false;
                      for (var p in Board) {
                         const Piece = Board[p].piece;
                         if (Piece == null) continue;
                         if (Piece.role_ != 'R' || this_.role_ != 'K') continue;
                         if (Piece.oldlocation_ == null && this_.oldlocation_ == null) {
                                              // Rook and King have not moved before
                             if (this_.color_ == "klt") {
                                 if (location == "g1") {
                                   if (Piece.location_ == "h1" && Piece.color == "rlt") {
                                     //   Piece.piece.className = "piece p_" + reverseLoc("f1");
                                     this_.restype_ = RES;
                                     // Piece.piece.display = "block";
                                     Piece.oldlocation_ = "h1";
                                     Piece.location_ = "f1";
                                     switchPiece(game, location,  this_);
                                     initCell(game, this_.location_);
                                     Board["f1"].piece = Piece;
                                     switchPiece(game, "f1", Piece);
                                     initCell(game, "h1");
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              } else
                              if (this_.color_ == "kdt") { // dark
                                 if (location == "g8") {
                                   if (Piece.location_ == "h8" && Piece.color == "rdt") {
                                     // Piece.piece.className = "piece p_" + reverseLoc("f8");
                                     this_.restype_ = RES;
                                     // Piece.piece.display = "block";
                                     Piece.oldlocation_ = "h8";
                                     Piece.location_ = "f8";
                                     switchPiece(game, location, this_);
                                     initCell(game, this_.location_);
                                     switchPiece(game, "f8", Piece);
                                     initCell(game, "h8");
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              }
                          }
                       }
                       if (!goodcastle_) illegal_move("Not able to find proper pieces for short castling!");
         } else
         if (RES == GOODMOVE) {
                  if (promote != null && promote != "") { 
                       this_.role_ = promote;
                       this_.color_ =  (this_.color_ == 'plt') ? promote.toLowerCase() + 'lt' : promote.toLowerCase() + 'dt';
                       this_.img_.src = getImgSrc(this_.color_);
		       this_.promote_piece = promote;
                  }
                  this_.restype_ = RES;
                  switchPiece(game, location, this_);
                  initCell(game, this_.location_);
                  Undo.push( { type: RES, color: this_.color_, piece: this_, oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_, promote: promote } )
           } else {
                 illegal_move("No result from assertion!");
           }
           this_.oldlocation_ = this_.location_;
           this_.location_ = location;
           game.GAME_STATE.lastpiece_ = this_;
           assertMateDraw(game);
           const threat = evaluate_king_threat(game, pclass, RES);
           if (threat) { log( "King is in danger (" + threat + ")!"); }
           return RES;
    }


    class Game {

       // Initialize
       Undo_  = []
       MoveHint_ = []
       Moves_ = []
       RepeatDraw_ = []
       tbox = null

       PLAYCNT_ = TIMER_BLITZ_
       PLAYTIME_ = this.PLAYCNT_ * 50

       INIT_STATE =  { sidetomove_: WHITE, movecount_: 0, status_: STATUS.INIT, lastpiece_: null,
                       chessgame_: null, lastmove_: null, playstatus_: STATUS.STOPPED, playcurrent_: null, 
                       ptimer_: null,  mousedu_: false, onpromote_: false, promotepiece: null,
                       checkmate_: false, checkmateside_: null, checkmatemobility_: 0, gamecurrent_: null,
                       stalemate_: false, stalemateside_: null, stalematemobility_: 0,
                       checkking_: false, checkkingside_: null, gameover_: false, gameoverside_: null,
		       drawinsufficient_ : false, drawaccepted_: false
                     }

       INIT_TIMER_ = { last_time: 0, watch: '00:00:00', timer: null, int_timer: 0, elapsed: 0 }

       BPLAYER_ = "human"
       WPLAYER_ = "human"

       Piece = class Piece {
           constructor(this_, role, color, location, set_it) {
              this.image(this_, role, color, location, set_it);
           }

           image(this_, role, color, location, set_it = false) {
               const img = document.createElement('img');
               img.id  = role + location;
               img.src = getImgSrc(color);
               img.className = 'chessimg';
               img.style.display = "block";
               img.style.cursor = "pointer";
               img.style.top = '0px';
               img.style.left = '0px';
               img.style.width = this_.cellwidth + 'px';
               img.style.height = this_.cellheight + 'px';
               this.img_ = img;
               this.role_ = role;
               this.color_ = color;
               this.location_ = location;
               this.oldlocation_ = null;
               // this.active_ = 1;
               img.piece = this;
               img.game_ = this_;
               img.addEventListener('mousedown', this_.mouseDownForMove);
               if (set_it) { img.ondblclick = this_.unsetPiece; }
           }

           get role() { return this.role_; }
           get location() { return this.location_; }
           get oldlocation() { return this.oldlocation_; }
           get getpiece() { return this.piece; }
           get color() { return this.color_; }

           set move(what) {
             return move(this.img_.game_, this, what);
           }
       }


       constructor(id, parent, top, left, width, height, color, padding, control = true) {
          this.id = id;
          this.parent_ = parent;
          this.ChessBoard = this.createBoard(id, parent, top, left, width, height, color, padding);
          this.positionBoard(wINITFEN_, this);
          this.GAME_STATE = Object.assign({}, this.INIT_STATE);
          this.createWindow(id, parent, control);
          this.colorBoard(this, color);
       }

      createBoard(id, parent, top = 10, left = 10, width = 400, height = 400, color, padding = 14 ) {
          const Board = {};
          const tbox = document.createElement('div');
          const tb = document.createElement('table');
          const tbody = document.createElement('tbody');
          tbody.style = "margin: 0px; padding: 0px";
          var cellwidth = width / 8; 
          var cellheight = height / 8;
          this.cellwidth = cellwidth;
          this.cellheight = cellwidth;
          tbox.className = 'chessbox';
          tbox.style.top = top + 'px';
          tbox.style.left = left + 'px';
          tbox.style.width = width + 'px';
          tbox.style.height = height + 'px';
          tbox.style.padding = padding + 'px';
          tbox.style.paddingTop = '5px';
          tbox.style.paddingBottom = '5px';
          tbox.style.paddingRight = padding + 'px'; 
          tbox.style.paddingLeft = padding + 'px'; 
          tb.className = 'chesstable';
          tb.appendChild(tbody);
          tbox.appendChild(tb);
          tbox.reversed_ = false;
          tbox.boardcolor_ = BOARDCOLOR_[color];
          tbox.boardnumbers_ = {};
          for (var v = 8; v>=1; v--) {
            const tr = document.createElement('tr');
            tr.className = 'chessrow';
            for (var p=0; p<=7; p++) {
               const h = horiz[p];
               const td = document.createElement('td');
               const dv = this.createEmptyCell(this, tbox, v, p);
               if ((p + v) % 2) td.className = 'darksquare'; else td.className = 'lightsquare';
               td.cellspacing = 0; td.cellpadding = 0;
               td.style.width = cellwidth + 'px';
               td.style.height = cellheight + 'px';
               td.id = h + v;
               dv.id = h + v;
               td.appendChild(dv);
               tr.appendChild(td);
               Board[h + v] = { td_ : dv, piece: null};
            }
            tbody.appendChild(tr);
          }

          return { tbox: tbox, Board: Board, Bench: [] };
     }

     createEmptyCell(this_, tbox, v, p) {
          const empty = document.createElement('div');
          const color = tbox.boardcolor_;
          empty.className = "cellcontainer"; // "chessimg";
          empty.style.width = this_.cellwidth + 'px';
          empty.style.height = this_.cellheight + 'px';
          const a = document.createElement('span');
          const b = document.createElement('span');
          a.className = 'rboardno'; 
          b.className = 'bboardno';
          if (p == 7) { a.innerHTML =  v; a.style.color = (v % 2) ? color.dt : color.lt; };
          if (v == 1) { b.innerHTML = horiz[p];  b.style.color = (p % 2) ? color.dt : color.lt; };
          empty.appendChild(a);
          empty.appendChild(b);
          empty.anum_ = a;
          empty.bnum_ = b;
          return empty;
     }

     rgba(hex, opacity) {
       const r = parseInt('0x' + hex.slice(1,3));
       const g = parseInt('0x' + hex.slice(3,5));
       const b = parseInt('0x' + hex.slice(5,7));
       const color = 'rgb(' + r + ',' + g + ',' + b + ',' + opacity + ')';
       return color;
     }

     colorBoard(this_, selected) {
          const Board = this_.ChessBoard.Board;
          const tbox = this_.ChessBoard.tbox;
          const color = BOARDCOLOR_[selected];
          var reversed = this.tbox.reversed_;
          var len = 0;
          tbox.style.backgroundColor = color.sd;
          const lt = tbox.getElementsByClassName('lightsquare');
          const dt = tbox.getElementsByClassName('darksquare');
          len = lt.length;
          for (var i=0; i<len; i++) {
              const elem = lt[i];
              elem.style.backgroundColor = color.lt;
          }
          len = dt.length;
          for (var i=0; i<len; i++) {
              const elem = dt[i];
              elem.style.backgroundColor = color.dt;
          }
          tbox.boardcolor_ = color;

          // color Numbers
          for (var i=8; i>=1; i--) {
            var anum = Board['h' + i].td_.anum_;
            var bnum = Board[horiz[8-i] + 1].td_.bnum_;
            anum.style.color = (i % 2) ? color.dt : color.lt;
            bnum.style.color = (i % 2) ? color.dt : color.lt;
          }

          this_.footer_.style.backgroundColor = tbox.boardcolor_.sd;
          this_.header_.style.backgroundColor = tbox.boardcolor_.sd;
          this_.ftr_player_.style.color = '#2a2a2a'; // tbox.boardcolor_.hdt;
          this_.hdr_player_.style.color = '#2a2a2a'; // tbox.boardcolor_.hdt;
          this_.hdr_capture_.style.color = tbox.boardcolor_.lt;
          this_.ftr_capture_.style.color = tbox.boardcolor_.hdt;

          const white = tbox.boardcolor_.sd;
          const black = tbox.boardcolor_.dt;
          if (tbox.rating != null) {
            var score = tbox.score_;
            tbox.rating.style.backgroundColor = (reversed) ? white : black;
            tbox.rating.parentNode.style.backgroundColor = (reversed) ? black : white;
          }

          // color move hints
          if (this_.MoveHint_.length > 0) {
             var hint = this_.MoveHint_[this_.MoveHint_.length - 1];
             this_.resetHint(hint.src, false);
             this_.resetHint(hint.dst, false);
          }

          // color tooltip
          const tooltip = this_.header_.getElementsByClassName('tooltip')[0];
          tooltip.style.backgroundColor = tbox.boardcolor_.dt;
          tooltip.style.color = tbox.boardcolor_.hdt; // '#2a2a2a';

          // color message window;
          var msgwin = tbox.msgwin_;
          // msgwin.style.backgroundColor = tbox.boardcolor_.lt;
          msgwin.style.borderColor = tbox.boardcolor_.hdt;
          msgwin.style.color = tbox.boardcolor_.hdt;

     }


     createHeader() {
         // clone header and footer
         this.header_ = chessheader.cloneNode(true);
         this.header_.style.visibility = 'visible';
         this.hdr_player_  = this.header_.getElementsByClassName('playerside')[0]
         this.hdr_elo_     = this.header_.getElementsByClassName('playerelo')[0]
         this.hdr_capture_ = this.header_.getElementsByClassName('playercapture')[0]
         this.hdr_timer_   = this.header_.getElementsByClassName('playertimer')[0]
         const tag =  this.header_.getElementsByTagName('button')[0];
         tag.game_ = this;
     }

     createFooter() {
         this.footer_ = chessfooter.cloneNode(true);
         this.footer_.style.visibility = 'visible';
         this.ftr_player_  = this.footer_.getElementsByClassName('playerside')[0]
         this.ftr_elo_     = this.footer_.getElementsByClassName('playerelo')[0]
         this.ftr_capture_ = this.footer_.getElementsByClassName('playercapture')[0]
         this.ftr_timer_   = this.footer_.getElementsByClassName('playertimer')[0]
         this.ftr_side_    = this.footer_.getElementsByClassName('sidetomove')[0]
     }

     createWindow(id, parent, control) {
         const container = document.createElement('div');
         const tbox = this.ChessBoard.tbox; 
         // const padding = parseInt(tbox.style.padding);
         const paddingL = parseInt(tbox.style.paddingLeft);
         const paddingR = parseInt(tbox.style.paddingRight);
         const paddingT = parseInt(tbox.style.paddingTop);
         const paddingB = parseInt(tbox.style.paddingBottom);
         const width = parseInt(tbox.style.width) + paddingL + paddingR; // padding * 2;
         const height = parseInt(tbox.style.height) + paddingT + paddingB; // padding * 2;
         this.createHeader();
         this.createFooter();
         container.appendChild(this.header_);
         container.appendChild(tbox);
         container.appendChild(this.footer_);
         parent.appendChild(container);
         this.container_ = container;
         container.game_ = this;

         ZINDEX_ ++;
         container.id = 'contr_' + id;
         container.className = 'chesscontainer';
         this.container_.style.top = parseInt(tbox.style.top) + 'px';
         this.container_.style.left = parseInt(tbox.style.left) + 'px';
         this.container_.style.width = width + 'px';
         this.container_.style.height = ( height + 50 )  + 'px';
         this.container_.style.zIndex = ZINDEX_;

         this.container_.style.backgroundColor = tbox.boardcolor_.sd;

         // header & footer
         this.header_.style.height = '25px';
         this.header_.style.width = width + 'px';
         this.footer_.style.height = '25px';
         this.footer_.style.width = width + 'px';
         this.header_.style.cursor = 'pointer';

         this.footer_.style.backgroundColor = tbox.boardcolor_.sd;
         this.header_.style.backgroundColor = tbox.boardcolor_.sd;

         this.header_.style.top = '0px';
         tbox.style.top =  '25px';
         this.footer_.style.top = (height + 25 ) + 'px';

         this.header_.style.left = '0px';
         tbox.style.left  = '0px';
         this.footer_.style.left = '0px';

         // Board & tbox
         this.Board_ = this.ChessBoard.Board;
         this.tbox   = this.ChessBoard.tbox;

         // create tbox cover (to disable accidental movement of mouse
         const tbox_cover = tbox.cloneNode(false); 
         tbox.cover_ = tbox_cover;
         tbox.cover_.style.backgroundColor = 'rgb(150,150,150,0)';
         tbox.cover_.style.visibility = 'hidden';
         container.appendChild(tbox_cover); 

         // chessls link
         this.chessls_ = chessls;

         this.createChessMovesWindow();

         this.createControl(control);

         this.createMsgWindow();

         this.createSideControl();

         this.createSet();

         // mouse events
         container.addEventListener('mouseenter', this.highlightBoard, false);
         container.addEventListener('mouseleave', this.unhighlightBoard, false);

         this.header_.addEventListener('mousedown', this.mouseDownForContainer);
         this.header_.container_ = this.container_
         this.header_.game_ = this;

         document.addEventListener('mouseup', this.mouseUpForAll, false);

         // resize operations
         const resizeContainer = container.cloneNode(false);
         resizeContainer.id = "clonedcontainer";
         resizeContainer.style.backgroundColor = '';
         resizeContainer.style.visibility = 'hidden';
         resizeContainer.style.zIndex = 250000;
         parent.appendChild(resizeContainer);
         this.resizeContainer_ = resizeContainer;

         container.addEventListener('mousedown', this.mouseDownForResize, false);
         container.game_ = this;

         // Clone Promotion template
         this.promo_ = promoteid.cloneNode(true);
         this.promocoll_  = this.promo_.getElementsByClassName('promocontain')
         this.promoblack_ = this.promocoll_[0]
         this.promowhite_ = this.promocoll_[1]

         var next = this.promoblack_.firstChild;
         while (next) {
           if (next.nodeType == 1) { next.onclick = this.promotePiece; next.game_ = this }
           next = next.nextSibling;
         }
         next = this.promowhite_.firstChild;
         while (next) {
           if (next.nodeType == 1) { next.onclick = this.promotePiece; next.game_ = this }
           next = next.nextSibling;
         }
         this.container_.appendChild(this.promo_);

     }

     createSet() {
         var tbox = this.tbox;
         const setpiece = setpositionid.cloneNode(true);
         const pieceid = setpiece.getElementsByClassName('pieceid')[0];
         const width = parseInt(tbox.style.width);
         const padL = parseInt(tbox.style.paddingLeft);
         const padR = parseInt(tbox.style.paddingRight);
         var pieces = ['k','q','b','n','r','p'];
         setpiece.style.top = '30px'
         setpiece.style.left = (width + padL + padR + 3) + 'px';
         setpiece.style.visibility = 'hidden';
         
         for (var p in pieces) {
           const id = parseInt(p);
           const img = document.createElement('img');
           img.src = '/images/rmoo_' + pieces[id] + 'dt.svg';
           img.className = 'setpieces'
           img.style.top = (10 + id * 40) + 'px'; 
           img.style.width = '40px';
           img.style.height = '40px';
           img.role_ = pieces[id].toUpperCase();
           img.color_ = pieces[id] + 'dt';
           img.addEventListener('mousedown', this.mouseDownForSet);
           img.game_ = this;
           setpiece.appendChild(img);
         }

         for (var p in pieces) {
           const id = parseInt(p);
           const img = document.createElement('img');
           img.src = '/images/rmoo_' + pieces[id] + 'lt.svg';
           img.className = 'setpieces'
           img.style.top = (270 + id * 40) + 'px'; 
           img.style.width = '40px';
           img.style.height = '40px';
           img.role_ = pieces[id].toUpperCase();
           img.color_ = pieces[id] + 'lt';
           img.addEventListener('mousedown', this.mouseDownForSet);
           img.game_ = this;
           setpiece.appendChild(img);
         }
         tbox.appendChild(setpiece);
         tbox.setpiece_ = setpiece;
     }

     createMsgWindow() {
         var tbox = this.tbox;
         const msgwin = messagedivid.cloneNode(true);
         const msgid  = msgwin.getElementsByClassName('messageid')[0];   
         var twidth = parseInt(tbox.style.width);
         var theight = parseInt(tbox.style.height);
         var width = parseInt(msgwin.style.width);
         var height = parseInt(msgwin.style.height);
         var left = (twidth - width ) / 2;
         var top = (theight - height ) / 2;
         this.tbox.msgwin_ = msgwin;
         this.tbox.msgid_ = msgid;
         msgwin.style.left = left + 'px';
         msgwin.style.top = top + 'px';
         msgwin.style.visibility = 'hidden';
         // msgwin.style.backgroundColor = tbox.boardcolor_.lt;
         msgwin.style.borderColor = tbox.boardcolor_.hdt;
         msgwin.style.color = tbox.boardcolor_.hdt;
         tbox.appendChild(msgwin);
     }

     createChessMovesWindow() {
        const chessmv = chessmoves.cloneNode(true);
        chessmv.style.zIndex = ZINDEX_;
        chessmv.tag_ = 1;
        this.parent_.appendChild(chessmv);
        this.container_.chessmoves_ = chessmv;
        const notes = chessmv.getElementsByClassName("chessgame")[1];
        this.Notes_ = notes;

        const movebtns = chessmv.getElementsByClassName("chessplaybtn");
        for (var p in movebtns) {
           const btn = movebtns[p];
           if (btn.nodeType == 1) btn.game_ = this;
        }
     }

     createSideControl() {
         const condiv = document.createElement('div');
         condiv.style = 'position: absolute; margin: 0px 0px 0px 0px; background-color: #dedede; box-shadow: 3px 3px 3px 3px rgb(50, 50, 50, 0.5);' +
                        'border: 2px solid #efefef; top: 280px; left: 0px; width: 120px; height: 170px';
         this.container_.appendChild(condiv);

         const icons = [ '&#x1F4CC', '&#x265F;', '&#x25A3', '&#x1F532;', '&#x23F0;', '&#x274C;' ];
         const func  = [ this.pinBoard, this.setPosition, this.setSquare, this.maxSize, this.chooseTimer, this.closeBoard ];
         const title = [ 'Pin To Board', 'Set Position', 'Square Size', 'Maximize Size', 'Timer', 'Close' ];

         for (var i=0; i<6; i++) {
            const ctrl = document.createElement('span');
            const tt = '<span style="font-size: 12px; font-weight: normal; font-family: helvetica">' + title[i] + '</span>';
            ctrl.style = 'position: absolute; cursor: pointer; left: 10px; top: ' + (5 + i * 28) +  'px';
            ctrl.innerHTML = icons[i] + '&nbsp;&nbsp;&nbsp;' + tt;
            ctrl.onclick = func[i];
            ctrl.title = title[i];
            ctrl.game_ = this;
            condiv.appendChild(ctrl);
         }
         condiv.title = 'ToolTips';
         condiv.style.visibility = 'hidden';
         this.sidecontrol_ = condiv;
         condiv.addEventListener('mouseleave', this.leaveMeBeorEnter, false);
     }

     createControl(control) {
         const condiv = document.createElement('div');
         condiv.style = 'position: absolute; margin: 0px 0px 0px 0px; background-color: #dedede; cursor: pointer; ' +
                        'top: -3px; left: -31px; width: 28px; height: 310px';
         this.container_.appendChild(condiv);

         const icons = ['&#x2795;', '&#x1F519;', '&#x1F44E;', '&#x21BB;', '&#x1F3A8;',
			'&#x1F916;', '&#x1F916', '&#x1F4DC;', '&#x1F5C4;', '&#x1F4AC;', '&#x2630' ];
         const func  = [ this.newGame, this.takeBack, this.resignGame, this.reverseBoard, this.chooseColor,
                         this.choosePlayer, this.showPGN, this.loadPosition, this.loadPGN, this.sendMessage, this.MoreTools ];
         const title = [  'New Game', 'Take Back', 'Resign', 'Reverse Board', 'Choose Color',
                         'Choose Player', 'Show Moves', 'Load a Game', 'Load a Database', 'Send Message', 'More Tools' ];

         for (var i=0; i<11; i++) {
            const ctrl = document.createElement('span');
            ctrl.style = 'position: absolute; cursor: pointer; left: 5px; top: ' + (5 + i * 28) +  'px';  // above the board
            if (i == 6) {
               const img = document.createElement('img');
               img.src = '/images/pgn.svg';
               img.style.width='21px';
               ctrl.appendChild(img);
            } else {
               ctrl.innerHTML = icons[i];
            }
            ctrl.onclick = func[i];
            ctrl.title = title[i];
            ctrl.game_ = this;
            ctrl.addEventListener('mouseenter', this.leaveMeBeorEnter, false);
            condiv.appendChild(ctrl); 
         }

         this.control_ = condiv;
         condiv.style.visibility = 'visible';
         if (control) condiv.style.visibility = 'hidden';


     }

     sendMessage() {
      var this_ = this.game_;
         log("send message ...");
         socket.on("responded", function(msg) {
             log("I got a response ...:" + msg);
         });
         socket.emit("move", "get it now ...");
     }

     MoreTools() {
      var this_ = this.game_;
      if (this_ != null && this_.sidecontrol_ != null) {
          this_.disablePopups();
          const vis = this_.sidecontrol_.style.visibility;
          this_.sidecontrol_.style.visibility = (vis == 'visible') ? 'hidden' : 'visible';
      }
     }

     leaveMeBeorEnter(e) {
        e.preventDefault();
        var this_ = this.game_;
        var color, analyze, database;
        if (this.title == 'Choose Color') {
           analyze = document.getElementById('chooseanalyzeid_' + this_.id);
           database = document.getElementById('choosedatabaseid_' + this_.id);
           if (analyze != null) analyze.style.visibility = 'hidden';
           if (database != null) database.style.visibility = 'hidden';
        } else
        if (this.title == 'Load a Game') {
           color = document.getElementById('choosecolorid_' + this_.id);
           database = document.getElementById('choosedatabaseid_' + this_.id);
           if (color != null) color.style.visibility = 'hidden';
           if (database != null) database.style.visibility = 'hidden';
        } else
        if (this.title == 'Load a Game') {
           color = document.getElementById('choosecolorid_' + this_.id);
           analyze = document.getElementById('chooseanalyzeid_' + this_.id);
           if (color != null) color.style.visibility = 'hidden';
           if (analyze != null) analyze.style.visibility = 'hidden';
        } else
        if (this.title == 'ToolTips') {
           this.style.visibility = 'hidden';
        }
     }

     minimizeControl() {
         var this_  = this.condiv_;
         var c = this_.style.visibility;
         this_.style.visibility = (c == 'hidden') ? 'visible' : 'hidden';
     }

     showPGN(e, oper = 0) {
       if(!e.detail || e.detail == 1){
         e.preventDefault();
         var this_  = this.game_;
         if (document.containergame_) {
          this_ = document.containergame_;
         } else
         if (document.resizegame_) {
          this_ = document.resizegame_;
         } else
         if (document.setsquaregame_) {
          this_ = document.setsquaregame_;
         }
         var pos    = scrollOffset(e);
         var hdrh_  = parseInt(this_.header_.style.height);
         var cbdr_  = parseInt(this_.container_.style.borderWidth);
         var width  = parseInt(this_.container_.style.width);
         var height = parseInt(this_.container_.style.height);
         var top    =  parseInt(this_.container_.style.top);
         var left  =  parseInt(this_.container_.style.left);
         var bottom = this_.container_.offsetTop + height + cbdr_ * 2;
         var chessmv = this_.container_.chessmoves_;

         const btns = chessmv.getElementsByClassName('chessmovesbtn');

         if (chessmv.tag_ == 3 && oper) {  // for move & resize operations
            chessmv.style.width= ( width + cbdr_ * 2) + 'px';
            chessmv.style.height= '250px';
            chessmv.style.top = bottom + 'px';
            chessmv.style.left = left + 'px'
         } else 
         if ((chessmv.tag_ == 4) && oper) { // for move & resize operations
            chessmv.style.width= '450px';
            chessmv.style.height= ( height + cbdr_ * 2) + 'px';
            chessmv.style.top = top + 'px';
            chessmv.style.left = (this_.container_.offsetLeft + width + cbdr_ * 2)  + 'px';
         } else
         if (!oper && (chessmv.tag_ == 1 || chessmv.tag_ == 2)) {
            chessmv.style.visibility = 'visible';
            btns[0].style.visibility = 'visible';
            chessmv.style.width= ( width + cbdr_ * 2) + 'px';
            chessmv.style.height= '250px';
            chessmv.style.top = bottom + 'px';
            chessmv.style.left = left + 'px';
            chessmv.tag_ = 3;
          } else
         if (!oper && chessmv.tag_ == 3)  {
            chessmv.style.visibility = 'visible';
            btns[0].style.visibility = 'visible';
            chessmv.style.width= '450px';
            chessmv.style.height= ( height + cbdr_ * 2) + 'px';
            chessmv.style.top = top + 'px';
            chessmv.style.left = (this_.container_.offsetLeft + width + cbdr_ * 2)  + 'px';
            chessmv.tag_ = 4;
         } else 
         if (!oper && chessmv.tag_ == 4)  {
            chessmv.style.visibility = 'hidden';
            btns[0].style.visibility = 'hidden';
            chessmv.tag_ = 2;
         }
        }
     }

     disablePopups() {
          var pops = document.getElementsByClassName('popupdiv');
          for (var p in pops) {
             if (pops[p].nodeType == 1) {
                  pops[p].style.visibility = 'hidden';
             }
          }
          this.sidecontrol_.style.visibility = 'hidden';
     }

     chooseColor(e) {
       if(!e.detail || e.detail == 1){
         e.preventDefault();
         var this_ = this.game_;
       //  var top = 0;
       //  var left = parseInt(this.style.left.replace(/px/,'')) - 10;
         this_.disablePopups();
         var top = this.offsetTop + this.parentNode.offsetTop;
         var left = parseInt(this.style.left.replace(/px/,'')) - 10;
         chooseBoardColor( this_, { y: top, x: left } ); // references external function
        }
     }

     changeBoardColor() { // this is internal function. Don't confuse with the external one
         var this_ = this.game_;
         var color = this.value_;
         this_.colorBoard(this_, color);
     }

     highlightBoard(e) {
         e.preventDefault();
         if (typeof(document.resizegame_) != "undefined") return;
         var this_ = this.game_
         var color = this_.tbox.boardcolor_.lt;
         this.style.border = '3px solid ' + color; 
     }

     unhighlightBoard(e) {
         e.preventDefault();
         if (typeof(document.resizegame_) != "undefined") return;
         var this_ = this.game_
         var color = this_.tbox.boardcolor_.sd;
         this.style.border = '3px solid ' + color; 
         this_.disablePopups();
     }

     repositionBoard(fen, this_) {  // using  UCI-fen
            if (fen == null) return;
            this_.quiesce_system(this_);
            this_.initializeBoard(this_);
            this_.positionBoard(fen, this_);
     }

     initializeBoard(this_) {
         var Board = this_.ChessBoard.Board;
         // Initialize Board
         for (var p in Board) {
            const board = Board[p];
            const img_ = getImage(board.td_); 
            if (img_ != null) { board.td_.removeChild(img_); }
            delete board.piece;
            board.piece = null;
         }
     }

     positionBoard(fen, this_) {  // using  UCI-fen
            if (fen == null) return;
            const ranks = fen.split(' ')[0].split('/');
            const Board = this_.ChessBoard.Board;
            const tbox  = this_.ChessBoard.tbox;
            for (var r in ranks) {
                const pieces = ranks[r];
                const rank = 8 - parseInt(r);
                var v = 0;
                for (var p in pieces) {
                  var role = null, color = null, location = null;
                  const piece = pieces[p];
                  location = horiz[v] + rank;
                  if (piece.match(/[RNBQKP]/)) { // lt
                     role = piece.toUpperCase();
                     color = piece.toLowerCase() + 'lt';
                     v++;
                  } else
                  if (piece.match(/[rnbqkp]/)) { // dt
                     role = piece.toUpperCase();
                     color = piece.toLowerCase() + 'dt';
                     v++;
                  } else {
                     const spaces = parseInt(piece);
                     v +=  (spaces );
                  }
                  if (role != null) {
                     const new_piece = new this.Piece(this, role, color, location);
                     Board[location].piece = new_piece;
                     Board[location].td_.appendChild(new_piece.img_);
                  }
              }
           }
           if (tbox.reversed_) {
              this_.reverseBoard(null, this_);
           }
     }

     quiesce_system(this_, keep_moves = false) {
         var Bench = this_.ChessBoard.Bench;
         var Undo_ = this_.Undo_;
         var MoveHint_ = this_.MoveHint_;
         var Moves_ = this_.Moves_;
         var RepeatDraw_ = this_.RepeatDraw_;

         // quiesce engine
         if (this_.enginetime != null || this_.int_engine) {
             clearInterval(this_.enginetime);
             this_.int_engine = 0;
         }

         // clear timer
         this_.ftr_timer_.innerHTML = padTime(this.PLAYTIME_);
         this_.hdr_timer_.innerHTML = padTime(this.PLAYTIME_);
         if (this_.GAME_STATE.ptimer_ != null) {
            clearInterval(this_.GAME_STATE.ptimer_);
         }
         this_.WTIMER_ = Object.assign({}, this_.INIT_TIMER_);
         this_.BTIMER_ = Object.assign({}, this_.INIT_TIMER_);

         // reset Hints;
         if (MoveHint_.length > 0) {
            var hint = MoveHint_[MoveHint_.length - 1];
            this_.resetHint(hint.src);
            this_.resetHint(hint.dst);
         }

         // clear queues
         while (Bench.length) { Bench.pop(); }
         while (Undo_.length) { Undo_.pop(); }
         while (MoveHint_.length) { MoveHint_.pop(); }
         if (!keep_moves) while (Moves_.length) { Moves_.pop(); }
         while (RepeatDraw_.length) { RepeatDraw_.pop(); }

         // clear states
         this_.GAME_STATE = Object.assign({}, this_.INIT_STATE);
         this_.statusGame(true);

         // clear moves
         if (!keep_moves) {
           const Notes = this_.Notes_;
           while (Notes.firstChild) Notes.removeChild(Notes.firstChild);
         }

         // clear popups
         this_.disablePopups();   
         this_.tbox.msgwin_.style.visibility = 'hidden';
     }

     mouseDownForContainer(e)  {
       e.preventDefault();
       if(!e.detail || e.detail == 1) {
           var this_ = this.game_;
           var pos = scrollOffset(e, false);
           var offsetLeft = this_.parent_.offsetLeft + pos.x;
           var offsetTop = this_.parent_.offsetTop + pos.y;
           var contrs = this_.parent_.getElementsByClassName('chesscontainer');
           var len = contrs.length;
           this.container_.startPosX = offsetLeft + this.offsetLeft + e.clientX;
           this.container_.startPosY = offsetTop + this.offsetTop + e.clientY;
           document.addEventListener('mousemove', this_.mouseMoveForContainer, false);
           document.containergame_ = this_;
           document.targetmove_ = this;
       }
     }

     mouseMoveForContainer(e) {
           e.preventDefault();
           if (typeof(this.targetmove_) == "undefined") return;
           var this_ = this.targetmove_;
           var contr = this_.container_;
           var pos = scrollOffset(e), x = pos.x, y = pos.y;
           contr.newPosX   = contr.startPosX - x;
           contr.newPosY   = contr.startPosY - y;
           if (contr.offsetTop - contr.newPosY < 5) {  return; }
           if (contr.offsetLeft - contr.newPosX < 5) {  return;  }
           contr.startPosX = x;
           contr.startPosY = y;

           contr.style.top  = (contr.offsetTop - contr.newPosY) + "px";
           contr.style.left = (contr.offsetLeft - contr.newPosX) + "px";
           document.containergame_.showPGN(e, 1);
      }

      mouseUpForAll(e) {
           e.preventDefault();
           if (typeof(document.containergame_) != "undefined") {
              var this_ = document.containergame_;
              this_.showPGN(e, 1);
              this_.postScore();
              document.removeEventListener('mousemove', document.containergame_.mouseMoveForContainer);
              delete document.containergame_;
           } else
           if (typeof(document.resizegame_) != "undefined") {
              var this_ = document.resizegame_;
              this_.resizeBoard(e);
              this_.showPGN(e, 1);
              this_.postScore();
              document.removeEventListener('mousemove', document.resizegame_.mouseMoveForResize);
              delete document.resizegame_;
           } else
           if (typeof(document.movegame_) != "undefined") {
              var this_ = document.movegame_;
              this_.playHuman();
              document.removeEventListener('mousemove', document.movegame_.mouseMove);
              delete document.movegame_;
           } else
           if (typeof(document.setgame_) != "undefined") {
              var this_ = document.setgame_;
              this_.setPiece();
              document.removeEventListener('mousemove', document.setgame_.mouseMoveForSet);
              delete document.setgame_;
           }
      }

      mouseDownForResize(e) {
         e.preventDefault();
         if(!e.detail || e.detail == 1) {
           var this_ = this.game_;
           var hdrh_ = parseInt(this_.header_.style.height);
           var cbdr_ = parseInt(this.style.borderWidth);
           var width = parseInt(this_.container_.style.width);
           var height = parseInt(this_.container_.style.height);
           var right = this.offsetLeft + width + cbdr_ * 2;
           var bottom = this.offsetTop + height + cbdr_ * 2;
           var pos = scrollOffset(e), lim_ = 35;
           if ((pos.x > right - lim_ && pos.x < right + lim_) &&
               (pos.y > bottom - lim_ && pos.y < bottom + lim_)) {
                this.startPosX = pos.x;
                this.startPosY = pos.y;
                document.addEventListener("mousemove", this_.mouseMoveForResize, false);
                document.targetmove_ = this;
                document.resizegame_ = this_;

                // Use resize container
                const res_ctrl = this_.resizeContainer_;
                res_ctrl.style.top = this.style.top;
                res_ctrl.style.left = this.style.left;
                res_ctrl.style.visibility = 'visible';
                res_ctrl.style.border = '3px dashed #ff0000';
                this.initWidth = parseInt(res_ctrl.style.width);
                this.initHeight = parseInt(res_ctrl.style.height);
           }

          const con_ = this_.container_;
          ZINDEX_ ++;
          con_.style.zIndex = ZINDEX_;
          con_.chessmoves_.style.zIndex = ZINDEX_;
          chessdiv.game_ = this_; // helps key strokes identify current game.
         }
     }

     mouseMoveForResize(e) {
           e.preventDefault();
           if (typeof(this.targetmove_) == "undefined") return;
           if (typeof(this.resizegame_) == "undefined") return;
           var this_   = this.targetmove_; // container
           var game_   = this.resizegame_; // container
           const res_ctrl = game_.resizeContainer_;
           var width_  = parseInt(res_ctrl.style.width);
           var height_ = parseInt(res_ctrl.style.height);
           var pos = scrollOffset(e);
           if (pos.x < res_ctrl.offsetLeft + 300 || pos.y < res_ctrl.offsetTop + 300) return;
           if (pos.x > res_ctrl.offsetLeft + 1124 || pos.y > res_ctrl.offsetTop + 1124) return;
           this_.newPosX = this_.startPosX - pos.x;
           this_.newPosY = this_.startPosY - pos.y;
           this_.startPosX = pos.x;
           this_.startPosY = pos.y;
           res_ctrl.style.width = ( width_ - this_.newPosX ) + 'px';
           res_ctrl.style.height = ( height_ - this_.newPosY ) + 'px';
     }

     resizeBoard(e) {
         var this_ = null 
         if (document.setsquaregame_) {
           this_ = document.setsquaregame_;
         } else {
         if (document.resizegame_);
           this_ = document.resizegame_;
         }
         var ctrl_ = this_.container_;
         var res_ctrl_ = this_.resizeContainer_;
         var tbox  = this_.tbox;
         var Board = this_.ChessBoard.Board;
         var Bench = this_.ChessBoard.Bench;
         var brdr_ =  parseInt(res_ctrl_.style.borderWidth);
         var minX = ctrl_.initWidth - parseInt(res_ctrl_.style.width);
         var minY = ctrl_.initHeight - parseInt(res_ctrl_.style.height);
         var new_width = parseInt(this_.tbox.style.width) - minX;
         var new_height = parseInt(this_.tbox.style.height) - minY;
         // var padding = parseInt(tbox.style.padding);
         var paddingL = parseInt(tbox.style.paddingLeft);
         var paddingR = parseInt(tbox.style.paddingRight);
         var paddingT = parseInt(tbox.style.paddingTop);
         var paddingB = parseInt(tbox.style.paddingBottom);

         // resize tboxes
         tbox.style.width = new_width + 'px';
         tbox.style.height = new_height + 'px';
         tbox.cover_.style.width = new_width + 'px';
         tbox.cover_.style.height = new_height + 'px';

         // resize cells in board
         var new_cellwidth =  ( parseInt(tbox.style.width) - (paddingL + paddingR) ) / 8 ;
         var new_cellheight = ( parseInt(tbox.style.height) - (paddingT + paddingB) ) / 8;
         this_.cellwidth = new_cellwidth;
         this_.cellheight = new_cellheight;
         this_.header_.style.width = (new_width + (paddingL + paddingR)) + 'px';
         this_.footer_.style.width = (new_width + (paddingL + paddingR)) + 'px';
         this_.footer_.style.top = (new_height + (paddingT + paddingB) + 25) + 'px';
         for (var p in Board) {
             const board = Board[p];
             const td = board.td_;
             const img = getImage(board.td_);
             td.parentNode.style.width = new_cellwidth + 'px';
             td.parentNode.style.height = new_cellheight + 'px';
             td.style.width =  new_cellwidth  + 'px';
             td.style.height = new_cellheight + 'px';
             if (img != null) {
               img.style.width =  new_cellwidth  + 'px';
               img.style.height = new_cellheight + 'px';
             }
            
         }

         // resize cells in bench
         for (var p in Bench) {
            const board = Bench[p];
            if (board.piece != null) {
                const td = board.td_;
                const img = getImage(board.td_);
                td.parentNode.style.width = new_cellwidth + 'px';
                td.parentNode.style.height = new_cellheight + 'px';
                td.style.width =  new_cellwidth  + 'px';
                td.style.height = new_cellheight + 'px';
                if (img != null) {
                  img.style.width =  new_cellwidth  + 'px';
                  img.style.height = new_cellheight + 'px';
                }
             }
         }

         // Reposition message windows
         const msg = tbox.msgwin_;
         var twidth = parseInt(this_.tbox.style.width);
         var theight = parseInt(this_.tbox.style.height);
         var width = parseInt(msg.style.width);
         var height = parseInt(msg.style.height);
         var left = (twidth - width ) / 2;
         var top = (theight - height ) / 2;
         msg.style.left = left + 'px';
         msg.style.top = top + 'px';

         ctrl_.style.width = res_ctrl_.style.width;
         ctrl_.style.height = res_ctrl_.style.height;
         res_ctrl_.style.visibility = 'hidden';

         // reposition setpiece
         tbox.setpiece_.style.left = (parseInt(tbox.style.width) + paddingL + paddingR + 3) + 'px';

         // disable capture display for small board sizes
         if (parseInt(res_ctrl_.style.width) < 350) {
             this_.hdr_capture_.style.visibility = 'hidden';
             this_.ftr_capture_.style.visibility = 'hidden';
         } else {
             this_.hdr_capture_.style.visibility = '';
             this_.ftr_capture_.style.visibility = '';
         }
       
     }

     RBOARDNUM_ = { a8: 8, a7: 7, a6: 6, a5: 5, a4: 4, a3: 3, a2: 2, a1: 1 }
     BBOARDNUM_ = { a1: 1, b1: 2, c1: 3, d1: 4, e1: 5, f1: 6, g1: 7, h1: 8 }

     reverseBoard(e, game = null) {
         var this_ = (game != null) ? game : this.game_;
         var Board = this_.ChessBoard.Board;
         var Bench = this_.ChessBoard.Bench;
         var tbox  = this_.ChessBoard.tbox;
         var hints = this_.MoveHint_;
         var temp_board_ = {};
         tbox.style.visibility = "hidden";
         for (var p in Board) {
            var board = Board[p];
            const b_ = document.createElement('div');
            const img = getImage(board.td_);
            if (img != null) {
               b_.appendChild(img);
               temp_board_[board.td_.id] = { div: b_ } 
            }

         }
         for (var p in temp_board_) {
             var board = temp_board_[p];
             var revLoc = reverseLoc(p);
             Board[revLoc].td_.appendChild(board.div.firstChild);
         }
         if (game == null) tbox.reversed_ = !tbox.reversed_;
         if (hints.length > 0) {
            const last = hints[hints.length - 1];
            var rvs_src_ = reverseLoc(last.src);
            var rvs_dst_ = reverseLoc(last.dst);

            this_.resetHint(last.src, false);
            this_.resetHint(last.dst, false);
            this_.resetHint(rvs_src_);
            this_.resetHint(rvs_dst_);
         }

         // Reverse Numbers
         for (var i=8; i>=1; i--) {
            var anum = Board['h' + i].td_.anum_;
            var bnum = Board[horiz[8-i] + 1].td_.bnum_;
            anum.innerHTML = (tbox.reversed_) ? (9 - i) : i; 
            bnum.innerHTML = (tbox.reversed_) ? horiz[i - 1] : horiz[ 8 - i]; 
         }

         // infoHeader(game);
         // setRate();
         this_.reversePlayers();
         this_.postScore();
         tbox.style.visibility = "visible";
     }

     reversePlayers() {
         var reversed = this.tbox.reversed_;
         var p = null, e = null, c = null, t = null;
         p = this.hdr_player_.innerHTML;
         e = this.hdr_elo_.innerHTML;
         c = this.hdr_capture_.innerHTML;
         t = this.hdr_timer_.innerHTML;
         this.hdr_player_.innerHTML = this.ftr_player_.innerHTML;
         this.hdr_elo_.innerHTML = this.ftr_elo_.innerHTML;
         this.hdr_capture_.innerhTML = this.ftr_capture_.innerHTML;
         this.hdr_timer_.innerHTML = this.ftr_timer_.innerHTML;
         this.ftr_player_.innerHTML = p;
         this.ftr_elo_.innerHTML = e;
         this.ftr_capture_.innerHTML = c;
         this.ftr_timer_.innerHTML = t;

     }

     pinBoard(e) {
      if(!e.detail || e.detail == 1){
         e.preventDefault();
         var this_ = this.game_;
         pinCube(this_.id);  
       }
     }
 
     setPosition(e) {
      if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
          var tbox = this_.tbox;
          this_.quiesce_system(this_);
          this_.initializeBoard(this_);
          tbox.setpiece_.style.visibility = 'visible';
          this_.GAME_STATE.status_ = STATUS.SET;
          this_.statusGame();
log(this_.GAME_STATE.sidetomove_);
      }
     }

     setSquare(e) {
      if(!e.detail || e.detail == 1){
       e.preventDefault();
       var this_  = this.game_;
       var res_ctrl_ = this_.resizeContainer_;
       var rwidth  = parseInt(res_ctrl_.style.width);
       var rheight = parseInt(res_ctrl_.style.height);
       var width  = parseInt(this_.tbox.style.width);
       var height = parseInt(this_.tbox.style.height);
       var size = (width < height) ? width : height;
       var minX = size - width;
       var minY = size - height;
       this_.container_.initWidth = rwidth;
       this_.container_.initHeight = rheight;
       res_ctrl_.style.visibility = 'visible';
       res_ctrl_.style.width =  (rwidth + minX) + 'px';
       res_ctrl_.style.height = (rheight + minY)  + 'px';
       document.setsquaregame_ = this_;
       this_.resizeBoard(e);
       this_.showPGN({ detail: 1, preventDefault: function() {}} , 1);
       this_.postScore();
       delete document.setsquaregame_;
      }
     }

     maxSize(e) {
      if(!e.detail || e.detail == 1){
       e.preventDefault();
       var this_ = this.game_;
       var ctrl_ = this_.container_;
       var res_ctrl_ = this_.resizeContainer_;
       var rwidth  = parseInt(res_ctrl_.style.width);
       var rheight = parseInt(res_ctrl_.style.height);
       var width  = parseInt(this_.tbox.style.width);
       var height = parseInt(this_.tbox.style.height);
       var size = (width < height) ? width : height;
       var psize = pageSize();
       var minX = (psize.height - 125)  - width;
       var minY = (psize.height - 125) - height;
       this_.container_.initWidth = rwidth;
       this_.container_.initHeight = rheight;
       res_ctrl_.style.visibility = 'visible';
       res_ctrl_.style.width =  (rwidth + minX) + 'px';
       res_ctrl_.style.height = (rheight + minY)  + 'px';

       document.setsquaregame_ = this_;
       this_.resizeBoard(e);
       this_.showPGN({ detail: 1, preventDefault: function() {}} , 1);
       this_.postScore();

       ctrl_.style.top = '25px';
       res_ctrl_.style.top = '35px';
       this_.showPGN({ detail: 1, preventDefault: function() {}} , 1);
       this_.postScore();
       delete document.setsquaregame_;
      }
     }

     chooseTimer(e) {
      if(!e.detail || e.detail == 1){
       e.preventDefault();
       var this_ = this.game_;
log("choose timer");
      }
     }

     closeBoard(e) {
      if(!e.detail || e.detail == 1){
       e.preventDefault();
       var this_ = this.game_;
log("close board");
      }
     }

     loadPGN(e) {
       if(!e.detail || e.detail == 1){
         e.preventDefault();
         var this_ = this.game_;
         this_.disablePopups();
         // var top = 0;
         //var left = parseInt(this.style.left.replace(/px/,'')) - 70;
         var top = this.offsetTop + this.parentNode.offsetTop;
         var left = parseInt(this.style.left.replace(/px/,'')) - 10;
         chooseDatabase( this_, { y: top, x: left } );
       }
     }

     LOADINGPGN_ = false
     pgntime = null
     changeDatabase() {
          var this_ = this.game_;
          var pgn = this.value_;
          const pgn_ = "/pgn/" + pgn + ".pgn";
          if (this_.LOADINGPGN_) return;
          this_.LOADINGPGN_ = true;
          this_.pgn_interval = 0;
          this_.pgntime = setInterval(this_.readyPGN, 50, this_, pgn_);
     }

     pgn_interval = 0
     readyPGN(this_, pgn_) {
          if (this_.pgn_interval > 20) { 
		this_.pgn_interval = 0; clearInterval(this_.pgntime); 
		message(this_, "Loading database ...", false); 
		this_.fetchPGN(this_, pgn_);
                return  
           }
          this_.pgn_interval ++;
          if (this_.LOADPGN_ == false) {
              this_.pgn_interval = 0;
              clearInterval(this_.pgntime);
              message(this_, "Loading database ...", false);
              this_.fetchPGN(this_, pgn_);
          }
     }

     Games = []
     async fetchPGN(this_, pgn_){
          const res = await fetch(pgn_);
          const pgngame = await res.json();
          this_.Games = [];
          class Game {
             constructor (game) {
                var moves_ = game.moves.split(' ').length - 4; moves_ = Math.ceil(moves_ / 2);
                game.ct = moves_;
                this.detail_ = game;
             }
             get detail()  { return this.detail_; }
          }

          for (let i=0; i < pgngame.length; i++) {
               const game = new Game(pgngame[i])
               this_.Games.push(game.detail)
          }
          chessdiv.loadedgame_ = this_;
          await refreshListing(this_, this_.Games);
          this_.LOADINGPGN_ = false;

          showPGNWindow(null, true);

          // cover board for mouse movement
          this_.tbox.cover_.style.visibility = 'visible';

          // clear old database (for now )
          for (var p in this_.PGNDB_) {
              delete this_.PGNDB_[p];
          }
          this_.PGNDB_ = {};
     }

     // CURRENT_GAME_ = 0
     CONTINUOUS_PLAY_ = false
     CONTINUOUS_INTERRUPTED = false
     async continuousPlay(spn) {
          var this_ = this;
log("playing status ...");
log(this_.GAME_STATE.playstatus_);
           // interrupt async playing ...
           if (this_.GAME_STATE.playstatus_ == STATUS.PLAYING || this_.CONTINUOUS_PLAY_) { 
		this_.GAME_STATE.playstatus_ = STATUS.INTERRUPTED; 
	        return;
           }
           var Games = this_.Games;
           var len_ = Games.length, current_ = 0;
           if (this_.tbox.prevgame_ != null) current_ = parseInt(this_.tbox.prevgame_.value);
           if (Games.length == 0) { message(this_, "No database loaded!", false); return; }
           //   chess_awalker.playbackRate = 1.0;
           //   chess_awalker.currentTime = 1.0;
           //   chess_awalker.play();
            //  this_.GAME_STATE.playstatus_ = STATUS.PLAYING;
           this_.CONTINUOUS_PLAY_ = true;
           spn.innerHTML = '&#x26AC;';
           for (var i = current_; i < len_; i++) {
               const bt = document.getElementById("gameid_" + i);
               await bt.onclick(null); 
               if (this_.CONTINUOUS_INTERRUPTED) break;
               if (this_.GAME_STATE.playstatus_ == STATUS.INTERRUPTED) break;
           }
           this_.CONTINUOUS_INTERRUPTED = false;
           this_.GAME_STATE.playstatus_ = STATUS.STOPPED;
           this_.CONTINUOUS_PLAY_ = false;
           spn.innerHTML = '&#x25B6';
     }

     whichSound(restype) {
        if (restype == GOODMOVE) { chess_move.currentTime = 0; chess_move.play(); return; }; 
        if (restype == EATPIECE || restype == ENPASSANT) { chess_capture.currentTime = 0; chess_capture.play(); return; }; 
        if (restype == CASTLESHORT || restype == CASTLELONG) { chess_castle.currentTime = 0; chess_castle.play(); return; }; 
        chess_move.currentTime = 0; chess_move.play();
     }

     async playNext(e) {
        if(!e.detail || e.detail == 1) {
          e.preventDefault();
          var this_ = this.game_;
          var node = this.parentNode.parentNode;
          var prevgame_ = this_.tbox.prevgame_;
          if (e!= null && this_.CONTINUOUS_PLAY_) { this_.GAME_STATE.playstatus_ = STATUS.INTERRUPTED; this_.IN_NEXTPLAY_ = false;  return }
          // playing next game
          if (prevgame_ != null) {
                var node1 = prevgame_.parentNode.parentNode;
                if (prevgame_.id != this.id) {
                     this.game_.GAME_STATE.playstatus_ = STATUS.STOPPED;
                     // reset previous game
                     node1.className = 'chesstr';
                     prevgame_.innerHTML = "&#8594;";
log("must 0 ...");
                     // set current game
                     this.innerHTML = "&#9675;"
                     node.className = 'chesstr chesstrcurrent';

                     this.game_.tbox.prevgame_ = this;
                     await this.game_.play(this.value, this_.MUSIC_TIME);
                     this.innerHTML = "&#8594;";
                     node.className = 'chesstr';
log("must 1 ...");
                     return;
                }
          }
          // replaying current game
          if (this.game_.GAME_STATE.playstatus_ ==  STATUS.PLAYING) {
                this.game_.GAME_STATE.playstatus_ = STATUS.INTERRUPTED;
                this.innerHTML = "&#8594;"
                node.className = 'chesstr';
          } else {
                this.game_.tbox.prevgame_ = this;
                this.innerHTML = "&#9675;"
                node.className = 'chesstr chesstrcurrent';
                // this.game_.CURRENT_GAME_ = this.value;
log("must 2 ...");
                await this.game_.play(this.value, this.game_.MUSIC_TIME);
                this.innerHTML = "&#8594;"
                node.className = 'chesstr';
log("must 3 ...");
          }
        }
     }


     PGNDB_ = {}
     MUSIC_TIME = 330.924;
     async play(value, MUSIC_TIME = null) {
       const this_ = this;
       const notes = this_.Notes_;
       var current_ = this_.Games[value];
       if (typeof(this_.PGNDB_[value]) == "undefined") {
          this_.newGame(null, this_, false);
          this_.recordPlayers(current_);
          var fens = await this_.recordFEN(value);
          this_.PGNDB_[value] = fens;
       } else { chess_reset.currentTime = 0; chess_reset.play();  }
       const mymoves = this_.PGNDB_[value];
       if (this_.GAME_STATE.playstatus_ == STATUS.STOPPED) {
          this_.GAME_STATE.playstatus_ = STATUS.PLAYING;
          this_.recordPlayers(current_);
          this_.quiesce_system(this_, false);
          this_.initializeBoard(this_);
          this_.positionBoard(wINITFEN_, this_);
          await this_.setMoves(this_, current_.moves);
          current_ = null;
          await pause(1000);
       }
       this_.GAME_STATE.gamecurrent_  = value;
       this_.GAME_STATE.playstatus_ = STATUS.PLAYING;
       for (var p in mymoves) {
           current_ = await this_.jumpMove(null, p);
           this_.GAME_STATE.playcurrent_  = p;
           await pause(500);
           if (this_.GAME_STATE.playstatus_ == STATUS.INTERRUPTED ||
             this_.GAME_STATE.playstatus_ == STATUS.STOPPED)  return;
       }
       this_.GAME_STATE.playstatus_ = STATUS.STOPPED;
     }

     async recordFEN(value) {
         const fens_ = [];
         const this_ = this;
         var cnt = 0, fen = null;
         var current_ = this_.Games[value];

         this_.quiesce_system(this_, true);
         this_.initializeBoard(this_);
         this_.positionBoard(wINITFEN_, this_);

         await this_.setMoves(this_, current_.moves); 

         for (var p in this_.Moves_) {
            const move = this_.Moves_[p];
            const turn = this_.simpleMove(this_, move, null);
            const restype = await this_.captureMove(this_.Board_, turn, HUMAN, false, false, true);
            fen = generateFEN(this_, this_.GAME_STATE.sidetomove_ == WHITE ? 'w' : 'b');
            fens_.push({ fen: fen, turn: turn, restype: restype });
         }
         return fens_;
     }


     highlightMove(notes, p, lastmove = null) {
          var elem = null, move = null
          if (lastmove != null) {
             elem = notes.childNodes[lastmove];
             move = elem.firstChild.nextSibling;
             move.className = 'chesspiecenomove';
          }
          elem= notes.childNodes[p];
          move = elem.firstChild.nextSibling;
          move.className = 'chesspiecemove';
          return move;
     }

     simpleMove(this_, turn, player = null) {
        var src_loc = null, dest_loc = null, role = null, src = null, hint = null;
        var move = turn.move.replace(/^[0-9]+\./,'');
        var color = turn.side;
        var promote = turn.promote;
        var len = move.length;
        role = move[0];
        dest_loc = move.slice(-2);

        if ( move.match(/(=)?(\([qbnr]\)|[qbnr])$/i) ) {
             promote = move.match(/(=)?(\([qbnr]\)|[qbnr])$/i)[0].replace(/[=()]/g,'');
             move = move.replace(/(=)?(\([qbnr]\)|[qbnr])$/i, '');
        }

        if (player == MACHINE || player == HUMAN) {
            src_loc  = move.slice(0, move.length - 2);
            dest_loc = move.slice(-2);
        } else
        if (move == "O-O") {
             src_loc = [ (color == 'lt') ? "e1" : "e8" ]; dest_loc = (color == 'lt') ? "g1" : "g8";
        } else
        if ( move == "O-O-O") {
             src_loc = [ (color == 'lt') ? "e1" : "e8" ]; dest_loc = (color == 'lt') ? "c1" : "c8";
        } else if (len == 2) {
             dest_loc = move;
             src_loc = find_location(this_, color, move[0], dest_loc);
        } else if (len == 3) {
             src_loc = find_location(this_, color, role, dest_loc);
        } else
        if (len == 4) { // e.g. Rxe1 exd1 Rhe1
             hint = move[1];
             if (hint != 'x') { hint = null; src = move[1]; }
             src_loc = find_location(this_, color, role, dest_loc, hint, src);
        } else
        if (len == 5) { // e.g. Rhxe1 R8xe1  Nh8g6
             hint = move[2];
             if (hint == 'x') {
                   src = move[1];
             } else {
                   hint = null;
                   src = move.slice(1,3).match(/[a-h][1-8]/)[0]
             }
             src_loc = find_location(this_, color, role, dest_loc, hint, src);
        } else
        if (len == 6) { // e.g. Rh8xe1
             src = move.slice(1,3); hint = move[3];
             src_loc = find_location(this_, color, role, dest_loc, hint, src);
        }
        log("Final " + color + " location: " + src_loc + " " + dest_loc + " " + promote);
        if (typeof(src_loc) != "string" && src_loc.length ==1) src_loc = src_loc[0];
        return { src: src_loc, dst: dest_loc, promote: promote };
    }

     beautifyMove(move) {
           return move.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                       replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                       replace(/R/g,'&#9814;');
     }

     setMoves(this_, moves_) {
         const parsed_ = parser.parse(moves_);
         const pmoves = parsed_[0];
         var moves = moves_.split(' ');

         var RS_ = null;
         if (parsed_[1] != "1-0" && parsed_[1] != "0-1" && parsed_[1] != "1/2-1/2") {
             pmoves.push([parsed_[1],['']]);
         } else {
             RS_ = parsed_[1];
         }

         this_.GAME_STATE.sidetomove_ = WHITE;
         this_.GAME_STATE.movecount_ = 0;
         for (var m in pmoves) {
            const move = pmoves[m][0];
            const wmove = move[2][0];
            const wprom = move[2][1].replace(/[=()]/g,'');
            const wchk = move[2][2];
            const wcmt = move[2][3];
            this_.recordMove(wmove, wprom, wchk, wcmt); 
            this_.GAME_STATE.sidetomove_ = (this_.GAME_STATE.sidetomove_ == WHITE) ? BLACK : WHITE;
            if (typeof(move[4]) == "object") {
              const bmove = move[4][0];
              const bprom = move[4][1].replace(/[=()]/g,'');
              const bchk = move[4][2];
              const bcmt = move[4][3];
              this_.recordMove(bmove, bprom, bchk, bcmt); 
              this_.GAME_STATE.sidetomove_ = (this_.GAME_STATE.sidetomove_ == WHITE) ? BLACK : WHITE;
            } else {
               RS_ = (RS_ != null) ? RS_ : move[4];
               break;
            }
            this_.GAME_STATE.movecount_ ++;
         }
         this_.recordScore(RS_);
         this_.GAME_STATE.sidetomove_ = WHITE;
         this_.GAME_STATE.movecount_ = 0;
    }

     loadPosition(e) {
       if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
          this_.disablePopups();    
         // var top = 0; 
         // var left = parseInt(this.style.left.replace(/px/,'')) - 70;
          var top = this.offsetTop + this.parentNode.offsetTop;
          var left = parseInt(this.style.left.replace(/px/,'')) - 10;
          chooseAnalyze( this_, { y: top, x: left } );
       }
     }

     async analyzePosition() {
          var this_ = this.game_;
          var tbox  = this_.tbox;
          var fen = this.value_;
          var who_ = fen.split(' ')[1]
          var popup = document.getElementById('pop_chooseanalyzeid_' + this_.id);
          popup.parentNode.parentNode.style.visibility = 'hidden';
          await pause(250);
          try {
             const reverseB = checkPositionLegality(this_, fen);
             if (reverseB) {
               this_.repositionBoard(wINITFEN_, this_ );
             } else {
               this_.repositionBoard(fen, this_);
             }
             this_.GAME_STATE.status_ = STATUS.NEW;
             this_.GAME_STATE.sidetomove_ = (who_ == 'w') ? WHITE : BLACK;
             this_.statusGame();
             this_.nextToPlay();
           } catch(e) { log(e) }
     }


     async rematchGame(e, this_ = null) {
       if(!e.detail || e.detail == 1) { // avoid multiple clicks
          e.preventDefault();
log('rematch.');
       }
     }

     async newGame(e, this_ = null) {
       if(!e.detail || e.detail == 1) { // avoid multiple clicks
          e.preventDefault();
          var this_ = (this_ != null) ? this_ : this.game_;
          var fen = wINITFEN_; 

          // if (this_.GAME_STATE.playstatus_ != STATUS.STOPPED) return;
          if (this_.UCI_NEW_GAME_READY) {
             this_.repositionBoard(fen, this_);
             this_.statusGame(false);
             chess_reset.play();
             this_.GAME_STATE.status_ = STATUS.NEW;
             this_.GAME_STATE.playstatus_ = STATUS.PLAYING;
             this_.GAME_STATE.gameover_ = 0;
             this_.setEngine();
             // Play First Move 
             await pause(1000);
             this_.nextToPlay();
          }
        }
     }

     createButton(title, color, bgcolor, top = 200, left = 5, width = 120, height = 40) {
        var dv = document.createElement('div');
        dv.style="position: absolute; font-family: helvetica; font-weight: bold; font-size: 12pt; border-radius: 2px; cursor: pointer";
        dv.style.top = top + 'px'; dv.style.left = left + 'px';
        dv.style.width = width + 'px'; dv.style.height = height + 'px';
        dv.style.backgroundColor = bgcolor;
        dv.style.color = color;

        var sp = document.createElement('span');
        dv.appendChild(sp);
        sp.style="position: absolute; display: block; width: 100%; text-align: center; top: 10px;";
        sp.innerHTML = title;
        return dv;
     } 

     msgClean() {
          var this_ = this;
          var tbox = this_.tbox;
          var msgid  = tbox.msgid_;
          while (msgid.lastChild) {
             const child = msgid.lastChild;
             msgid.removeChild(child);
          } 
          msgid.innerHTML = '';
     }

     msgDone(this_, msg) {
       if (this_.GAME_STATE.gameover_) {
          var go = this_.GAME_STATE.gameover_;
          var tbox = this_.tbox;
          var wicon   = ' (&#x2655;)';
          var bicon   = ' (&#x265A;)';
          var fplayer = this.ftr_player_;
          var hplayer = this.hdr_player_;
          var helo    = this.hdr_elo_;
          var felo    = this.ftr_elo_;
          var msgwin = tbox.msgwin_;
          var msgid  = tbox.msgid_;
          var winner = ( this_.GAME_STATE.gameoverside_ == WHITE ) ? 'Black' : 'White';
          var result = ( this_.GAME_STATE.gameoverside_ == WHITE ) ? '0-1' : '1-0';
          var bywhat = null, draw = false;
          this_.msgClean();
          if (go == GAMEOVER.CHECKMATE) bywhat = 'by checkmate'; else
          if (go == GAMEOVER.TIMEOUT) bywhat = 'by timeout'; else
          if (go == GAMEOVER.ABANDONED) bywhat = 'by abandonment'; else
          if (go == GAMEOVER.RESIGNED) bywhat = 'by resignation'; 

          if (go == GAMEOVER.STALEMATE) bywhat = 'by stalemate'; else
          if (go == GAMEOVER.INSUFFICIENT) bywhat = 'by insufficient material'; else
          if (go == GAMEOVER.REPETITION) bywhat = 'by repetition'; else
          if (go == GAMEOVER.DRAWACCEPTED) bywhat = 'by mutual agreement';
          draw = (go == GAMEOVER.INSUFFICIENT || go == GAMEOVER.REPETITION || go == GAMEOVER.DRAWACCEPTED || go == GAMEOVER.STALEMATE);
          result = (draw) ? '1/2 - 1/2' : result;

          // main message
          var main=document.createElement('span');
          main.style="position: absolute; left: 0px; top: 5px;  font-weight: bold; font-size: 12pt";
          main.innerHTML = (draw) ? 'Draw' : winner + ' Won';
          main.style.width = msgid.style.width;
          msgid.appendChild(main);

          // reason
          var b = document.createElement('span'); b.innerHTML = bywhat;
          b.style="position: absolute; left: 0px; top: 26px; font-family: helvetica; font-weight: normal; font-size: 10pt;  white-space: nowrap; text-align: center";
          b.style.width = msgid.style.width;
          b.style.color = '#880000';
          msgid.appendChild(b);

          // display players
          var h = document.createElement('span'); h.innerHTML = hplayer.innerHTML + ((tbox.reversed_) ? wicon : bicon );
          var s = document.createElement('span'); s.innerHTML = '<br><span style="color: #800000">' + result + '</span><br>';
          var f = document.createElement('span'); f.innerHTML = fplayer.innerHTML + ((tbox.reversed_) ? bicon : wicon );
          var s1 = document.createElement('span');
          s1.style="position: absolute; display: block; top: 60px; font-weight: normal; font-size: 10pt";
          s1.style.width = msgid.style.width;
          s1.appendChild(h); s1.appendChild(s); s1.appendChild(f);
          msgid.appendChild(s1);
          msgid.style.textAlign = 'center';

          // Rating
          var rate = 0;
          if (this_.GAME_STATE.gameoverside_ == WHITE) {
            rate = (tbox.reversed_) ? felo.innerHTML : helo.innerHTML;
          } else {
            rate = (tbox.reversed_) ? helo.innerHTML : felo.innerHTML;
          }
          var r = document.createElement('span'); r.innerHTML = (draw) ? '' : rate;
          r.style="position: absolute; left: 0px; top: 130px; font-weight: bold; font-size: 18pt; color: #800000;";
          r.style.width = msgid.style.width;
          msgid.appendChild(r);

          // Earn
          var e = document.createElement('span'); e.innerHTML = 'You earned 20 points!';
          e.style="position: absolute; left: 0px; top: 160px; font-family: helvetica; font-weight: normal; font-size: 10pt;  white-space: nowrap; text-align: center";
          e.style.width = msgid.style.width;
          msgid.appendChild(e);

          // buttons
          var btn1 = this.createButton('Rematch', '#252525', '#81d765', 200, 5, 110, 40);
          var btn2 = this.createButton('New Game', '#252525', '#81d765', 200, 125, 110, 40);
          btn1.onclick = this_.rematchGame;
          btn2.onclick = this_.newGame;
          btn1.game_ = this_;
          btn2.game_ = this_;
          msgid.appendChild(btn1);
          msgid.appendChild(btn2);

          msgwin.style.visibility = 'visible';
       }
     }

     doneGame(msg = null) {
          log("done Game ..."); 
          this.GAME_STATE.status_ = STATUS.DONE;
          this.GAME_STATE.playcurrent_ = STATUS.STOPPED;
          this.statusGame(true);
          this.recordResult(this);
          this.msgDone(this, msg);
     }

     resignGame(e) {
       if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
          this_.GAME_STATE.status_ = STATUS.RESIGN;
          this_.GAME_STATE.gameover_ = GAMEOVER.RESIGNED;
          this_.GAME_STATE.gameoverside_ = this_.GAME_STATE.sidetomove_;
          this_.checkGameOver();
       }
     }


     async takeBack(e) {
       if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
          await pause(200);
          this_.takeitBack();
       }
     }

     takeitBack() {
          var mtype = undoMove(this);
          this.statusGame();
          if (mtype == 0) { /* do nothing */ } else
          if (mtype == GOODMOVE) {
             chess_move.currentTime = 0;
             chess_move.play();
          } else {
             chess_castle.currentTime = 0;
             chess_castle.play();
          }
     }

     playerChoice = false
     choosePlayer() {
         var this_ = this.game_;
         if (this_.engine_ == null) {
            this_.engine_ = machineid.cloneNode(true);
            this_.tbox.appendChild(this_.engine_);
            var inputs = this_.engine_.getElementsByClassName("engineclass");
            for (var p=0; p<inputs.length; p++) {
               if (inputs[p].id == "engineid") {
                  inputs[p].onclick = this_.engineGame;
                  inputs[p].game_ = this_;
                } else {
                  inputs[p].onclick = this_.enginePlayer;
                  inputs[p].game_ = this_;
                }
             }
         }
         this_.engine_.style.visibility = (this_.engine_.style.visibility == "visible") ? "hidden" : "visible";
         this_.playerChoice = (this_.engine_.style.visibility == "visible") ? true : false;
     }

     enginePlayer() {
         var this_ = this.game_;
         if (this.id == "whiteplayerid") this_.WPLAYER_ = this.value;
         if (this.id == "blackplayerid") this_.BPLAYER_ = this.value;
     }
 
     engineGame() {
         var this_ = this.game_;
         this_.engine_.style.visibility = (this_.engine_.style.visibility == "visible") ? "hidden" : "visible";
         this_.setEngine();
         message(this_, "Configuration takes effect in th next game!", false);
     }

     mouseDownForSet(e)  {
        e.preventDefault();
        if(!e.detail || e.detail == 1) {
           var this_ = this.game_;

           if (this_.GAME_STATE.status_ != STATUS.SET) return;
           var cell = this.parentNode.parentNode;
           var img = this.cloneNode(false);
           var tbox = this_.tbox;
           var width = parseInt(tbox.style.width);
           var height = parseInt(tbox.style.height);
           var padL = parseInt(tbox.style.paddingLeft);
           var padR = parseInt(tbox.style.paddingRight);
           var padT = parseInt(tbox.style.paddingTop);
           var padB = parseInt(tbox.style.paddingBottom);
           var center_width = this_.cellwidth / 2;
           var center_height = this_.cellheight / 2;
           var cwidth = parseInt(this.style.width) / 2;
           var cheight = parseInt(this.style.height) / 2;
           var loffset = width + padL + padR;
           var toffset = this.parentNode.parentNode.offsetTop + this.parentNode.offsetTop;

           var offsetLeft =  this_.container_.offsetLeft + loffset + this.offsetLeft + 5;
           var offsetTop = this_.container_.offsetTop + toffset + this.offsetTop + 4; 
           img.style.position = 'absolute';
           img.style.width = this_.cellwidth + 'px';
           img.style.height = this_.cellheight + 'px';
           img.style.left = (offsetLeft + cwidth - center_width ) + 'px'; // starts from tbox offset = 0
           img.style.top  = (offsetTop + cheight - center_height ) + 'px'; //  starts from tbox offset = 0
           img.startPosX = offsetLeft + cwidth;
           img.startPosY = offsetTop + cwidth;
           img.style.zIndex = 500;
           img.piece = this.piece;
           img.role_ = this.role_;
           img.color_ = this.color_;
           chessdiv.appendChild(img);
           chessdiv.targetmove_ = img;
           chessdiv.addEventListener('mousemove', this_.mouseMoveForSet);
           document.setgame_ = this_;
           tbox.game_ = this_;
           this_.GAME_STATE.mousedu_ = true;
         }
     }

     mouseMoveForSet(e) {
           e.preventDefault();
           var this_ = this.game_;
           var tbox = this_.tbox;
           var container_ = this_.container_;
           var padding = parseInt(tbox.style.padding);
           var piece = this.targetmove_;
           var pos = scrollOffset(e), x = pos.x , y = pos.y;
           piece.newPosX   = piece.startPosX - x;
           piece.newPosY   = piece.startPosY - y;
           piece.startPosX = x;
           piece.startPosY = y;

           piece.style.top  = (piece.offsetTop - piece.newPosY) + "px";
           piece.style.left = (piece.offsetLeft - piece.newPosX) + "px";
           piece.style.zIndex = 500;
     }

     unsetPiece() {
          var this_ = this.game_;
          var Board = this_.ChessBoard.Board;
          var piece = this.piece;
          var loc_ = piece.location; 
          var td_   = Board[loc_].td_;
          td_.removeChild(piece.img_);
          Board[loc_].piece = null;
          chess_capture.currentTime = 0;
          chess_capture.play();
     }

     setPiece() {
          var this_ = this;
          var Board = this_.ChessBoard.Board;
          var tbox = this_.tbox;
          var coffsetL = this_.container_.offsetLeft;
          var coffsetT = this_.container_.offsetTop;
          var hdr_height  = parseInt(this_.header_.style.height);
          var padL = parseInt(tbox.style.paddingLeft);
          var padT = parseInt(tbox.style.paddingTop);
          var img = chessdiv.targetmove_;
          this_.GAME_STATE.mousedu_ = false;
          var center_width  = (this_.cellwidth / 2);
          var center_height = (this_.cellheight / 2);
          var i_centerL = img.offsetLeft + center_width, i_centerT = img.offsetTop + center_height;
          var loc_ = null;
          for (var h in horiz) {
                 for (var v=1; v<=8; v++) {
                    loc_ = horiz[h] + v;
                    const td_ = Board[loc_].td_;
                    const b_offsetL = coffsetL + td_.parentNode.offsetLeft + padL;
                    const b_offsetT = coffsetT + td_.parentNode.offsetTop + padT + hdr_height;
                    if (( i_centerL > b_offsetL && i_centerL < b_offsetL + this_.cellwidth ) &&
                        ( i_centerT > b_offsetT && i_centerT < b_offsetT + this_.cellheight )) {
                          const img_ = td_.getElementsByClassName('chessimg')[0];
                          if (img_ != null) { td_.removeChild(img_); }
                          var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
                          const new_piece = new this.Piece(this, img.role_, img.color_, rloc_, true);
                          Board[rloc_].piece = new_piece;
                          td_.appendChild(new_piece.img_);
                          chess_move.currentTime = 0;
                          chess_move.play();
                          chessdiv.removeChild(img);
                          return;
                    }
                 }
          }
          chessdiv.removeChild(img);
          log(Board);
   }

     mouseDownForMove(e)  {
        e.preventDefault();
        if(!e.detail || e.detail == 1) {
           var this_ = this.game_;
           if (!(this_.GAME_STATE.status_ == STATUS.NEW || this_.GAME_STATE.status_ == STATUS.SET)) return;
           var cell = this.parentNode.parentNode; // td.tr.tbody.table
           var img = this.cloneNode(false); 
           var ctrl = this_.container_;
           var tbox = this_.tbox;
           var padL = parseInt(tbox.style.paddingLeft);
           var padR = parseInt(tbox.style.paddingRight);
           var padT = parseInt(tbox.style.paddingTop);
           var padB = parseInt(tbox.style.paddingBottom);
           var center_width = this_.cellwidth / 2
           var center_height = this_.cellheight / 2
           var brd_ = parseInt(ctrl.style.border);

           var offsetLeft =  ctrl.offsetLeft + tbox.offsetLeft + cell.offsetLeft;
           var offsetTop = ctrl.offsetTop + tbox.offsetTop + cell.offsetTop;
           offsetLeft = ( offsetLeft + this.offsetLeft + padL + brd_ )
           offsetTop = ( offsetTop + this.offsetTop + padT + brd_)

           img.style.position = 'absolute';
           img.style.left = (offsetLeft) + 'px'; // starts from tbox offset = 0
           img.style.top  = (offsetTop) + 'px'; //  starts from tbox offset = 0
           img.startPosX = offsetLeft + center_width;
           img.startPosY = offsetTop + center_height;
           img.piece = this.piece;
           img.style.zIndex = 500;
           chessdiv.appendChild(img);
           chessdiv.targetmove_ = img;
           chessdiv.addEventListener('mousemove', this_.mouseMove);
           document.movegame_ = this_;
           tbox.game_ = this_;
           this.style.visibility = 'hidden'; // hide original piece
           this_.GAME_STATE.mousedu_ = true;
        }
     }

     mouseMove(e) {
           e.preventDefault();
           var this_ = this.game_; 
           var tbox = this_.tbox;
           var container_ = this_.container_;
           var padding = parseInt(tbox.style.padding);
           var piece = this.targetmove_;
           var pos = scrollOffset(e), x = pos.x , y = pos.y;
           piece.newPosX   = piece.startPosX - x;
           piece.newPosY   = piece.startPosY - y;
           piece.startPosX = x;
           piece.startPosY = y;

           piece.style.top  = (piece.offsetTop - piece.newPosY) + "px";
           piece.style.left = (piece.offsetLeft - piece.newPosX) + "px";
           piece.style.zIndex = 500;
     }

     statusGame( done = false ) {
          var state = this.GAME_STATE;
          this.ftr_side_.style.color = done ? '#7E3348' : '#000000';
          if (done) {
             this.ftr_side_.innerHTML = '&#9679;';
          }  else {
             this.ftr_side_.innerHTML = (state.sidetomove_ == WHITE) ? '&#9675;' : '&#9679;';
          }
     }

     nextToPlay() {
         var this_ = this;
         if (this_.GAME_STATE.status_ == STATUS.DONE || this.GAME_STATE.playcurrent_ == STATUS.STOPPED) return;
         if ((this_.BPLAYER_ == MACHINE && this_.GAME_STATE.sidetomove_ == BLACK) ||
           (this_.WPLAYER_ == MACHINE && this_.GAME_STATE.sidetomove_ == WHITE)) {
            this_.playEngine();
         }
     }

     TurnToPlay(piece, reset_move = false) {
          var state = this.GAME_STATE;
          var SIDETOMOVE_ = state.sidetomove_;
          var MOVECOUNT_ = state.movecount_;
          this.GAME_STATE.sidetomove_ = ( state.sidetomove_ == WHITE) ? BLACK: WHITE;
          this.GAME_STATE.movecount_ = state.movecount_ + ((state.sidetomove_ == WHITE ) ? 1 : 0);
          this.statusGame();
          this.setTimer(true);
          piece.img_.style.visibility = 'visible';
          if (piece != null) {
             this.GAME_STATE.lastpiece_ = piece;
             this.setMoveHint(piece);
             if (!reset_move) {
                 if (piece.restype_ == CASTLELONG || piece.restype_ ==  CASTLESHORT) { chess_castle.currentTime = 0; chess_castle.play(); }
                   else
                 if (piece.restype_ == EATPIECE) { chess_capture.currentTime = 0; chess_capture.play(); } else
                                           { chess_move.currentTime = 0; chess_move.play(); }
             }
          } else chess_move.play();
     }



     UCI_NEW_GAME_READY = true;
     setenginetime = null
     setEngine() {
          this.UCI_NEW_GAME_READY = false;
          post("uci");
          ENGINE_UCI_RESPONSE_ = null
          this.setenginetime = setInterval(this.captureEngineSettings, 100, this);
     }


     int_setengine = 0
     captureEngineSettings(this_) {
           if (this_.int_setengine > 20) { this_.int_setengine = 0; clearInterval(this_.setenginetime)  }
           this_.int_setengine ++;
           if (ENGINE_UCI_RESPONSE_ != null) {
                this_.int_setengine  = 0;
                clearInterval(this_.setenginetime);
                if (ENGINE_UCI_RESPONSE_ == 'uciok') {
                    log("UCI set OK  ...");
                    this_.setEngineOptions(); 
                }
           }
     }

     optionenginetime = null
     setEngineOptions() {
          ENGINE_READY_RESPONSE_ = null;
          // post("setoption name UCI_Opponent value none none human " + this.id, this.id);
          post("setoption name MultiPV value 5", this.id);
          post("setoption name UCI_ShowWDL value true", this.id);
          // post("setoption name UCI_AnalyseMode value true", this.id);
          post("setoption name UCI_Elo value 2850", this.id);  // ( min 1350 max 2850 )
          post("setoption name UCI_LimitStrength value true", this.id); /* required by UCI_Eclo */ 
          post('setoption name Skill Level value 20', this.id);  // (min 0 max 20)
          // post("setoption name Slow Mover value 84", this.id);  // (min 10 max 1000)
          post("setoption name Use NNUE value true", this.id);
          //post("setoption name EvalFile value nn-98bb5dab8405.nnue", this.id); // see https://tests.stockfishchess.org/nns
          post("setoption name EvalFile value nn-6877cd24400e.nnue", this.id);
          post("isready", this.id);
          this.optionenginetime = setInterval(this.captureEngineOptions, 100, this);
     }

     int_optionengine = 0
     captureEngineOptions(this_) {
           if (this_.int_optionengine > 20) { this_.int_optionengine = 0; clearInterval(this_.optionenginetime)  }
           this_.int_optionengine ++;
           if (ENGINE_READY_RESPONSE_ != null) {
                this_.int_optionengine  = 0;
                clearInterval(this_.optionenginetime);
                if (ENGINE_READY_RESPONSE_ == 'readyok') {
                   log("Engine is ready ...");
                   this_.UCI_NEW_GAME_READY = true;
		   this_.newEngineGame();
                }
           }
     }

     newenginetime = null
     newEngineGame(this_) {
          ENGINE_NEW_RESPONSE_ = null;
          post("ucinewgame", this.id);
          this.newenginetime = setInterval(this.captureNewEngineGame, 100, this);
     }

     int_newengine = 0
     captureNewEngineGame(this_) {
           if (this_.int_newengine > 20) { this_.int_newengine = 0; clearInterval(this_.newenginetime)  }
           this_.int_newengine ++;
           if (ENGINE_NEW_RESPONSE_ != null) {
                this_.int_newengine  = 0;
                clearInterval(this_.newenginetime);
                if (ENGINE_NEW_RESPONSE_ == 'readyok') {
                   log("UCI new Game ready ...");
                }
           }
     }


     enginetime = null
     async playEngine(enpassant = "-") {
          ENGINEMOVE_ = null;
          ANALYZE_ = [];
          this.int_engine = 0;
          var side_ = (this.GAME_STATE.sidetomove_ == WHITE) ? 'w' : 'b';
          var fen = generateFEN(this, side_);
          var movetime = Math.floor(Math.random() * 200 + 500)
          var depth =  Math.floor(Math.random() * 5 + 15)
          post("ucinewgame", this.id);
          post("position fen " + fen, this.id);
          await post("go movetime " + movetime + " depth " + depth, this.id);
          this.enginetime = setInterval(this.captureEngineMove, 100, this);
     }

     formMove(piece, src_, nloc_, promote) {
          var move_ = null;
          if (piece.restype_ == CASTLELONG) move_ = "O-O-O"; else
          if (piece.restype_ == CASTLESHORT) move_ = "O-O"; else
          if (piece.restype_ == EATPIECE || piece.restype_ == ENPASSANT) {
                if (promote != null || piece.role_ == 'P') 
                   move_ = piece.oldlocation_[0] + "x" + nloc_;
                else
                   move_ = piece.role_ + src_ + "x" + nloc_;
          } else {
             if (promote != null) 
               move_ = src_ + nloc_;
             else
               move_ = piece.role_.replace(/P/g,'') + src_ + nloc_;
          }
          return move_;
     }

     checkGameOver() {
log('got here ... check game over ...');
        log(this.GAME_STATE.gameover_);
        if (this.isRepeatDraw()) {
          this.doneGame("Draw due to repetition of position!");
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.INSUFFICIENT) {
          this.doneGame("Draw due to lack of pieces to checkmate!");
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.CHECKMATE) {
log('got here ... check game over 2 ...');
          const msg = (this.GAME_STATE.gameoverside_ == WHITE) ?  "White loses!" : "Black loses!";
          this.doneGame("Checkmate! " + msg);
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.STALEMATE) {
          const msg = (this.GAME_STATE.gameoverside_ == WHITE) ?  "No viable move for white!" : "No viable move for black!";
          this.doneGame("Stalemate! " + msg);
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.ABANDONED) {
          const msg = (this.GAME_STATE.abandonedside_ == WHITE) ?  "White abandoned!" : "Black abandoned!";
          this.doneGame("Abandoned! " + msg);
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.DRAWACCEPTED) {
          this.doneGame("Draw accepted!");
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.RESIGNED) {
          const msg = (this.GAME_STATE.resignedside_ == WHITE) ?  "White resigned!" : "Black resigned!";
          this.doneGame("Resigned! " + msg);
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.TIMEOUT) {
          const msg = (this.GAME_STATE.timeoutside_ == WHITE) ?  "White timed out!" : "Black timed out!";
          this.doneGame("Timeout! " + msg);
        }
log('got here ... check game over 7 ...');
     }

     captureMove(Board, turn, player, record_move = true, stats = true, reset_move = false) {
         var oloc_ = turn.src;
         var nloc_ = turn.dst;
         var promote = turn.promote;
         try {
            if (typeof(oloc_) != "string" && oloc_.length != 1) illegal_move("No identified starting point ...");
            var move_ = null;
            var piece = Board[oloc_].piece;
            if (piece == null) illegal_move("No piece to move ...");
            this.GAME_STATE.checkking_ = false;
            this.GAME_STATE.draw_ = false;
            piece.move = { location: nloc_, promote: promote }
            const src_ = identifySource(Board, piece);
            move_ = this.formMove(piece, src_, nloc_, promote);
            if (record_move) this.recordMove(move_, promote, (this.GAME_STATE.checkking_ ? '+' : ''), null);
            this.TurnToPlay(piece, reset_move);
            this.checkGameOver();
            if (player == HUMAN) {
              if (stats) this.checkState(piece);
            } else {
              if (stats) this.postScore();
              this.nextToPlay();
            }
            return piece.restype_;
         } catch(e) {
              var msg = e.msg;
              if (piece != null) piece.img_.style.visibility = 'visible';
              // message(this, "Illegal move: " + e.msg, false);
                
              if (typeof(msg) != "undefined" && typeof(msg.lastIndexOf) != "undefined") {
                  var a = msg.lastIndexOf('endangering its own king'),
                      b = msg.lastIndexOf('Not able to find proper pieces'),
                      c = msg.lastIndexOf('no available king');
                  log(e);
                  if (a >= 0 || b >=0 || c >=0 ) { undoMove(this, false, false); };
              } else {
                  log(e);
              }
              this.GAME_STATE.playstatus_ = STATUS.ILLEGAL;
         }
     }

     int_engine = 0
     captureEngineMove(this_) {
           if (this_.int_engine > 150) { this_.int_engine = 0; clearInterval(this_.enginetime); log("timer expired ...");  }
           this_.int_engine ++;
           if (ENGINEMOVE_ != null) {
                clearInterval(this_.enginetime);
                this_.int_engine = 0;
                var Board = this_.ChessBoard.Board, piece;
                var oloc_ = null, nloc_ = null, promote = null;
                const move = { move: ENGINEMOVE_, side: this_.GAME_STATE.sidetomove_, check: null, promote: null }
                const turn = this_.simpleMove(this_, move, MACHINE);  //oloc_, nloc_, promote
                this_.captureMove(Board, turn, MACHINE);
          }
     }

     playHuman() {
          var this_ = this;
          var tbox = this_.tbox;
          var coffsetL = this_.container_.offsetLeft;
          var coffsetT = this_.container_.offsetTop;
          var hdr_height  = parseInt(this_.header_.style.height);
          var padL = parseInt(tbox.style.paddingLeft);
          var padT = parseInt(tbox.style.paddingTop);
          var img = chessdiv.targetmove_, piece = img.piece;
          var SIDETOMOVE_ = this_.GAME_STATE.sidetomove_;
          var MOVECOUNT_  = this_.GAME_STATE.movecount_;
          this_.GAME_STATE.mousedu_ = false;
          var center_width  = (this_.cellwidth / 2);
          var center_height = (this_.cellheight / 2);
          var i_centerL = img.offsetLeft + center_width, i_centerT = img.offsetTop + center_height;
          var loc_, oloc_ = null, nloc_;
          // remove cloned image  
          chessdiv.removeChild(img);             
          if ((SIDETOMOVE_ == WHITE && piece.color_.match(/dt$/)) ||
              (SIDETOMOVE_ == BLACK && piece.color_.match(/lt$/))) { 
                 piece.img_.style.visibility = 'visible';
                 log ("Illegal turn!");
                 return;
          }
          for (var h in horiz) {
                 for (var v=1; v<=8; v++) {
                    const loc_ = horiz[h] + v;
                    const td_ = this.ChessBoard.Board[loc_].td_;
                    const img_ = td_.getElementsByClassName('chessimg')[0];
                    const b_offsetL = coffsetL + td_.parentNode.offsetLeft + padL;
                    const b_offsetT = coffsetT + td_.parentNode.offsetTop + padT + hdr_height;
                    if (( i_centerL > b_offsetL && i_centerL < b_offsetL + this_.cellwidth ) &&
                        ( i_centerT > b_offsetT && i_centerT < b_offsetT + this_.cellheight )) {
                            var promote = null, move_ = null;
                            oloc_ = piece.location_;
                            nloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
                            if (piece.role == 'P') {
                               if (piece.color == 'plt' && nloc_[1] == 8) promote = 'lt';
                               if (piece.color == 'pdt' && nloc_[1] == 1) promote = 'dt';
                            }
                            if (promote == null) {
                               this_.captureHumanMove(piece, oloc_, nloc_, null);
                            } else {
                               this_.promoteChoice(piece, oloc_, nloc_, promote);
                            }
                            if (MOVECOUNT_ >= 0) this_.GAME_STATE.donegame_ = false;
                            return;
                     }
                 }
          }
          piece.img_.style.visibility = 'visible';
          return;
     }

     captureHumanMove(piece, oloc_, nloc_, promote) {
          var promote_ = (promote != null) ? '=' + promote : '';
          var turn = { move: oloc_ + nloc_ + promote_, side: piece.color, check: null};
          turn = this.simpleMove(this, turn, HUMAN);
          this.captureMove(this.Board_, turn, HUMAN);
     }

     promotetime = ''
     promoteChoice(piece, oloc_, nloc_, color) {

          this.GAME_STATE.onpromote_ = true;
          this.promo_.style.visibility = "visible";
          if (color == 'lt') {
             this.promowhite_.style.visibility = 'visible';
             this.promoblack_.style.visibility = 'hidden';
          } else {
             this.promowhite_.style.visibility = 'hidden';
             this.promoblack_.style.visibility = 'visible';
          }
          this.int_promote = 0;
          this.promotetime = setInterval(this.readyPromote, 50, this, piece, oloc_, nloc_);
     }

     int_promote = 0
     readyPromote(this_, piece, oloc_, nloc_) {
        var ONPROMOTE_ = this_.GAME_STATE.onpromote_;
        var PROMOTEPIECE_ = this_.GAME_STATE.promotepiece_;
        if (this_.int_promote > 200) {
           this_.int_promote = 0;
           clearInterval(this_.promotetime);
           this_.captureHumanMove(piece, oloc_, nloc_, 'Q'); // taking forever to decide, let's promote to Queen
           this_.promotePiece();
        }
        if (!ONPROMOTE_ && PROMOTEPIECE_ != null) {
           clearInterval(this_.promotetime);
           this_.captureHumanMove(piece, oloc_, nloc_, PROMOTEPIECE_);
           this_.promotePiece();
        }
        this_.int_promote ++;
     }

     promotePiece() {
         var this_ = null;
         if (typeof(this.nodeType) == "undefined") {
             this_  = this;
             this_.GAME_STATE.promotepiece_ = null;
         } else {
             this_  = this.game_;
             this_.GAME_STATE.promotepiece_ = this.id;
         }
         this_.GAME_STATE.onpromote_ = false;
         this_.promowhite_.style.visibility = 'hidden';
         this_.promoblack_.style.visibility = 'hidden';
         this_.promo_.style.visibility = "hidden";
     }

     recordMove(move, promote = null, check = null, comment = null, result = null) {
         var state_ = this.GAME_STATE;
         var SIDETOMOVE_ = state_.sidetomove_;
         var count_ = state_.movecount_ + 1;
         if (count_ == 1 && SIDETOMOVE_ == BLACK && this.Moves_.length == 0) { 
            this.GAME_STATE.sidetomove_ = WHITE;
 	    this.recordMove("(...)");
            this.GAME_STATE.sidetomove_ = BLACK;
         }
         if (promote == '') promote = null; 
         const notes = this.Notes_;
         const move_ = this.beautifyMove(move);
         const span   = document.createElement("span");
         const moves0 = document.createElement("span");  moves0.className = "chesspiecestep";
         const moves1 = document.createElement("span");  moves1.className = "chesspiecenomove";   moves1.innerHTML = move_ + ((promote !=null) ? '=' + promote : '');
         const moves2 = document.createElement("span");  
         const space1 = document.createTextNode(" ");
         const movec1 = document.createElement("span");  movec1.className = 'chesscmt';         movec1.innerHTML = check; 
         const movec2 = document.createElement("span");  movec2.className = 'chesscmt';         movec2.innerHTML = comment;

         if (SIDETOMOVE_ == WHITE) { moves0.innerHTML = count_ + "."; }

         span.id = "moveid_" + count_ + '_' + ((SIDETOMOVE_ == WHITE) ? "w" : "b");
         movec1.id = "chk_" + count_ + "_" + move;

         span.onclick = this.jumpMove;
         span.game_ = this;
         span.step_ = ((SIDETOMOVE_ == WHITE) ? (count_ * 2 - 1) : (count_ * 2) ) - 1;

         this.Moves_.push( { move: moves0.innerHTML + move.replace(/P/g, ''), 
			     side: (SIDETOMOVE_==WHITE) ? 'lt' : 'dt', promote: promote, check: check, comment: comment } );
        
         span.appendChild(moves0); span.appendChild(moves1);
         span.appendChild(moves2); span.appendChild(movec1); 
         span.appendChild(movec2); span.appendChild(space1);
         notes.appendChild(span);
     }

     recordScore(rs) {
         const notes = this.Notes_;
         const span   = document.createElement("span");
         const movesp = document.createTextNode("   ");
         const moves = document.createElement("span");
         moves.className = "chesspiecers";
         moves.style.color = "#1255b3";
         moves.innerHTML = "&nbsp;&nbsp;&nbsp;" + rs;
         span.appendChild(movesp); 
         span.appendChild(moves); 
         notes.appendChild(span);
     }

     recordPlayers(current_) {
         var reversed = this.tbox.reversed_;
         var side_ = this.GAME_STATE.sidetomove_;
         this.hdr_player_.innerHTML  = (reversed) ? current_.wp : current_.bp;
         this.hdr_elo_.innerHTML     = (reversed) ? current_.we : current_.be;
         this.ftr_player_.innerHTML  = (reversed) ? current_.bp : current_.wp;
         this.ftr_elo_.innerHTML     = (reversed) ? current_.be : current_.we;
     }

     recordResult(this_) {
         var notes = this_.Notes_;
         var go = this_.GAME_STATE.gameover_;
         var result = ( this_.GAME_STATE.gameoverside_ == WHITE ) ? '0-1' : '1-0';
         var draw = false;
         draw = (go == GAMEOVER.INSUFFICIENT || go == GAMEOVER.REPETITION || go == GAMEOVER.DRAWACCEPTED || go == GAMEOVER.STALEMATE);
         result = (draw) ? '1/2 - 1/2' : result;

         this_.recordScore(result);

     log(notes);  

     }

     unrecordMove() {
         const notes = this.Notes_;
         this.Moves_.pop();
         notes.removeChild(notes.lastChild);
     }

     async jumpMove(e = null, step = null) {
        var this_ = (e != null) ? this.game_ : this;
        const notes = this_.Notes_;
        if (e != null && ( this_.GAME_STATE.playstatus_ != STATUS.STOPPED && this_.GAME_STATE.playstatus_ != STATUS.INTERRUPTED)) return;
        var p = (step != null) ? step : this.step_;
        var value = this_.GAME_STATE.gamecurrent_;
        var mymoves = this_.PGNDB_[value];
        var fen = mymoves[p].fen;
        var rtype = mymoves[p].restype;
        var turn = mymoves[p].turn;
        this_.initializeBoard(this_);
        this_.positionBoard(fen, this_);
        this_.whichSound(rtype);
        this_.resetHint(turn.src, false);
        this_.resetHint(turn.dst, false);
        if (this_.GAME_STATE.playcurrent_ != null) {
             var o = this_.GAME_STATE.playcurrent_;
             var sturn = mymoves[o].turn;
             if (!(turn.src == sturn.src && turn.dst == sturn.dst)) { 
               this_.resetHint(sturn.src, true);
               this_.resetHint(sturn.dst, true);
             }
        }
        this_.highlightMove(notes, p, this_.GAME_STATE.playcurrent_);
        this_.GAME_STATE.playcurrent_ = p;
        return p;
     }

     isRepeatDraw() {  // Three-fold repetition of the same Position in the board.
        var draw = false;
        var fen = generateFEN(this, "w").split(' ')[0];
        this.RepeatDraw_.push(fen);
        if (this.RepeatDraw_.length >= 15) { // though rule says repetition could be anywhere in the whole game.
           this.RepeatDraw_.shift(); // chops off the first element to manage length of array
        }
        var dupfen = {};
        this.RepeatDraw_.forEach((i) => { dupfen[i] = ++dupfen[i] || 1} );
        for (p in dupfen) {
            var repeat = dupfen[p];
            if (repeat >= 3) {
               draw = true;
               break;
            }
        }
        if (draw) this.GAME_STATE.gameover_ = GAMEOVER.REPETITION;
        return draw;
     }

     evaluateScore() {
        var ponder_ = (typeof(PONDER_) == "undefined") ? "" : " " + PONDER_;
        var move_ = ENGINEMOVE_ + ponder_;
        var analyze = 50, score = 0, found = 0, load_ = null;
        if (ANALYZE_.length)
        for (var p in ANALYZE_) {
          const l_ = ANALYZE_[p];
          found = l_.moves.lastIndexOf(move_);
          if (found == 0) {
            if (l_.srate > score ) {
              load_ = l_;
              score = load_.wscore // load_.srate
            }
          }
        }
        return score == 0 ? 0.50 : score;
     }

     postScore() {
        const score = this.evaluateScore();
        var reversed = this.tbox.reversed_;
        var ctrl_ = this.container_;
        // var cbr_ = parseInt(this.tbox.style.padding);
        var padL = parseInt(this.tbox.style.paddingLeft);
        var padR = parseInt(this.tbox.style.paddingRight);
        var padT = parseInt(this.tbox.style.paddingTop);
        var padB = parseInt(this.tbox.style.paddingBottom);

        var hdr_ = parseInt(this.header_.style.height);
        var width = parseInt(this.tbox.style.width);
        var height = parseInt(this.tbox.style.height);
        var white = this.tbox.boardcolor_.sd; // '#eeeeee';
        var black = this.tbox.boardcolor_.dt; // '#444444';
        if (typeof(this.tbox.rating) == "undefined") { 
           const cover = document.createElement('span');
           const rating = document.createElement('span');
           cover.appendChild(rating);

           cover.style.position = 'absolute';
           cover.style.display = 'block';

           rating.style.position = 'absolute';
           cover.style.display = 'block';

           cover.style.border = '0px';
           rating.style.border = '0px';
 
           this.tbox.appendChild(cover);
           this.tbox.rating = rating;
        }

        const rating = this.tbox.rating;
        const cover  = rating.parentNode;
     
        cover.style.width = '3px'
        cover.style.height = height + 'px';
        cover.style.top = (padT) + 'px';
        cover.style.left = (width + (padR + padL))  + 'px';
        //cover.style.right = '-1px';
        cover.style.backgroundColor = white;
        cover.style.zIndex = 3;

        rating.style.width = '3px';
        rating.style.height = (height * score) + 'px';
        rating.style.top = '0px';
        rating.style.left = '0px';
        // rating.style.right = '-1px';
        rating.style.backgroundColor = black;
        rating.style.zIndex = 3;
           
        this.tbox.rating.style.backgroundColor = (reversed) ? white : black;
        this.tbox.rating.parentNode.style.backgroundColor = (reversed) ? black : white;
        this.tbox.rating.style.height = (height * ((reversed) ? score : 1 - score)) + 'px';
     }

     readyNextPlay(this_, move_) { 
        if (this_.check_timer_[move_].int_timer > 120) { 
             this_.check_timer_[move_].int_timer = 0; 
             clearInterval(this_.check_timer_[move_].timer); 
        }
        this_.check_timer_[move_].int_timer++;
        if (ENGINE_NEXT_RESPONSE_ != null) {
            this_.check_timer_[move_].int_timer = 0;
            clearInterval(this_.check_timer_[move_].timer);
            delete this_.check_timer_[move_]; 
            this_.postScore();
            this_.nextToPlay();
        }
     }

     // checkstatetime = null
     check_timer_ = {};
     async checkState(piece) {
         var side_ = (this.GAME_STATE.sidetomove_ == WHITE) ? 'w' : 'b';
         var fen = generateFEN(this, side_);
         var move_ = piece.oldlocation_ + piece.location_;
         ENGINE_NEXT_RESPONSE_ = null;
         ENGINE_STATE_REQ_ = true;
         post("position fen " + fen, this.id);
         await post("go movetime 500 10");
         this.check_timer_[ move_ ] = { timer: null, int_timer: 0 } 
         this.check_timer_[ move_ ].timer  = setInterval(this.readyNextPlay, 100, this, move_);
     }

     resetHint(loc_, reset = true) {
         var Board = this.ChessBoard.Board;
         var tbox  = this.tbox;
         var color = tbox.boardcolor_;
         var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
         var board = Board[rloc_];
         var td    = board.td_.parentNode;
         var mod = (td.cellIndex +td.parentNode.rowIndex ) % 2;
         if (reset) {
              td.style.backgroundColor = (mod) ? color.dt : color.lt;
         } else {
              td.style.backgroundColor = (mod) ? color.hdt : color.hlt;
         }
     }

     isEnpassant() {
         var piece = this.GAME_STATE.lastpiece_;
         if (piece == null) return '-';
         var WHITETOMOVE_ = (piece.color_.match(/lt$/)) != null;
         var oh = piece.oldlocation_[0], nh = piece.location_[0];
         var ov = piece.oldlocation_[1], nv = piece.location_[1];
         if (oh == nh) {
               if (WHITETOMOVE_ && ov == 2 && nv == 4) return oh + 3;
               if (!WHITETOMOVE_ && ov == 7 && nv == 5) return oh + 6;
         }
         return '-'
     }

     setMoveHint(piece) {
         var hints = this.MoveHint_;
         if (hints.length > 0) {
               const last_ = hints[hints.length  - 1];
               this.resetHint(last_.src);
               this.resetHint(last_.dst);
         } 
         if (piece.oldlocation_ == null) {
           this.resetHint(piece.location_, true);
         } else {
           this.resetHint(piece.location_, false);
           this.resetHint(piece.oldlocation_, false);
         }
         this.MoveHint_.push({ src: piece.oldlocation_, dst: piece.location_ });
     }

     unsetMoveHint(takeback_) {
          var Board = this.ChessBoard.Board;
          var hints = this.MoveHint_;
          var curr_ = null, last_ = null;

          if (takeback_) {
             curr_ = this.MoveHint_.pop();
             this.resetHint(curr_.src);
             this.resetHint(curr_.dst);
             if (hints.length > 0) {
                 last_ = hints[hints.length  - 1];
                 this.resetHint(last_.src, false);
                 this.resetHint(last_.dst, false);
             }
          } 
       }

     int_PCOUNT_ = 0
     checkTimer(this_) {
           var BTIMER_ = this_.BTIMER_,  WTIMER_ = this_.WTIMER_;
           var SIDETOMOVE_ = this_.GAME_STATE.sidetomove_;
           var PTIMER_ = this_.GAME_STATE.ptimer_;
           var last_time_ = Date.now();
           var elapsed = 0, seconds = 0, minutes = 0, hours = 0;
           if (this_.int_PCOUNT_ > 60000) { this_.int_PCOUNT_ = 0; clearInterval(PTIMER_); this_.GAME_STATE.ptimer_ = null }
           this_.int_PCOUNT_++;
           if (SIDETOMOVE_ == WHITE) {
              WTIMER_.elapsed += (last_time_ - WTIMER_.last_time);
              elapsed = (this_.PLAYTIME_ - WTIMER_.elapsed)
              if (elapsed < 0) {
                  this_.int_PCOUNT = 0; clearInterval(PTIMER_); this_.GAME_STATE.ptimer_ = null;
                  this_.WTIMER_ = WTIMER_;
                  this_.GAME_STATE.gameover_ = GAMEOVER.TIMEOUT;
                  this_.GAME_STATE.gameoverside_ = WHITE;
                  this_.checkGameOver();
                  return;
              }
              WTIMER_.watch = padTime(elapsed)
              if (this_.tbox.reversed_) {
                 this_.hdr_timer_.innerHTML = WTIMER_.watch;
              } else {
                 this_.ftr_timer_.innerHTML = WTIMER_.watch;
              }
              WTIMER_.last_time = last_time_;
          } else {
              BTIMER_.elapsed += (last_time_ - BTIMER_.last_time);
              elapsed = (this_.PLAYTIME_ - BTIMER_.elapsed)
              if (elapsed < 0) {
                 this_.int_PCOUNT = 0; clearInterval(PTIMER_); this_.GAME_STATE.ptimer_ = null;
                 this_.BTIMER_ = BTIMER_;
                 this_.GAME_STATE.gameover_ = GAMEOVER.TIMEOUT;
                 this_.GAME_STATE.gameoverside_ = BLACK;
                 this_.checkGameOver();
                 return;
              }
              BTIMER_.watch = padTime(elapsed)
              if (this_.tbox.reversed_) {
                   this_.ftr_timer_.innerHTML = BTIMER_.watch;
              } else {
                   this_.hdr_timer_.innerHTML = BTIMER_.watch;
              }
              BTIMER_.last_time = last_time_;
          }
          this_.BTIMER_ = BTIMER_; this_.WTIMER_ = WTIMER_;
     }
    
     setTimer(timeron = true) {
          var last_time_ = Date.now();
          if (this.GAME_STATE.sidetomove_ == BLACK && this.GAME_STATE.movecount_ == 0) {
             this.ftr_timer_.innerHTML = padTime(this.PLAYTIME_);
             this.hdr_timer_.innerHTML = padTime(this.PLAYTIME_);
          }
          if (this.GAME_STATE.sidetomove_ == WHITE) {
             this.WTIMER_.last_time = last_time_;
          } else {
             this.BTIMER_.last_time = last_time_;
          }
          this.int_PCOUNT = 0;
          if (timeron) if (this.GAME_STATE.ptimer_ == null) this.GAME_STATE.ptimer_ = setInterval(this.checkTimer, 50, this);
     }

    } // end Game class


    function undoMove(game, takeback_ = true, switchside = true) {
       var Board = game.ChessBoard.Board;
       var Benched = game.ChessBoard.Bench;
       var Undo = game.Undo_;
       var MoveHint_ = game.MoveHint_;
       var RepeatDraw_ = game.RepeatDraw_;
       var SIDETOMOVE_ = game.GAME_STATE.sidetomove_;
       var BOARDSIZE_ = game.BOARDSIZE_;
       if (Undo.length ==0 ) return 0;
       var move = Undo[Undo.length - 1], undone = false, piece; 
       if (move.type == GOODMOVE) {
            piece = move.piece;
            switchPiece(game, move.oloc, piece);
            initCell(game, move.nloc);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            if (move.promote) { const color = piece.color_.match(/lt$/);
                                piece.role_ = 'P'; 
                                piece.color_ = (color) ? 'plt' : 'pdt' ;
                                piece.img_.src = getImgSrc(piece.color_);
                              }
            game.unsetMoveHint(takeback_);
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == EATPIECE) {
            piece = move.piece;
            bpiece = Benched.pop();
            switchPiece(game, move.oloc, piece);
            switchPiece(game, bpiece.location_, bpiece);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            if (move.promote) { const color = piece.color_.match(/lt$/);
                                piece.role_ = 'P'; 
                                piece.color_ = (color) ? 'plt' : 'pdt' ;
                                piece.img_.src = getImgSrc(piece.color_);
                              }
            game.unsetMoveHint(takeback_);
            sortBenchedPieces();
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == ENPASSANT) {
            piece = move.piece;
            bpiece = Benched.pop();
            switchPiece(game, move.oloc, piece);
            initCell(game, move.nloc);
            switchPiece(game, bpiece.location_, bpiece);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            game.unsetMoveHint(takeback_);
            sortBenchedPieces();
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == CASTLESHORT) {
            piece = move.piece;
            // king
            switchPiece(game, move.oloc, piece);
            initCell(game, move.nloc);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            // rook
            var oloc_ = null, nloc_ = null;
            if (piece.color_.match(/lt$/)) {
                var oloc_ = "h1", nloc_ = "f1";
            } else {
                var oloc_ = "h8", nloc_ = "f8";
            }
            piece = Board[nloc_].piece;
            switchPiece(game, oloc_, piece);
            initCell(game, nloc_);
            Board[oloc_].piece.location_ = oloc_;
            Board[oloc_].piece.oldlocation_ = null;
            game.unsetMoveHint(takeback_);
            // if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == CASTLELONG) {
           piece = move.piece;
            // king
            switchPiece(game, move.oloc, piece);
            initCell(game, move.nloc);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            // rook
            var oloc_ = null, nloc_ = null;
            if (piece.color_.match(/lt$/)) {
                var oloc_ = "a1", nloc_ = "d1";
            } else {
                var oloc_ = "a8", nloc_ = "d8";
            }
            piece = Board[nloc_].piece;
            switchPiece(game, oloc_, piece);
            initCell(game, nloc_);
            Board[oloc_].piece.location_ = oloc_;
            Board[oloc_].piece.oldlocation_ = null;
            game.unsetMoveHint(takeback_);
            // if (!takeback_) return move.type;
            undone = true; 
       }
       if (undone) {
            Undo.pop();
            if (takeback_) { // repeatdraw and recordmove are not committed during error.
                RepeatDraw_.pop();
                game.unrecordMove();
            }
            if (switchside) {
               var state = game.GAME_STATE;
               game.GAME_STATE.sidetomove_ = ( state.sidetomove_ == WHITE) ? BLACK: WHITE;
               game.GAME_STATE.movecount_ = game.GAME_STATE.movecount_ - ((state.sidetomove_ == WHITE ) ? 0 : 1);
               game.statusGame();
               game.setTimer(true)
            }
       }
       return move.type;
    }


    function find_bishop(Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       for (var i = 1; i <= diff_nh; i++) {
          const h = (oh < nh) ? String.fromCharCode(oh + i) : String.fromCharCode(oh - i);
          const v = (ov < nv) ? (ov + i) : (ov - i);
          if (v < 1 || v > 8) continue;
          const apiece = Board[h + v].piece;
          if ( i == diff_nh ) {  // same destination
              if (apiece != null && apiece.color_.slice(-2) == color) {
                    blocked = 1; _loc = null;
              } else { // eat or move
                    if (h + v == location)  { // found the target
                        if (src != null) { // now select piece, assuming multiple sources
                          if (loc == src || _oh == src || ov == src) { _loc = loc }
                        } else { _loc = loc } // otherwise, choose the only one source
                    }
             }
          } else { if (apiece != null)   { blocked = 1; _loc = null; } }
       }
       if (!blocked) {return _loc; }
       return null;
    }

    function find_rook(Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       if (diff_nv == 0 && diff_nh > 0) {
            for (var i = 1; i <= diff_nh; i++) {
                const h = (oh < nh) ? String.fromCharCode(oh + i) : String.fromCharCode(oh - i);
                const apiece = Board[h + nv].piece;
                  if ( i == diff_nh ) {  // same destination
                      if (apiece != null && apiece.color_.slice(-2) == color) {
                          blocked = 1; _loc = loc;
                      } else { // eat or move
                        if (h + nv == location)  { 
                           if (src != null) { // now select piece, assuming multiple sources
                              if (loc == src || _oh == src || ov == src) { _loc = loc }
                           } else { _loc = loc } // otherwise, choose the only one source
                        }
                      }
                  } else {
                      if (apiece != null) { blocked = 1; _loc = null; } 
                  }
            }
            if (!blocked) {return _loc; }
       } else
       if (diff_nh == 0 && diff_nv > 0) {
            const h = String.fromCharCode(nh);
            for (var i = 1; i <= diff_nv; i++) {
                const v = (ov < nv) ? (ov + i) : (ov - i);
                const apiece = Board[_oh + v].piece;
                if ( i == diff_nv ) {  // same destination
                      if (apiece != null && apiece.color_.slice(-2) == color) {
                          blocked = 1; _loc = null;
                      } else { // eat or move
                        if (h + v == location)  { 
                           if (src != null) { // now select piece, assuming multiple sources
                              if (loc == src || _oh == src || ov == src) { _loc = loc }
                           } else { _loc = loc } // otherwise, choose the only one source
                        }
                      }
                } else { if (apiece != null) { blocked = 1; _loc = null; } }
            }
            if (!blocked) {return _loc; }
       }
       return null;
    }

    function find_knight(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       if ((diff_nh == 1 && diff_nv == 2) || 
           (diff_nh == 2 && diff_nv == 1)) {
         if (bpiece.color_.slice(-2) != color) {
            blocked = 1;
         } else {
            if (src != null) { // now select piece, assuming multiple sources
              if (loc == src || _oh == src || ov == src) { _loc = loc }
            } else { _loc = loc } // otherwise, choose the only one source
         } 
       }
       if (!blocked) { return _loc; }
       return null;
    }

    function find_location(this_, color, role, location, hint = null, src = null) {
      var Board = this_.ChessBoard.Board;
      const locs = [];
      for (var p in Board) {
        const bpiece = Board[p].piece;
        if (bpiece != null) {
            const loc = bpiece.location;
            const oh    = loc[0].charCodeAt(0), ov = parseInt(loc[1]);
            const nh    = location[0].charCodeAt(0), nv = parseInt(location[1]);
            diff_nh = Math.abs(nh - oh); diff_nv = Math.abs(nv - ov);
            if ((color == 'lt' && bpiece.color.match(/lt$/)) || (color == 'dt' && bpiece.color.match(/dt$/)))  {
               if (bpiece.role == "K" && role == "K") {
                  locs.push(loc);
                } else 
                if (bpiece.role == "N" && role == "N") {
                  const floc = find_knight(bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "B" && role == "B") {
                  const floc = find_bishop(Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "R" && role == "R") {
                  const floc = find_rook(Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "Q" && role == "Q") {
                  const floc1 = find_bishop(Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc1 != null) locs.push(floc1);
                  const floc2 = find_rook(Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc2 != null) locs.push(floc2);
                } else 
                if (bpiece.role == "P" && role.match(/[a-h]/) != null) {
                  if (diff_nh == 0 && (diff_nv == 1 || diff_nv == 2)) {
                     const bpiece1 = Board[String.fromCharCode(oh) + ((color == 'lt') ? (ov + 1) : (ov - 1))].piece;
                     if (bpiece1 != null) { continue }; // there is a block.
                     if (hint == null) { // moving
                       if (color == 'dt' && ov > nv) { locs.push(loc); }
                       if (color == 'lt' && ov < nv) { locs.push(loc); }
                    }
                  } else
                  if (diff_nh == 1 && diff_nv == 1) {
                     if (hint != null && hint == "x") { // eating
                        const loc1 = loc[0];
                        if (loc[0] == role) {
                           if (color == 'dt' && ov > nv) { locs.push(loc); }
                           if (color == 'lt' && ov < nv) { locs.push(loc); }
                        }
                     }
                  } 
                }
            }
        }
      }
      return locs;
    }

    // Audio
    function playawalker() {
       // const audio = new Audio("/audio/AlanWalker.mp3");
       const audio = new Audio("/audio/shortawalker.mp3");
       audio.volume = 0.5;
       return audio;
    }

    function chessreset() {
       const audio = new Audio("/audio/chessreset.mp3");
       audio.volume = 1.0;
       return audio;
    }
    function chesscastle() {
       const audio = new Audio("/audio/chesscastle.mp3");
       audio.volume = 1.0;
       return audio;
    }
    function chessmove() {
       const audio = new Audio("/audio/chessmove.mp3");
       audio.volume = 1.0;
       return audio;
    }
    function chesscapture() {
       // const audio = new Audio("/audio/chesscapture.mp3");
       const audio = new Audio("/audio/chess_eat.mp3");
       audio.volume = 1.0;
       return audio;
    }

    var PLAY_AW_ = false;
    function playAW() {
        PLAY_AW_ = (PLAY_AW_) ? false: true;
        const music_ = document.getElementById("musicid");
        if (PLAY_AW_) { 
            music_.innerHTML = "&#9834;";
            chess_awalker.playbackRate = 1.0;
         } else  { 
            music_.innerHTML = "&#9632;";
            chess_awalker.pause(); chess_awalker.currentTime = 0 
         };
    } 

    // audio objects
    const chess_awalker = playawalker();
    const chess_move = chessmove();
    const chess_capture = chesscapture();
    const chess_castle = chesscastle();
    const chess_reset = chessreset();

    var parser = null;
    async function loadParser() {
        const res = await fetch('/jscripts/pgngrammar.pegjs');
        const grammer = await res.text();
        parser = PEG.buildParser(grammer);
    }


    const pause = time => new Promise(resolve => setTimeout(resolve, time))
    const musictime_ = document.getElementById("musictimeid");
    var MUSIC_TIME = musictime_.value;

    /* Remove - obsolete */
    function movePiece(color, move, spanmove, sound = true) {
        var src_loc = null, dest_loc = null, role = null, src = null, hint = null;
        var piece = (color == 'lt') ? move.white : move.black;  
        var len = piece.length;
        role = piece[0]; 
        dest_loc = piece.slice(-2);
        if (piece == "O-O") {
             src_loc = [ (color == 'lt') ? "e1" : "e8" ]; dest_loc = (color == 'lt') ? "g1" : "g8";
        } else
        if ( piece == "O-O-O") {
             src_loc = [ (color == 'lt') ? "e1" : "e8" ]; dest_loc = (color == 'lt') ? "c1" : "c8";
        } else if (len == 2) {
             dest_loc = piece;
             src_loc = find_location(color, piece[0], dest_loc);
        } else if (len == 3) {
             src_loc = find_location(color, role, dest_loc);
        } else
        if (len == 4) { // e.g. Rxe1 exd1 Rhe1
             hint = piece[1];
             if (hint != 'x') { hint = null; src = piece[1]; }
             src_loc = find_location(color, role, dest_loc, hint, src);
        } else
        if (len == 5) { // e.g. Rhxe1 R8xe1  Nh8g6
             hint = piece[2];
             if (hint == 'x') {
                   src = piece[1];
             } else {
                   hint = null;
                   src = piece.slice(1,3).match(/[a-h][1-8]/)[0]
             }
             src_loc = find_location(color, role, dest_loc, hint, src);
        } else
        if (len == 6) { // e.g. Rh8xe1
             src = piece.slice(1,3); hint = piece[3];
             src_loc = find_location(color, role, dest_loc, hint, src);
        }
        if (src_loc.length < 1) illegal_move('Illegal move (99)!');
        log("Final " + color + " location: " + src_loc + " " + dest_loc);
  /*
        if (spanmove != null) { spanmove.className = "chesspiecenomove"; }
        const mid = (color == 'lt') ? "moveidl" : "moveidd"
        spanmove = document.getElementById( mid + move.step);
        if (spanmove != null) spanmove.className = "chesspiecemove";
        piece = place(src_loc, dest_loc, (color == 'lt') ? move.wpromote : move.bpromote, sound);
        return { piece: piece, spanmove: spanmove };
   */
        return { src: src_loc, dst: dest_loc };
    }

    
    var F_WELO_OPS_ = null, F_BELO_OPS_ = null, F_MOVES_OPS_ = null, 
        F_WELO_ = null, F_BELO_ = null, F_MOVES_ = null, F_RES1_ = null, F_RES2_ = null, F_RES3_ = null;
    function filterPlay() {
        f_welo_ops = document.getElementById("filter_welo_ops");
        f_belo_ops = document.getElementById("filter_belo_ops");
        f_moves_ops = document.getElementById("filter_moves_ops");
        f_welo = document.getElementById("filter_welo");
        f_belo = document.getElementById("filter_belo");
        f_moves = document.getElementById("filter_moves");

        f_res1 = document.getElementById("filter_res1");
        f_res2 = document.getElementById("filter_res2");
        f_res3 = document.getElementById("filter_res3");

        F_WELO_OPS_ = f_welo_ops.options[f_welo_ops.selectedIndex].value;
        F_BELO_OPS_ = f_belo_ops.options[f_belo_ops.selectedIndex].value;
        F_MOVES_OPS_ = f_moves_ops.options[f_moves_ops.selectedIndex].value;

        F_WELO_ = f_welo.value; F_BELO_ = f_belo.value; F_MOVES_ = f_moves.value;
        F_RES1_ = (f_res1.checked) ? f_res1.value : null;
        F_RES2_ = (f_res2.checked) ? f_res2.value : null;
        F_RES3_ = (f_res3.checked) ? f_res3.value : null;
    }

    var ECO_ = null;
    async function loadECO() {
        const res = await fetch('/jscripts/eco2.pgn');
        var eco = await res.text();
        eco = eco.split(/\n/);
        const eco_ = []
        for (var p in eco) {
            const variation = eco[p].replace(/"/g,"").replace(/[ ]+/g, " ").split("~");
            variation[variation.length-1] = variation[variation.length-1].replace(/([0-9]+\.) /g, "$1");
            eco_.push(variation);
        }
        ECO_ = eco_;
    }

    function findECO(eco, moves) {
        var eco_ = null;
        for (p in ECO_) {
          var peco = ECO_[p];
          if (peco[0] == eco) {
             eco_ = { eco: peco[0], variation: peco[2], opening:  peco[1] }
             break;
          }
        }
        return eco_; 
    }


    
    /* Remove - obsolete */
    var LASTMOVE_ = null;
    function moveIt(count_, move, chk = '') {
        const wmove = move.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, '');
        if (ANALYZEGAME_ && ecoGame_.length == 0) { // handle premove for white ...
          if (count_ == 1 && SIDETOMOVE_ == BLACK) {
             const movespan0 = document.createElement("span");
             const movespan1 = document.createElement("span");
             const movespan2 = document.createElement("span");
             const movespace1 = document.createTextNode(" ");
             const movechk1 = document.createElement("span"); movechk1.innerHTML = chk; movechk1.className = 'chesscmt';
             const movecmt1 = document.createElement("span"); movecmt1.innerHTML = ""; movecmt1.className = 'chesscmt';
             movechk1.id = "chk_" + count_ + "_premove";
             movespan0.innerHTML = count_ + ".";
             movespan1.innerHTML = "(...)"; movespan1.id = "moveid" + count_ + "w";
             movespan0.className = "chesspiecestep";
             movespan1.className = "chesspiecenomove";
             CHESSGAME_.appendChild(movespan0);
             CHESSGAME_.appendChild(movespan1);
             CHESSGAME_.appendChild(movechk1);
             CHESSGAME_.appendChild(movecmt1);
             CHESSGAME_.appendChild(movespace1);
             ecoGame_.push( movespan0.innerHTML + "(...)" + chk);
          }

        }
        const movespan0 = document.createElement("span");
        const movespan1 = document.createElement("span");
        const movespan2 = document.createElement("span");
        const movespace1 = document.createTextNode(" ");
        const movechk1 = document.createElement("span"); movechk1.innerHTML = chk; movechk1.className = 'chesscmt';
        const movecmt1 = document.createElement("span"); movecmt1.innerHTML = ""; movecmt1.className = 'chesscmt';
        movechk1.id = "chk_" + count_ + "_" + move;
        LASTMOVE_ = movechk1.id;
        if (SIDETOMOVE_ == WHITE) { movespan0.innerHTML = count_ + "."; }
        movespan1.innerHTML = wmove; movespan1.id = "moveid" + count_ + ((SIDETOMOVE_ == WHITE) ? "w" : "b");
        movespan0.className = "chesspiecestep";
        movespan1.className = "chesspiecenomove";

        CHESSGAME_.appendChild(movespan0);
        CHESSGAME_.appendChild(movespan1);
        CHESSGAME_.appendChild(movechk1);
        CHESSGAME_.appendChild(movecmt1);
        CHESSGAME_.appendChild(movespace1);
        ecoGame_.push( movespan0.innerHTML + move.replace(/P/g, '') + chk);
    } 


    function showGame(obj) {
       var g = obj.innerHTML;
       g = g.replace(". ", ""); 
       const game_ = document.getElementById("gametrid" + g);
       game_.scrollIntoView();
    }



    function keyPress() { document.onkeydown = keyPlay; }

    async function keyPlay(e) {
        e.preventDefault();
        e = e || window.event;
       if (e.keyCode == '38') { // up
         jumpToStart(chessdiv);
       }
       else if (e.keyCode == '40') { // down
         jumpToEnd(chessdiv);
       }
       else if (e.keyCode == '37') { // left
         backwardPlay(chessdiv);
       }
       else if (e.keyCode == '39') {  // right
         forwardPlay(chessdiv);
       }
    }

    // calculate time
    function calcTime(timer, start) {
        const sec = ( Date.now() - start ) / 1000;
        const hr = Math.floor(sec / 3600);
        const min = (sec % 3600) / 60;
        timer.innerHTML = hr + ":" + min.toFixed(1);
    }

    function emptyBench() {
       while (Benched.length) Benched.pop();
       wcapture.innerHTML = '';
       bcapture.innerHTML = '';
    }

/*
    function interruptRepeat() {
         REPEATPLAY_ = false;    
         chess_awalker.pause();
    }

    var jmp_interval = 0, jumptime = null;
    async function readyJump(obj) {
        jmp_interval += 1;
        if (jmp_interval > 20) { jmp_interval = 0; clearInterval(jumptime)  }
        if (!PLAYING) {
          jmp_interval = 0;
          clearInterval(jumptime);
          MOVETRACKER_ = obj.internal_.tracker_;
          CURRENTCOLOR_ = obj.internal_.color;
          return await jump1Move();
        }
    } 

    async function jumpPlay() {
        if (REPEATPLAY_) return;
        if (PLAYING) {
          INTERRUPT = true;
          jmp_interval = 0;
          jumptime = setInterval(readyJump, 50, this);
        } else {
          const obj = this;
          MOVETRACKER_ = obj.internal_.tracker_;
          CURRENTCOLOR_ = obj.internal_.color;
          return await jump1Move();
        }
    }
*/

    async function forwardPlay(this_) {
        var this_ = this_.game_;
        var current_ = parseInt(this_.GAME_STATE.playcurrent_);
        if (isNaN(current_)) return;
        var last_ = this_.Moves_.length - 1; 
        current_ = (current_ == last_) ? current_ : current_ + 1;
        await this_.jumpMove(null, current_);
    }

    async function backwardPlay(this_) {
        var this_ = this_.game_;
        var current_ = parseInt(this_.GAME_STATE.playcurrent_);
        if (isNaN(current_)) return;
        current_ = (current_ == 0) ? current_ : current_ - 1;
        await this_.jumpMove(null, current_);
    }


    async function jumpToStart(this_) {
        var this_ = this_.game_;
        var current_ = parseInt(this_.GAME_STATE.playcurrent_);
        if (isNaN(current_)) return;
        await this_.jumpMove(null,  0);
    }

    async function jumpToEnd(this_) {
        var this_ = this_.game_;
        var current_ = parseInt(this_.GAME_STATE.playcurrent_);
        if (isNaN(current_)) return;
        var last_ = this_.Moves_.length - 1; 
        await this_.jumpMove(null, last_);
    }

    function evalFilter(game) {
       var filter_ = true ;
       var moves_ = game.moves.split(' ').length - 4; moves_ = Math.floor(moves_ / 2); 
       if (F_WELO_OPS_ == "=") if (parseInt(game.we) != parseInt(F_WELO_)) filter_ = false;
       if (F_WELO_OPS_ == ">=") if (parseInt(game.we) < parseInt(F_WELO_)) filter_ = false;
       if (F_WELO_OPS_ == "<=") if (parseInt(game.we) > parseInt(F_WELO_)) filter_ = false;

       if (F_BELO_OPS_ == "=") if (parseInt(game.we) != parseInt(F_BELO_)) filter_ = false ;
       if (F_BELO_OPS_ == ">=") if(parseInt(game.we) < parseInt(F_BELO_))  filter_ = false;
       if (F_BELO_OPS_ == "<=") if(parseInt(game.we) > parseInt(F_BELO_))  filter_ = false;

       if (F_MOVES_OPS_ == "=") if (moves_ != parseInt(F_MOVES_))  filter_ = false;
       if (F_MOVES_OPS_ == ">=") if (moves_ < parseInt(F_MOVES_)) filter_ = false;
       if (F_MOVES_OPS_ == "<=") if (moves_ > parseInt(F_MOVES_))  filter_ = false;

       if (F_RES1_ == null) if (game.rt == "1-0")  filter_ = false;
       if (F_RES2_ == null) if (game.rt == "0-1")  filter_ = false;
       if (F_RES3_ == null) if (game.rt == "1/2-1/2")  filter_ = false;

       return filter_;
    }


    function sortGames(g1, g2) {
         var res = 0, ORDER = 0;
         for (var i=1; i<=6; i++) {
           ORDER = ORDERS_[i-1];
           if (ORDER != 0) {
              if (ORDER == 1) {
                  if (i == 1)  res =  ((g2.wp) > (g1.wp)) ? 1 : -1;
                  if (i == 2)  res =  ((g2.we) > (g1.we)) ? 1 : -1;
                  if (i == 3)  res =  ((g2.bp) > (g1.bp)) ? 1 : -1;
                  if (i == 4)  res =  ((g2.be) > (g1.be)) ? 1 : -1;
                  if (i == 5)  res =  ((g2.rt) > (g1.rt)) ? 1 : -1;
                  if (i == 6)  res =  ((g2.ct) > (g1.ct)) ? 1 : -1;
              } else
              if (ORDER == 2) {
                  if (i == 1)  res =  ((g2.wp) < (g1.wp)) ? 1 : -1;
                  if (i == 2)  res =  ((g2.we) < (g1.we)) ? 1 : -1;
                  if (i == 3)  res =  ((g2.bp) < (g1.bp)) ? 1 : -1;
                  if (i == 4)  res =  ((g2.be) < (g1.be)) ? 1 : -1;
                  if (i == 5)  res =  ((g2.rt) < (g1.rt)) ? 1 : -1;
                  if (i == 6)  res =  ((g2.ct) < (g1.ct)) ? 1 : -1;
              }
          }
         }
         return res;
    }

    // order List // &#8593; up // &#8595; down // &#8597; neutral
    // 0 = no order, 1 = descending, 2 = ascending

    const ORDERS_ = [0,0,0,0,0,0];
    // 0 = no order, 1 = descending, 2 = ascending
    function orderGame(title, id, elem) {
        const tbody = document.getElementById('tbodylistingid');
        if (tbody == null) { message(this_, "No database loaded ...", false); return; }
        const this_ = tbody.ordergame_;
        if (ORDERS_[id] == 0) {
            elem.innerHTML = title + ' &#8593;';
            ORDERS_[id] = 1;
        } else
        if (ORDERS_[id] == 1) {
            elem.innerHTML = title + ' &#8595;';
            ORDERS_[id] = 2;
        } else
        if (ORDERS_[id] == 2) {
            elem.innerHTML = title + ' &#8597;';
            ORDERS_[id] = 0;
        } 

        const games = this_.Games.sort(sortGames)
        refreshListing(this_, games);
    }

    function orderWhite(elem) {
        orderGame('White', 0, elem);
    }

    function orderBlack(elem) {
        orderGame('Black', 2, elem);
    }

    function orderWhiteElo(elem) {
        orderGame('ELO', 1, elem);
    }

    function orderBlackElo(elem) {
        orderGame('ELO', 3, elem);
    }

    function orderResult(elem) {
        orderGame('Result', 4, elem);
    }

    function orderCount(elem) {
        orderGame('Result', 5, elem);
    }

    async function refreshListing(this_, Games) {
        var chessls = this_.chessls_;
        const chesstable = chessls.getElementsByClassName("chesstableid")[0];
        const tbody = document.createElement('tbody');
        tbody.id = 'tbodylistingid';
        tbody.ordergame_ = this_;
        if (chesstable.firstChild != null) {
            chesstable.replaceChild(tbody, chesstable.firstChild);
        } else {
            chesstable.appendChild(tbody);
        }
        var td = null, txtnode;
        var game_cnt = 0;
        for (var p in Games) {
            const game = Games[p]
           if (game.we != "" && game.be != "") {

            game_cnt += 1;
            const tr = document.createElement("tr");
            tr.style.backgroundColor = (parseInt(p) % 2 ? '#2a2a2a' : '#3a3a3a' );
            const tdcnt = document.createElement("td"); const cnt = document.createTextNode(game_cnt);
            const tdev = document.createElement("td"); const ev = document.createTextNode(game.ev.slice(0,20));
            const tdwp = document.createElement("td"); const wp = document.createTextNode(game.wp.slice(0,20));
            const tdbp = document.createElement("td"); const bp = document.createTextNode(game.bp.slice(0,20));
            const tdwe = document.createElement("td"); const we = document.createTextNode(game.we);
            const tdbe = document.createElement("td"); const be = document.createTextNode(game.be);
            const tdrt = document.createElement("td"); const rt = document.createTextNode(game.rt);
            const tdbt = document.createElement("td"); const bt = document.createElement("button");
            const tdec = document.createElement("td");
            const ec = document.createTextNode(typeof game.eco === "undefined" ? "" : game.eco);

            const tdct = document.createElement("td"); const ct = document.createTextNode(game.ct);
            tdev.appendChild(ev); tdcnt.appendChild(cnt); 
            tdwp.appendChild(wp); tdbp.appendChild(bp); tdwe.appendChild(we);
            tdbe.appendChild(be); tdrt.appendChild(rt); tdbt.appendChild(bt);
            tdct.appendChild(ct); tdec.appendChild(ec);

            tr.id = "gametrid" + p;
            tr.appendChild(tdbt); tr.appendChild(tdcnt); tr.appendChild(tdct);
            tr.appendChild(tdwp); tr.appendChild(tdwe);
            tr.appendChild(tdbp); tr.appendChild(tdbe); tr.appendChild(tdrt);
            tr.appendChild(tdec); tr.appendChild(tdev); tr.appendChild(tdct);
            tr.className = "chesstr";
            tdcnt.className = "chesstdb"; tdev.className = "chesstde";  tdec.className = "chesstce";
            tdwp.className = "chesstdp"; tdbp.className = "chesstdp"; tdwe.className = "chesstdl";
            tdbe.className = "chesstdl"; tdrt.className = "chesstdr";  tdbt.className = "chesstdb";
            tdct.className = "chesstdb";
            tbody.appendChild(tr);

            bt.game_ = this_;
            bt.innerHTML = "&#8594;";
            bt.onclick = await this_.playNext;
            bt.value = p;
            bt.id = "gameid_" + p;
            bt.style.backgroundColor = '#4a4a4a';
            bt.style.color = '#afafaf';
            tr.className = "chesstr"; 
           }
        }
        this_.tbox.prevgame_ = null;
  /*
        var current_ = document.getElementById("currentgameid");
        current_.innerHTML = Games.length + '. ';
  */
        chessls.style.visibility = 'visible';
    }

     var FETCHEDGAME_ = false;
     function refreshGames(sorted = false, bttn_ = null) {
        // populate html
        const chesstable = document.getElementById("chesstableid");
        const tbody = document.createElement('tbody');

        if (chesstable.firstChild != null) {
            chesstable.replaceChild(tbody, chesstable.firstChild);
        } else {
            chesstable.appendChild(tbody);
        }

        var td = null, txtnode;
        var game_cnt = 0;
        filterPlay();
        for (var p in Games) {
            const game = Games[p]
           if (game.we != "" && game.be != "") {
            if (evalFilter(game) ==  false) continue;
            game_cnt += 1;
            // var moves_ = game.moves.split(' ').length - 4; moves_ = Math.floor(moves_ / 2); 
            if (game_cnt == 1) {
              const tr1 = document.createElement("tr");
              const td1 = document.createElement("td"); td1.appendChild(document.createTextNode(""));
              const td2 = document.createElement("td"); td2.appendChild(document.createTextNode(""));
              const td3 = document.createElement("td"); td3.appendChild(document.createTextNode(""));
              const td4 = document.createElement("td"); td4.appendChild(document.createTextNode(""));
              const tdowp  = document.createElement("td"); const owp = document.createElement("button");
              const tdowe  = document.createElement("td"); const owe = document.createElement("button");
              const tdobp  = document.createElement("td"); const obp = document.createElement("button");
              const tdobe  = document.createElement("td"); const obe = document.createElement("button");
              const tdort  = document.createElement("td"); const ort = document.createElement("button");
              const tdocnt = document.createElement("td"); const ocnt = document.createElement("button");
              // #8593; up // &#8595; down
              tdowp.appendChild(owp); tdowe.appendChild(owe); tdobp.appendChild(obp); 
              tdobe.appendChild(obe); tdort.appendChild(ort); tdocnt.appendChild(ocnt);
              const bts_ = [ owp, owe, obp, obe, ort, ocnt ];
              for (var i=1; i<=6; i++ ) {
                  const bt_ = bts_[i-1];
                  bt_.onclick = orderGame;
                  bt_.value = i;
                  bt_.innerHTML = ORDERSDESC_[i-1] + "&#8597;"; 
                  if (sorted && bttn_ == i) {
                    if (ORDERS_[i-1] == 1) bt_.innerHTML = ORDERSDESC_[i-1] + "&#8595;"; else
                    if (ORDERS_[i-1] == 2) bt_.innerHTML = ORDERSDESC_[i-1] + "&#8593;"; 
                  }
              }
              tr1.appendChild(td1);
              tr1.appendChild(td2);
              tr1.appendChild(tdowp); tr1.appendChild(tdowe);
              tr1.appendChild(tdobp); tr1.appendChild(tdobe);
              tr1.appendChild(tdort); 
              tr1.appendChild(td3);
              tr1.appendChild(td4);
              tr1.appendChild(tdocnt);
              tdowp.className = "chesstdp"; tdobp.className = "chesstdp"; 
              tdowe.className = "chesstdl"; tdobe.className = "chesstdl"; 
              td1.className = "chesstdb"; td2.className = "chesstdb";
              td3.className = "chesstce"; td4.className = "chesstde";
              tdort.className = "chesstdb";
              tr1.className = "chesstr"; 
              tbody.appendChild(tr1);
            }

            const tr = document.createElement("tr");

            const tdcnt = document.createElement("td"); const cnt = document.createTextNode(game_cnt);
            const tdev = document.createElement("td"); const ev = document.createTextNode(game.ev.slice(0,35));
            const tdwp = document.createElement("td"); const wp = document.createTextNode(game.wp.slice(0,23));
            const tdbp = document.createElement("td"); const bp = document.createTextNode(game.bp.slice(0,23));
            const tdwe = document.createElement("td"); const we = document.createTextNode(game.we);
            const tdbe = document.createElement("td"); const be = document.createTextNode(game.be);
            const tdrt = document.createElement("td"); const rt = document.createTextNode(game.rt);
            const tdbt = document.createElement("td"); const bt = document.createElement("button"); 
            const tdec = document.createElement("td"); 
            const ec = document.createTextNode(typeof game.eco === "undefined" ? "" : game.eco); 

            const tdct = document.createElement("td"); const ct = document.createTextNode(game.ct);
            tdev.appendChild(ev); tdcnt.appendChild(cnt);
            tdwp.appendChild(wp); tdbp.appendChild(bp); tdwe.appendChild(we); 
            tdbe.appendChild(be); tdrt.appendChild(rt); tdbt.appendChild(bt);
            tdct.appendChild(ct); tdec.appendChild(ec);
            tr.id = "gametrid" + p;
            tr.appendChild(tdbt); tr.appendChild(tdcnt); tr.appendChild(tdct); 
            tr.appendChild(tdwp); tr.appendChild(tdwe); 
            tr.appendChild(tdbp); tr.appendChild(tdbe); tr.appendChild(tdrt);
            tr.appendChild(tdec); tr.appendChild(tdev); tr.appendChild(tdct); 
            tr.className = "chesstr";
            tdcnt.className = "chesstdb"; tdev.className = "chesstde";  tdec.className = "chesstce";
            tdwp.className = "chesstdp"; tdbp.className = "chesstdp"; tdwe.className = "chesstdl";
            tdbe.className = "chesstdl"; tdrt.className = "chesstdr";  tdbt.className = "chesstdb";
            tdct.className = "chesstdb";
            tbody.appendChild(tr);

            bt.innerHTML = "&#8594;";
            bt.onclick = proceedPlay;
            bt.value = p;
            bt.id = "gameid" + p;

            if (p == '0') {
              tr.className = "chesstr chesstrcurrent";
              tr.scrollIntoView();
              PLAYBUTTON = bt;
            }
           }
        }
        var current_ = document.getElementById("currentgameid");
        var repeatbt = document.getElementById("repeatid");
        current_.innerHTML = '1. ';
        repeatbt.value = "&#9654;"; repeatbt.innerHTML = "&#9654;";
        const totalid = document.getElementById("totalid"); totalid.innerHTML = game_cnt;
        MOVETRACKER_ = null; CURRENTCOLOR_ = null; LOADPGN_ = false; INTERRUPT = false;
        REPEATPLAY_ = false; REPEATWHERE_ = null; REPEATBUTTON_ = null; 
        chess_awalker.pause(); chess_awalker.currentTime = 0
        initializePlay(0);
   }

   function findEmptyCube() {
       const cubes = cubicle.getElementsByClassName('cubelet');
       for (var p in cubes) {
         const cube = cubes[p];
         if (cube.firstChild) continue;
         return cube;
       }
       return null;
   }


   async function unpinCube() {
     var container_ = this.container_;
     if (typeof(container_) != "undefined") {

        var img = this, game = img.game_;
        var cube = img.parentNode;
        const wind = cube.cloneNode(false);
        wind.style.border = '2px solid #ff0000';
        wind.style.backgroundColor = '';
        wind.style.margin = '0px 0px 0px 0px';
        wind.style.zIndex = 200000;
        var top = parseInt(wind.style.top);
        var left = parseInt(wind.style.left);
        var width = parseInt(wind.style.width);
        var height = parseInt(wind.style.height);
        chessdiv.appendChild(wind);

        img.style.visibility = 'hidden';

        var top1 = parseInt(container_.style.top);
        var left1 = parseInt(container_.style.left);
        var width1 = parseInt(container_.style.width);
        var height1 = parseInt(container_.style.height);
        const size = '36';
        var mw = width1 / 10;
        var mh = height1 / 10;
        var offsetL = 0, offsetT = 0;
        var osetL = parseInt(container_.style.left), osetT = parseInt(container_.style.top);
        var topc = 0, leftc = 0;
        var ml = 0, mt = 0;

       var offsetL1 = img.parentNode.offsetLeft, offsetT1 = img.parentNode.offsetTop;
       var offsetL2 = img.parentNode.parentNode.offsetLeft, offsetT2 = img.parentNode.parentNode.offsetTop;
       var topc = parseInt(img.parentNode.offsetTop), leftc = parseInt(img.parentNode.offsetLeft);
       offsetL = offsetL1 + offsetL2, offsetT = offsetT1 + offsetT2;

       wind.style.top = offsetT + 'px';
       wind.style.left = offsetL + 'px';
       wind.style.width = size + 'px';
       wind.style.height = size + 'px';

       ml = (osetL - offsetL) / 10; mt = (osetT - offsetT ) / 10;
       var mwidth = size - 0; mheight = size - 0;
       top = offsetT; left = offsetL;


       var next = cube.parentNode.firstChild;
       while (next) {
           if (next.nodeType == 1) {
              if (next.game_ != null && next.game_ == game) {
                 cube.parentNode.removeChild(next); break;
              }
           }
           next = next.nextSibling;
        }

       for (var i=1; i <= 10; i++) {
          mwidth = mwidth + mw;
          mheight = mheight + mh;
          left = left + ml;
          top = top + mt;
          wind.style.width = ( mwidth > width1 ? width1 : mwidth ) + 'px';
          wind.style.height = (mheight > height1 ? height1 : mheight) + 'px';
          wind.style.top = top + 'px';
          wind.style.left = left + 'px';
          await pause(10);
       }
       wind.style.width =  width1 + 'px';
       wind.style.height = height1 + 'px';
       wind.style.top = osetT  + 'px';
       wind.style.left = osetL  + 'px';
       wind.parentNode.removeChild(wind); 
       while (cube.firstChild) cube.removeChild(cube.firstChild);

       const con_ = document.getElementById('contr_' + game);
       if (con_ != null) {
          ZINDEX_ ++;
          con_.style.zIndex = ZINDEX_;
          con_.chessmoves_.style.zIndex = ZINDEX_;
       }
      
        container_.style.display = '';
        container_.chessmoves_.style.display = '';
     }
   }

   async function pinCube(game) {
       const img = document.createElement('img');
       const cubes = cubicle.getElementsByClassName('cubelet');
       const container_ = document.getElementById('contr_' + game);
       const cube = findEmptyCube();
       const size = '36';
       img.src = '/images/chesscubes.svg';
       img.style = 'position: absolute; left: 0px; top: 0px; width: ' + size + 'px; height: ' + size + 'px; border: 2px solid #4a4a4a';
       img.onclick = unpinCube;
       img.container_ = container_;
       img.game_ = game;
       img.style.visibility = 'hidden';
       cube.appendChild(img);
       const wind = container_.cloneNode(false);
       const pin = document.createElement('span'); 

       chessdiv.appendChild(wind);
       container_.style.display = 'none';
       container_.chessmoves_.style.display = 'none';
       pin.innerHTML = '&#x1F4CD'; // '&#x1F4CC';
       pin.game_ = game;
       wind.style.border = '2px solid #ff0000';
       wind.style.backgroundColor = '#24262A';
       wind.style.zIndex = 200000;
       var top = parseInt(wind.style.top);
       var left = parseInt(wind.style.left);
       var width = parseInt(wind.style.width);
       var height = parseInt(wind.style.height);
       var mw = width / 10;
       var mh = height / 10;
       var offsetL = 0, offsetT = 0;
       var osetL = parseInt(wind.style.left), osetT = parseInt(wind.style.top);
       var topc = 0, leftc = 0;
       var ml = 0, mt = 0;

       var offsetL1 = img.parentNode.offsetLeft, offsetT1 = img.parentNode.offsetTop;
       var offsetL2 = img.parentNode.parentNode.offsetLeft, offsetT2 = img.parentNode.parentNode.offsetTop;
       var topc = parseInt(img.parentNode.offsetTop), leftc = parseInt(img.parentNode.offsetLeft);
       offsetL = offsetL1 + offsetL2, offsetT = offsetT1 + offsetT2;

       ml = (osetL - offsetL) / 10; mt = (osetT - offsetT ) / 10;
       for (var i=1; i <= 10; i++) {
          width = width - mw; 
          height = height - mh; 
          left = left - ml; 
          top = top - mt; 
          wind.style.width = width + 'px';
          wind.style.height = height + 'px';
          wind.style.top = top + 'px';
          wind.style.left = left + 'px';
           
          await pause(10); 
       }
       wind.style.width =  size + 'px';
       wind.style.height = size + 'px';
       wind.style.top = offsetT + 'px';
       wind.style.left = offsetL + 'px';
       wind.parentNode.removeChild(wind); 
       cube.parentNode.appendChild(pin);
       pin.style = 'position: absolute; top: ' + (cube.offsetTop - 8 ) + 'px; left: 35px; z-index: 10';
       img.style.visibility = 'visible';

   }

   BOARDS_ = [];
   BOARDTOP_ = 50;
   DEFAULTCOLOR_ = 'Cyan';
   function newBoard(e, hide = true, width = 480, height = 480) {
      if(!e.detail || e.detail == 1) {
        e.preventDefault();
        var cnt = BOARDS_.length + 1;
        var title = 'game' + cnt, top = 40 + BOARDTOP_ * cnt, left = 145 + BOARDTOP_ * cnt ;
        var game = new Game(title, chessdiv, top=top, left=left, width=width, height = height, DEFAULTCOLOR_, padding=14, control = hide);
        BOARDS_.push(game);
     }
   }

   function  createPGNWindow() {
        const height = parseInt(chessls.style.height);
        const width = parseInt(chessls.style.width);
        const pos = pageSize();
        chessls.style.visibility = 'visible';
        chessls.style.position = 'fixed';
        chessls.style.left = '5px';
        chessls.style.top =  pos.height + 'px';
        window.onresize = onWindowResize;
        chessdiv.appendChild(chessls);
        chessdiv.PGNWindow_ = false;
        setPGNControl(chesscv);

        var next = chessor.firstChild;
        while (next) {
           if (next.nodeType == 1) next.order
          next = next.nextSibling;
        }
    }

    function setPGNControl(chesscv) {
         if (typeof(chesscv.filled_) != "undefined") return;
         const icons = ['&#x21A5;', '&#x25B6;', '&#x266C;' ];
         const func  = [ showPGNWindow, prepareContinuousPlay, playAW ];
         const title = [ 'Show/Hide PGN Window', 'Play Continuously', 'Enable Music' ];
         for (var i=0; i<3; i++) {
            const ctrl = document.createElement('span');
            ctrl.style = 'position: absolute; cursor: pointer; top: 2px; left: ' + (5 + i * 28) +  'px';  // above the board
            ctrl.innerHTML = icons[i];
            ctrl.onclick = func[i];
            ctrl.title = title[i];
            chesscv.appendChild(ctrl);
         }
          chesscv.filled_ = true;
     }

     function prepareContinuousPlay() {
        var this_ = chessdiv.loadedgame_;
        if (this_ != null) {
            this_.continuousPlay(this);
        }
     }

     async function showPGNWindow(e, show = false) {
         const pos = pageSize();
         const height = parseInt(chessls.style.height);
         const width = parseInt(chessls.style.width);
         const left = '5px'
         const top = ( pos.height);
         chessls.style.left = left + 'px';
         if (show && chessdiv.PGNWindow_) return;
         chessdiv.PGNWindow_ = (chessdiv.PGNWindow_) ? false : true;
        
         if (chessdiv.PGNWindow_) {
           for (var i=top; i >= (top - height); i-=10) {
              chessls.style.top = i + 'px';
              await pause(1);
           }
           chessls.style.top = (top - height) + 'px';
           chesscv.firstChild.innerHTML = '&#x21A7;';
         } else {
           for (var i=(top - height); i <= top; i+=10) {
              chessls.style.top = i + 'px';
              await pause(1);
           }
           chessls.style.top = (top) + 'px';
           chesscv.firstChild.innerHTML = '&#x21A5;';
         }
     }

     function onWindowResize() {
         const pos = pageSize();
         const chessls = document.getElementById('chesslisting');
         const chessid = document.getElementById('chesslistid');
         const condiv = document.getElementById('playcontrolid');
         const height = parseInt(chessls.style.height);
         const width = parseInt(chessls.style.width);
         const left = '5px';
         const top = ( pos.height - height);
         chessls.style.left = left + 'px';
        if (chessdiv.PGNWindow_) {
           chessls.style.top = top + 'px';
        } else {
           chessls.style.top = pos.height + 'px';
        }

     }

     /**** authenticate ******
     function signup(this_) {
log(this_);
     }

     function signin(this_) {
log(this_);
     }

     /**************** LET'S HANDLE SOCKET.IO *****************/
     const socket = io("http://localhost:3000", {
          transports: ["websocket", "polling"] // use WebSocket first, if available
     });

     socket.on("connect_error", () => {
          // revert to classic upgrade
          socket.io.opts.transports = ["polling", "websocket"];
     });


   log("Load Parser ...");
   loadParser();
   log("Load ECO ...");
   loadECO();
   log("Load Stockfish ...");
   loadStockfish();
   log("Enable Key Event Capture ...");
   keyPress();

   log("Create PGN Window ...");
   createPGNWindow();
   
   log("Load One Board ...");
   newBoard({detail: 1, preventDefault: function() {} }, false, width=780, height=780 );

</script>
</body>
</html>
