<DOCTYPE html>
<html lang="en" Cross-Origin-Embedder-Policy: require-corp>
<head>
  <meta charset="UTF-8">
  <title>Chess Repertoire</title>
<style type="text/css" title="mycsslist">
.piece { position: absolute; width: 0px; height: 0px; margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; border: 0px solid #00ff00; }

.chessdiv { position: absolute; top: 0px; left: 0px; width: 5000px; height: 10000px; background-color: #24262A; margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px }
.chesscontainer { position: absolute; border: 3px solid #dedede; margin: 25px 0px 25px 0px; padding: 0px 0px 0px 0px; border-radius: 0px 0px 0px 0px; }
.chessblanket { position: fixed; top: 40px; left: 0px; width: 5000px; height: 5000px; background-color: #24262A; 
                margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; z-index: 5001 }
.chessbox  { position: absolute; margin: 0px; padding: 0px 0px 0px 0px; width: 640px; height: 640px; background-color: #a7b093 }
.chesstable { border-collapse: collapse; width: 100%; height: 100%; margin: 0px; padding: 0px; }
.chessboard { position: absolute; top: 0px; left: 0px;  margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px }
.chessboardimg { position: absolute; top: 0px; left: 0px; width: 840px; height: 840px;; margin: 0px 0px 0px 0px  }
.chessheader { position: absolute; top: 0px; left: -100px; width: 0px; height: 25px; color: #afafaf;
					margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px }
.chessfooter { position: absolute; top: 0px; left: -100px; width: 0px; height: 25px; color: #afafaf;
					margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px }
.chessmsgboard { position: absolute; top: 0px; margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px; height: 25px; 
                  background-color: #24262A; color: #D6B26B; text-align: center }
.chessrow { margin: 0px; padding: 0px }
.chessimg { margin: 0px; padding: 0px; }
.cellcontainer { margin: 0px; padding: 0px; top: 0px; left: 0px; font-size: 0.8em }
.darksquare { background-color: #669104; margin: 0px; padding: 0px; }
.lightsquare { background-color: #e9efdc; margin: 0px; padding: 0px; }

.rboardno { font-family: helvetica; margin: 2px 2px 2px 2px; resize: both; display: block;  position: absolute; right: 0px } 
.bboardno { font-family: helvetica; margin: 2px 2px 2px 2px; resize: both; display: block;  position: absolute; bottom: 0px } 
.setpieces { position: absolute; cursor: pointer; left: 0px }
.pieceid { position: absolute; border: 1px solid #dedede; text-align: center; white-space: normal; font-family: helvetica; 
              padding: 5px 0px 0px 0px; background-color: #D9E8E8; width: 40px; height: 205px; }
.piecebnumid { position: absolute; width: 16px; height: 16px; font-size: 10pt; left: 20px; background-color: #dadada; 
			border: 1px solid #000000; border-radius: 25px }
.piecewnumid { position: absolute; width: 16px; height: 16px; font-size: 10pt; left: 20px; background-color: #000000; 
			border: 1px solid #dadada; color: #dadada; border-radius: 25px }
.piecebchkid { position: absolute; width: 20px; height: 20px; font-size: 11pt; font-weight: bold; left: 10px; background-color: #dadada; 
			border: 1px solid #000000; border-radius: 25px; color: #ff0000 ; }
.piecewchkid { position: absolute; width: 20px; height: 20px; font-size: 11pt; font-weight: bold; left: 10px; background-color: #4a4a4a; 
			border: 1px solid #dadada; border-radius: 25px; color: #ff0000;  }
.inputclass { position: absolute; border: 0px solid #dedede; font-family: helvetica; font-weight: normal; font-size: 10pt;  border-radius: 2px;
              box-shadow: 1px 1px 1px 1px rgb(80, 80, 80, 0.5); 
              background-color: #E1EAE3; color: #6a6a6a; margin: 2px 2px 2px 2px; width: 150px; height: 20px; padding: 0px 10px 0px 10px; }
.inputclass:focus { outline: 2px solid #4FA48F; background-color: #E1EAE3 }
.defaultbtn { position: absolute; font-family: helvetica; font-weight: bold; font-size: 12pt; border-radius: 2px; cursor: pointer; background-color: #81d765; color: #252525 }
.defaultspn { position: absolute; font-family: helvetica; font-weight: bold; font-size: 12pt; border-radius: 2px; cursor: pointer; color: #252525 }
.defaulterr { position: absolute; font-family: helvetica; font-weight: bold; font-size: 12pt; border-radius: 2px; cursor: pointer;  visibility: hidden;
			padding: 2px 10px 0px 10px; background-color: #F4D1A4; #color: #252525}
.defaultspn1 { position: absolute; font-family: helvetica; font-weight: normal; font-size: 11pt; border-radius: 2px;  text-align: left; 
             box-shadow: 1px 1px 1px 1px rgb(80, 80, 80, 0.2);
               cursor: pointer; color: #6a6a6a; background-color: #E1EAE3; padding: 5px 10px 5px 10px }
.defaultspn2 { position: absolute; font-family: helvetica; font-weight: normal; font-size: 11pt; border-radius: 2px; 
               cursor: pointer; color: #6a6a6a; padding: 5px 10px 5px 10px }
.defaultli1 { position: absolute; font-family: helvetica; font-weight: normal; font-size: 11pt; border-radius: 2px;  list-style-type: none; text-align: left;
               cursor: pointer; color: #6a6a6a; padding: 5px 10px 5px 10px; background-color: #dfdfdf;  box-shadow: 1px 1px 1px 1px rgb(80, 80, 80, 0.3) }
.inputclass1 { margin: 5px 2px 5px 15px; outline: 0px; border: 1px solid #E1EAE3; padding: 2px 2px 2px 2px; 
		background-color: #E1EAE3; font-weight: bold; color: #2a2a2a; font-size: 10pt; }
.tooltip { } /* for the collapseTool Button class search */
.humanid { } /* for the Human setting class search */
.computerid { } /* for the Human setting class search */

.settingsdivid { position: fixed;  border-radius: 10px; box-shadow: 4px 4px 4px 4px rgb(50, 50, 50, 0.5);
        border: 3px solid #787060; background-color: #D9E8E8; margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15000; }
.settingscloseid { } /* for closing settings */

.tourneyth { color: #ababab }
.tourneytd { border: 1px solid #323232; padding: 3px 3px 3px 3px }
.tourneyus { color: #4FA48F }
.tourneyrs { color: #ababab }

.source { position: absolute; width: 0px; height: 0px; background-color: #000080;  opacity: 0.2; z-index: 0 }
.destination { position: absolute; width: 0px; height: 0px; background-color: #A08080;  opacity: 0.2; z-index: 0 }

.popupdiv { position: absolute; top: 0px; left: 0px; width: 0px; height: 0px; background-color: #d0d0d0; box-shadow: 3px 3px 3px 3px rgb(50, 50, 50, 0.5);
             padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px; border: 1px solid #dedede; }
.popup { position: absolute; top: 0px; left: 0px; bottom: 0px; right: 0px; font-weight: normal; 
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; }
.popspan { display: block; width: 0px; height: 20px; background-color: #efefef; cursor: pointer; white-space: nowrap; padding: 0px 0px 0px 10px}

.chessside0 { position: absolute; top: 0px; left: 0px; border: 0px solid #afafaf; background-color: #FFFFFF;
			width: 0px; height: 0px; margin: 0px 0px 0px 0px }
.chesstitle { position: absolute; top: 0px; left: 0px; width: 98.5%; height: 80px;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px; ; background-color: #EFEFEF }
.chessgame1 { position: absolute; top: 80px; left: 0px; bottom: 23px; right: 0px; font-weight: bold;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px; ; background-color: #EFEFEF }
.chesscontrol { position: absolute; top: 0px; left: 0px; width: 0px; height: 0px; background-color: #d0d0d0; 
             padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px }
.chesscontrolbtn { position: absolute; left: 0px; width: 85px; height: 18px; margin: 0px 0px 0px 7px }
.chessrate  { position: absolute; top: 0px; left: 0px; width: 100%; height: 50%; background-color: #404040; margin: 0px 0px 0px 0px }
.chesslisting { position: fixed; top: 0px; left: 0px; background-color: #24262A; margin: 0px 0px 0px 0px; z-index: 60000 }  /* see sidepanel for z-index */
.chesslistcv { position: absolute; margin: 0px 0px 0px 0px; background-color: #4A4C4F; z-index: 5; border: 2px solid #3a3a3a; color: #dacaca;
				width: 100px; height: 25px; top: -29px; left: 0px; }
.chesslistor { position: absolute; margin: 0px 0px 0px 0px; background-color: #4A4C4F; z-index: 5; border: 2px solid #3a3a3a;  color: #dacaca;
				width: 856px; height: 26px; top: 0px; left: 0px; padding: 0px 0px 0px 0px; }
.chesslistid { position: absolute; padding: 5px 5px 5px 5px; overflow-y:scroll; background-color: #2A2C2F; /* d0d0d0 */
			 border-collapse: collapse; top: 25px; left: 0px;  width: 850px; height: 255px; }
.chesstableid { display: block; table-layout: fixed; width: 840px; padding: 2px 2px 2px 2px; color: #D0E050; border-collapse: collapse; }
.popfilter { position: absolute; top: 300px; left: 580px; border: 1px solid #ABABAB; width: 190px; height: 180px; background-color: #EFEFEF; visibility: hidden }
.chesspiece  { font-weight: bold; font-size: 14pt; margin: 5px 5px 5px 5px; }

.chessgame { position: relative; top: 0px; left: 0px; bottom: 0px; right: 0px; font-weight: normal; height: 105px;
               font-family: Helvetica, Sans-Seriv; font-size: 10pt; margin: 5px 5px 5px 5px ; background-color: #2A2C2F }
.chesspiecestep { color: #4FA48F; font-weight: normal }
.chesspiecemove { color: #FFFFFF; background-color: #288BA8;  cursor: pointer }
.chesspiecenomove { color: #cfcfcf; cursor: pointer; font-weight: normal }
.chesscmt { color: #42ABF0; font-weight: normal }
.chesschk { color: #DA5E5E; font-weight: normal }

.chesstrcurrent { background-color: #afafaf; width: 850px; }
.chesstr { margin: 0px 0px 0px 0px; border: 2px solid #2A2C2F; width: 850px; }
.chesstdp { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 220px; white-space: nowrap; font-size: 11pt; color: #afafaf; }
.chesstde { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 220px; white-space: nowrap; font-size: 11pt; color: #afafaf; }
.chesstce { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 32px; white-space: nowrap; font-size: 11pt; }
.chesstdr { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 55px; white-space: nowrap; font-size: 11pt; color: #afafaf; }
.chesstdl { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 38px; white-space: nowrap; font-size: 11pt; }
.chesstdb { margin: 3px 3px 3px 3px; border: 0px solid #3a3a3a; width: 32px; }
.chessplaybtn { position: absolute; display: block; margin: 0px 0px 0px 0px }
.chessbutton { margin: 5px 5px 5px 5px }
.chessbutton1 { margin: 1px 0px 1px 0px }
.gresult { color: #880000; font-weight: bold }
.opening { font-weight: normal; color: #000000;  }
.variation { font-weight: normal; color: #000000;  }
.player { font-weight: bold; color: #1255b3;  }
.playerelo { font-weight: normal; color: #880000; font-family: helvetica; font-size: 10pt }
.playerrnd { font-weight: normal; color: #880000; font-family: helvetica; font-size: 10pt }
.playertitle  { color: #800000; font-weight: normal; font-family; helvetica; font-size: 10pt }
.playerside   { color: #2a2a2a; font-weight: normal; font-family: helvetica; font-size: 10pt } 
.playertimer   { color: #800000; font-weight: normal; font-family: helvetica; font-size: 12pt } 
.playercapture   { color: #12626A; font-weight: bold; font-family: helvetica; font-size: 10pt } 
.sidetomove  { font-size: 16pt; font-weight: bold; color: #7E3348 }
.promocontain { font-size: 50px; position: absolute; top: 10px; left: 25px; visibility: hidden }
.promoclass { cursor: pointer; z-index: 20; border: 1px solid #ababab }
.engineclass  { margin: 0px }
.toppanel { position: fixed; top: 0px; left: 0px; width: 5000px; height: 40px; visibility: visible; z-index: 55001; /* see chesslisting for z-index */
            background-color: #343434 }
.sidepanel { position: fixed; top: 0px; left: 0px; width: 65px; height: 5000px; visibility: visible; z-index: 55000; /* see chesslisting for z-index */
            background-color: #24262A }
.cubicle  { position: fixed; background-color: #343434; top: 150px; left: 0px; width: 50px; height: 600px; padding: 5px 5px 5px 5px;  }
.cubelet  { position: relative; width: 40px; height: 40px; margin: 5px 5px 5px 5px;  background-color: #393939 }
.cubelast { position: relative; width: 40px; height: 40px; margin: 5px 5px 5px 5px;  background-color: #dadada }
.disableselect { user-select: none; -webkit-user-select: none; -moz-user-select: none; }

.center { position: absolute; 25%; transform: translateY(-50%); -ms-transform: translateY(-50%); text-align; middle; width: 70%; border: 1px solid #ff0000 }
.messageid { position: absolute; border: 1px solid #81d765; text-align: center; white-space: nowrap; font-family: helvetica }

.geartoolsclass { position: fixed; padding: 5px 10px 5px 0px; background-color: #dedede; box-shadow: 3px 3px 3px 3px rgb(50, 50, 50, 0.5); visibility: hidden;
               border: 2px solid #efefef; top: 40px; left: 430px; width: 140px; height: 210px; z-index: 55010 }
.gearitems { position: absolute; display: block; left: 5px; padding: 0px 5px 0px 5px }

.uloption { list-style: none; font-size: 9pt; font-weight: normal; font-family; helvetica; color: #808080; padding: 0px 0px 0px 0px; margin: 0px 0px 0px 0px }
.lioption { font-size: 9pt; font-weight: normal; font-family; helvetica; color: #808080 }
.divoption { position: absolute; left: 5px; width: 300px; height: 120px;  margin: 0px 0px 0px 0px; background-color: #fafafa;
             padding: 0px 0px 0px 0px; z-index: 200; border: 1px solid #bababa;  text-align: left}

.layout { position: absolute; top: 100px; left: 100px; width: 1200px } /* 183028 */
.view { display: inline-block; width: 300px; height: 300px; ; margin: 15px 25px 15px 25px; border: 2px solid #2f2f2f; border-radius: 15px; }

.slidediv {  position: absolute; top: 200px; left: 200px; width: 200px; height: 15px; background-color: #E1EAE3; 
		border-radius: 10px; border: 1px solid #c1cac3 }
.slidecon { position: absolute; top: 0px; left: 0px; width: 25px; height: 15px; background-color: #419725; border-radius: 15px }
.slidetitle { position: absolute; top: 0px; left: 0px; width: 20px; height: 10px; font-size: 10pt; font-weight: normal; font-family: helvetica }
.selectlabel { position: absolute; display: inline-block; top: 0px; left: 0px; width: 20px; height: 10px; 
		font-size: 10pt; font-weight: normal; font-family: helvetica }
.selectinp  { position: absolute; outline-width: 0; color: #808080; padding: 2px 5px 2px 5px; width: 115px; border: 1px solid #c1cac3; 
                font-size: 9pt; font-family: helvetica; font-weight: normal; background-color: E1EAE3 }
.selectval  { position: absolute; outline-width: 0; color: #606060; padding: 2px 5px 2px 5px; width: 115px;  text-align: left; 
                font-size: 9pt; font-family: helvetica; font-weight: normal; background-color: E1EAE3 }

.piecemove { font-size: 10pt; font-family: helvetica; text-align: left }
.chessmoves { position: absolute; visibility: hidden; top: 0px; width: 300px; height: 925px; border: 1px solid #0D6417 }
.chessmovestable { position: absolute; width: 100%; height: 100%; background-color: #343434; color: #adadad; font-family: helvetica }
.chmovetdstep { color: #4FA48F; text-align: left; padding: 3px 3px 3px 3px; }
.chmovetdtitle { color: #D6B26B; text-align: left; padding: 3px 3px 3px 3px; }
.chmovetdscore { color: #adadad; text-align: left; padding: 3px 3px 3px 3px; }
.chessmovesid {} /* used for search */
.chessbrilliantid { text-align: right; color: #42ABF0 } /* used for search */
.chessbestid { text-align: right; color: #3AB313 } /* used for search */
.chessgreatid { text-align: right; color:#93D068 } /* used for search */
.chessgoodid { text-align: right } /* used for search */
.chessbookid { text-align: right } /* used for search */
.chessinaccurateid { text-align: right; color: #E1A132 } /* used for search */
.chessmistakeid { text-align: right; color: #E76E0D } /* used for search */
.chessblunderid { text-align: right; color: #E14F32 } /* used for search */
.chessaccuracyid { text-align: right; color: #fafafa } /* used for search */

.bestmovesid {}
.bestscoretd { } /* used for search */
.bestscoreid { color: #D6B26B }
.bestmoveid {  color: #adadad  }

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="shortcut icon" href="images/favicon.ico">
</head>
<body style="background-color: #24262A; top: 0px; left: 0px; margin: 0px 0px 0px 0px">
<div id="chessdiv" class="chessdiv disableselect"> 
<div id="chessblanket" class="chessblanket disableselect" style="visibility: hidden"> 


<div id="toppanel" class="toppanel">
  <div id="usernamedivid"  style="position: fixed; top: 10px; left: 7px; width: 160px; height: 18px;  border-radius: 15px; font-family: helvetica;
        color: #66b79c; background-color: #414141; margin: 0px 0px 0px 0px; padding: 2px 2px 2px 2px; z-index: 55002; text-align: center; font-size: 10pt">
  <span id="usernameid" style="display: inline-block; width: 140px; white-space: nowrap; overflow: hidden" >connecting ...</span>
  </div>

  <div id="majordivid"  style="position: fixed; top: 10px; left: 187px; width: 520px; height: 18px;  border-radius: 15px; font-family: helvetica;
        color: #ababab; background-color: #414141; margin: 0px 0px 0px 0px; padding: 2px 2px 2px 2px; z-index: 55002; text-align: center; font-size: 10pt">
  <span id="mplayid" style="display: inline-block; width: 90px" >Play</span>
  <span id="mwatchid" style="display: inline-block; width: 90px;" >Watch</span>
  <span id="mlearnid" style="display: inline-block; width: 90px;">Learn</span>
  <span id="mpuzzleid" style="display: inline-block; width: 90px; ">Puzzle</span>
  <span id="mconnectid" style="display: inline-block; width: 90px; ">Connect</span>
  </div>

  <div id="noticedivid"  style="position: fixed; top: 10px; left: 750px; width: 320px; height: 18px;  border-radius: 15px; font-family: helvetica;
        color: #ababab; background-color: #414141; margin: 0px 0px 0px 0px; padding: 2px 2px 2px 2px; z-index: 55002; text-align: center; font-size: 10pt">
     <span id="noticeid" style="display: inline-block; width: 320px; color: #D6B26B" ></span>
  </div>


  <div id="othertoolsid"  style="position: fixed; top: 10px; left: 200px; width: 70px; height: 18px; 
        visibility: hidden; border-radius: 15px; font-family: helvetica; font-size: 10pt;
        color: #81d765; background-color: #343434; margin: 0px 0px 0px 0px; padding: 2px 2px 2px 2px; z-index: 55002; text-align: center; cursor: pointer" >
        <span id="searchid" style="position: absolute; display: block; top: 3px; left: 20px;  visibility: hidden">&#x1F50D;</span>
        <span id="gearid" style="position: absolute; display: block; top: 2px; left: 30px; color: #8a8a8a; font-size: 14pt" class="fa">&#xf013;</span>
  </div>

  <div id="signinid"  style="position: fixed; top: 10px; left: 1050px; width: 70px; height: 18px; visibility: hidden; 
        border-radius: 15px; font-family: helvetica; font-size: 10pt;
        color: #81d765; background-color: #414141; margin: 0px 0px 0px 0px; padding: 2px 2px 2px 2px; z-index: 55002; text-align: center; cursor: pointer"
        onclick="showSignIn('signindivid')" >Sign In</div>

  <div id="registerid"  style="position: fixed; top: 10px; left: 1130px; width: 70px; height: 18px; visibility: hidden; 
        border-radius: 15px; font-family: helvetica; font-size: 10pt;
        color: #a1f785; background-color: #515151; margin: 0px 0px 0px 0px; padding: 2px 2px 2px 2px; z-index: 55002; text-align: center; cursor: pointer"
        onclick="showSignUp('signupdivid')" >Sign Up</div>

</div>

<div id="layoutid" class="layout"></div>


<!-- GEAR TOOLS -->

<div id="geartoolsid" class="geartoolsclass"  style="width: 150px; visibility: hidden; height: 195px" > 

<span id="profileupdateid" class="gearitems fa" style="top: 5px; width: 140px; font-size: 14pt; color: #054F7E">&#xf007; &nbsp;&nbsp;&nbsp;<span style="color: #000000; font-size: 12px; font-weight: normal; font-family: helvetica" >Profile</span></span>
<span class="gearitems" style="top: 30px; width: 140px;">&#x1F310; &nbsp;&nbsp;&nbsp;<span style="font-size: 12px; font-weight: normal; font-family: helvetica">Language</span></span>
<span id="tourneyupdateid" class="gearitems" style="top: 55px; width: 140px">&#x1F3C6; &nbsp;&nbsp;&nbsp;<span style="font-size: 12px; font-weight: normal; font-family: helvetica">Tournament</span></span>
<span class="gearitems fa" style="top: 80px; width: 140px; font-size: 14pt; color: #0E739B">&#xf086;&nbsp;&nbsp;&nbsp;<span style="color: #000000; font-size: 12px; font-weight: normal; font-family: helvetica">Forum</span></span>
<span class="gearitems fa" style="top: 105px; width: 140px; color: #5B3904; font-size: 14pt" id="ratesystemid" >&#xf24e;&nbsp;&nbsp;<span style="color: #000000; font-size: 12px; font-weight: normal; font-family: helvetica; white-space: nowrap">Rating System&nbsp;<span id="ratingid" style="font-weight: normal; font-size: 10pt; font-family; helvetica; color: #800000">(E)</span></span></span>
<span class="gearitems fa" style="top: 135px; width: 140px; color: #800000; font-size: 14pt" id="saveconfigid">&#x2699;&nbsp;&nbsp;&nbsp;<span style="color: #000000; font-size: 12px; font-weight: normal; font-family: helvetica">Save Config</span></span>
<span id="skipid" class="gearitems" style="top: 155px; width: 140px"><hr></span> 

<span class="gearitems fa" style="top: 175px; width: 140px; color: #800000; font-size: 14pt" id="signout">&#xf08b;&nbsp;&nbsp;&nbsp;<span style="color: #000000; font-size: 12px; font-weight: normal; font-family: helvetica">Sign out</span></span>

<!-- START OF PROFILEID --->

<div id="profileid" class="geartoolsclass" style="visibility: hidden; width: 340px; height: 405px; display: inline-block; height: fit-content">

<span id="profilecloseid" style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer; z-index: 15003;
             border: 0px solid #ababab; position: absolute; top: 5px; left: 337px" >&#x2715</span>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 5px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; height: 90px">
<span style="display: block; width: 70px; height: 70px; background-color: #ffffff; border: 1px solid #afafaf"><img id="photoimageid" src="/images/rmoo_icon.svg" style="width: 70px; height: 70px"></span>
</span>
<span style="left: 90px; font-size: 12px; font-weight: normal; font-family: helvetica">Upload your photo here</span><br>
<span style="left: 90px; font-size: 12px; font-weight: normal; font-family: helvetica; color: #906060">(best to use 360x360 pixels)</span><br><br>
<span style="left: 90px; font-size: 12px; font-weight: normal; font-family: helvetica; width: 50px;">
<form action="upload" enctype="multipart/form-data" method="post" style="display: inline-block; width: 200px">
  <input id="pr_file" type="file" name="file" style="padding: 0px 0px 5px 0px"/>
<span id="pr_file_err" style="display: none; font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000"> This is an error.</span>
</form><br>
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Username</span>
<span style="font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 215px;
		font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_username" ></span>
</div>
<div id="pr_username_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica">First name</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 215px;
		font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_firstname" ></span>
</div>
<div id="pr_firstname_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px;  margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Last name</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 215px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_lastname" ></span>
</div>
<div id="pr_lastname_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px;  margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Email address</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 215px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_email" ></span>
</div>
<div id="pr_email_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px;">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000; ">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Phone number</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 215px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_phone" ></span>
</div>
<div id="pr_phone_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px;">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Country</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica">
    <select id="flagsoptionid" type="text" style="border: 0px; outline-width: 0; color: #808080; padding: 2px 5px 2px 5px; width: 215px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" value=0 >
    </select>
</span>
<span class="gearitems"  id="flagsoptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica; 
                 padding: 2px 5px 2px 5px; color: #14815C;"></span>
 <div id="flagsdivid" class="divoption" style="visibility: hidden; left: 115px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px"><ul id="flagsid" class="uloption"></ul></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Fide title</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <select id="titleoptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 215px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false">
     </select>
</span>
<span class="gearitems"  id="titleoptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica; 
                 padding: 2px 5px 2px 5px; color: #14815C;"></span>
 <div id="titledivid" class="divoption" style="visibility: hidden; left: 115px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px">
   <ul id="titleid" class="uloption"></ul></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Fide rating</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 50px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_rating" maxlength="4" placeholder="1500"></span>
</div>
<div id="pr_rating_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px;">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px;  margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Description</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica">
    <textarea type="text" style="border: 0px; outline-width: 0; color: #808080; padding: 2px 5px 2px 5px; width: 215px; height: 90px; resize: none;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_desc"></textarea></span>
</div>
<div id="pr_desc_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px;">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 5px 0px 0px 0px">
<span style="float: left; display: block; width: 235px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<button id="profilesaveid">Save Profile</button>
</div>

</div> <!---- END of PROFILEID ----->


<!-- START OF TOURNEY ID --->

<div id="tourneyid" class="geartoolsclass" style="visibility: hidden; width: 340px; height: 405px; display: inline-block; height: fit-content">

<span id="tourneycloseid" style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer; z-index: 15003;
             border: 0px solid #ababab; position: absolute; top: 5px; left: 337px" >&#x2715</span>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px; color: #800000">
Create a new tournament.<br>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Tournament name</span>
<span style="font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 215px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_tourney" ></span>
</div>
<div id="pr_tourney_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Tournament type</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <select id="tourneytypeoptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 215px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false">
     </select>
</span>
<span class="gearitems"  id="tourneytypeoptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica;
                 padding: 2px 5px 2px 5px; color: #14815C;">Round Robin</span>
 <div id="tourneytypedivid" class="divoption" style="visibility: hidden; left: 115px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px">
   <ul id="tourneytypeid" class="uloption"></ul></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Duration</span>
<span style="font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 35px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_tourney_dur" maxlength=3 placeholder="30" value=30> min 
    <span style="color: #800000">(per tournament)</span></span>
</div>
<div id="pr_tourney_dur_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;" id="error">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px; color: #800000; white-space: nowrap">
<span style="float: left; display: inline-block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; white-space: normal">Note</span>
<span style="display: inline-block; width: 215px; font-size: 10px; font-weight: normal; font-family: helvetica; white-space: normal">
Tournament ends after reaching the given duration. All running games are terminated and final outcome of the tournament is provided. Duration is best applied to 
bullet, blitz, and ladder-style tournaments.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Number of players</span>
<span style="font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 35px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_tourney_pl" maxlength=3 placeholder="4" value=4></span>
</div>
<div id="pr_tourney_pl_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Variant</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <select id="tourneyvariantoptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 215px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false"></select>
</span>
<span class="gearitems"  id="tourneyvariantoptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica;
                 padding: 2px 5px 2px 5px; color: #14815C;">Standard</span>
 <div id="tourneyvariantdivid" class="divoption" style="visibility: hidden; left: 115px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px">
   <ul id="tourneyvariantid" class="uloption"></ul></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Timer</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <select id="tourneytimeroptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 75px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false">
     </select> <span style="font-size: 10pt">min</span>
</span>
<span class="gearitems"  id="tourneytimeroptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica;
                 padding: 2px 5px 2px 5px; color: #14815C;">3</span>
 <div id="tourneytimerdivid" class="divoption" style="visibility: hidden; left: 115px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px">
   <ul id="tourneytimerid" class="uloption"></ul></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Increment</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <select id="tourneyincoptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 75px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false">
     </select> <span style="font-size: 10pt">sec</span>
</span>
<span class="gearitems"  id="tourneyincoptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica;
                 padding: 2px 5px 2px 5px; color: #14815C;">0</span>
 <div id="tourneyincdivid" class="divoption" style="visibility: hidden; left: 115px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px">
   <ul id="tourneyincid" class="uloption"></ul></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px; color: #800000; white-space: nowrap">
<span style="float: left; display: inline-block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; white-space: normal">Note</span>
<span style="display: inline-block; width: 215px; font-size: 10px; font-weight: normal; font-family: helvetica; white-space: normal">
For simultaneous-style tournaments, you are the exhibitor and the players are those you are willing to play simultaneously. The time restriction only applies to each of the players and not to you. However, you are limited to 30 seconds per move when number of players is 6 or more.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Rated</span>
<span style="font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="checkbox" style="border: 0px; outline-width: 0; color: #14815C; margin: 0px 0px 0px 0px; padding: 2px 0px 2px 0px; width: 15px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_tourney_rated" checked></span>
</div>
<div id="pr_tourney_rated_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Titled</span>
<span style="font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="checkbox" style="border: 0px; outline-width: 0; color: #14815C; margin: 0px 0px 0px 0px; padding: 2px 0px 2px 0px; width: 15px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_tourney_titled"></span>
</div>
<div id="pr_tourney_titled_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px; color: #800000; white-space: nowrap">
<span style="float: left; display: inline-block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; white-space: normal">Note</span>
<span style="display: inline-block; width: 215px; font-size: 10px; font-weight: normal; font-family: helvetica; white-space: normal">
Allow only titled players in the tournament, e.g. (WGM, GM, IM, FM, CM, etc.).
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Start date</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <select id="tourneydateoptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 170px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false">
     </select>
</span>
<span class="gearitems"  id="tourneydateoptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica;
                 padding: 2px 5px 2px 5px; color: #14815C;"></span>
 <div class="divoption" style="visibility: hidden; left: 115px; width: 150px; height: 240px "><div style="position: absolute; top: 5px; left: 5px" id="caldivid"></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Start time</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <select id="tourneytimehroptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 40px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false">
     </select> <span style="font-size: 12px; font-weight: normal; font-family: helvetica;">hr</span>
    <select id="tourneytimeminoptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 40px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false"> 
     </select> <span style="font-size: 12px; font-weight: normal; font-family: helvetica;">min</span>
</span>
<span class="gearitems"  id="tourneytimehroptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica;
                 padding: 2px 5px 2px 5px; color: #14815C;"></span>
<span class="gearitems"  id="tourneytimeminoptionspanid"  style="top: 0px; left: 175px; font-size: 12px; font-weight: normal; font-family: helvetica;
                 padding: 2px 5px 2px 5px; color: #14815C;"></span>
 <div id="tourneytimehrdivid" class="divoption" style="visibility: hidden; left: 115px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px">
   <ul id="tourneytimehrid" class="uloption"></ul></div></div>
 <div id="tourneytimemindivid" class="divoption" style="visibility: hidden; left: 175px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px">
   <ul id="tourneytimeminid" class="uloption"></ul></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Forfeit Policy</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <select id="tourneyforfeitoptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 75px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false">
     </select> <span style="font-size: 10pt">min</span>
</span>
<span class="gearitems"  id="tourneyforfeitoptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica;
                 padding: 2px 5px 2px 5px; color: #14815C;">1</span>
 <div id="tourneyforfeitdivid" class="divoption" style="visibility: hidden; left: 115px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px">
   <ul id="tourneyforfeitid" class="uloption"></ul></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px; color: #800000; white-space: nowrap">
<span style="float: left; display: inline-block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; white-space: normal">Note</span>
<span style="display: inline-block; width: 215px; font-size: 10px; font-weight: normal; font-family: helvetica; white-space: normal">
A player is forfeited if late 1 minute (default) in a game or if he/she becomes unavailable for 1 minute during a game. You can adjust the forfeit policy according to your
own tournament requirements.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica;">Recurrence</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica;">
    <select id="tourneyrecoptionid" type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 170px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false">
     </select>
</span>
<span class="gearitems"  id="tourneyrecoptionspanid"  style="top: 0px; left: 115px; font-size: 12px; font-weight: normal; font-family: helvetica;
                 padding: 2px 5px 2px 5px; color: #14815C;">None</span>
 <div id="tourneyrecdivid" class="divoption" style="visibility: hidden; left: 115px"><div style="position: absolute; overflow-y: scroll; top: 5px; left: 5px">
   <ul id="tourneyrecid" class="uloption"></ul></div></div>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px;  margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Description</span>
<span class="float: right; display: block; width: 100px; font-size: 12px; font-weight: normal; font-family: helvetica">
    <textarea type="text" style="border: 0px; outline-width: 0; color: #808080; padding: 2px 5px 2px 5px; width: 215px; height: 90px; resize: none;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_tourney_desc"></textarea></span>
</div>
<div id="pr_tourney_desc_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px;">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 5px 0px 0px 0px">
<span style="float: left; display: block; width: 205px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<button id="tourneysaveid">Save Tournament</button>
</div>

</div> <!----- END OF TOURNEYID ---->

</div> <!----- END OF GEAR TOOLS  ---->


<div id="layoutconfigid" class="geartoolsclass" 
       style="visibility: hidden; left: 1300px; width: 180px; height: 415px; display: inline-block; height: fit-content">
<span id="layoutcloseid" style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer; z-index: 15003;
             border: 0px solid #ababab; position: absolute; top: 5px; left: 177px" >&#x2715</span>
<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Free Layout</span>
<span style="font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="checkbox" style="border: 0px; outline-width: 0; color: #14815C; margin: 0px 0px 0px 0px; 
		padding: 2px 0px 2px 0px; width: 15px; font-size: 9pt; 
       font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_free_layout" checked></span>
</div>
<div id="pr_tourney_titled_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Columns</span>
<span style="font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 35px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_columns" maxlength=1 value=2></span>
</div>
<div id="pr_tourney_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>

<div style="position: relative; display: block; left: 5px; padding: 0px 5px 0px 5px; margin: 7px 0px 0px 0px">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; ">Rows</span>
<span style="font-size: 12px; font-weight: normal; font-family: helvetica;">
    <input type="text" style="border: 0px; outline-width: 0; color: #14815C; padding: 2px 5px 2px 5px; width: 35px;
                font-size: 9pt; font-family: helvetica; font-weight: normal" spellcheck="false" id="pr_rows" maxlength=1 value=5></span>
</div>
<div id="pr_tourney_err" style="position: relative; display: none; left: 5px; padding: 0px 5px 0px 5px; ">
<span style="float: left; display: block; width: 110px; font-size: 12px; font-weight: normal; font-family: helvetica; border: 1px solid #dedede"></span>
<span style="font-size: 10px; font-weight: normal; font-family: helvetica; color: #800000;">
This is an error.
</span>
</div>


</div> <!----- END OF LAYOUTCONFIGID ---->

<div id="schedtourneyid" style="position: fixed; background-color: #242424; visibility: hidden; z-index: 55004;
          border: 1px solid #226B53; top: 50px; left: 100px; height: 1000px; width: 987px">

<!--- FIRST PANEL A ---->

<div style="position: absolute; top: 5px; left: 5px; height: 380px; width: 315px; 
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 315px; 
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Ladder-Type and Titled Tournaments</span>

<div id="schedpanel1a" style="position: absolute; top: 30px; height: 345px; width: 300px; overflow-y: scroll"></div>

</div> 

<!-- SECOND PANEL A -->

<div style="position: absolute; top: 5px; left: 335px; height: 380px; width: 310px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 310px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Bullet, Blitz, Rapid Tournaments</span>

<div id="schedpanel2a" style="position: absolute; top: 30px; height: 345px; width: 300px; overflow-y: scroll"></div>

</div>

<!-- THIRD PANEL A -->

<div style="position: absolute; top: 5px; left: 660px; height: 380px; width: 310px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 310px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Simultaneous Exhibitions</span>

<div id="schedpanel3a" style="position: absolute; top: 30px; height: 345px; width: 300px; overflow-y: scroll"></div>

</div>

<!--- FIRST PANEL B ---->

<div style="position: absolute; top: 400px; left: 5px; height: 582px; width: 230px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 230px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">LeaderBoard - Bullet</span>

<div id="schedpanel1b" style="position: absolute; top: 30px; height: 550px; width: 300px; overflow-y: scroll"></div>

</div>


<!-- SECOND PANEL B -->

<div style="position: absolute; top: 400px; left: 250px; height: 582px; width: 230px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 230px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">LeaderBoard - Blitz</span>

<div id="schedpanel2b" style="position: absolute; top: 30px; height: 550px; width: 300px; overflow-y: scroll"></div>

</div> 

<!-- THIRD PANEL B -->

<div style="position: absolute; top: 400px; left: 495px; height: 582px; width: 230px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 230px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">LeaderBoard - Rapid</span>

<div id="schedpanel3b" style="position: absolute; top: 30px; height: 550px; width: 300px; overflow-y: scroll"></div>

</div> 

<!-- FOURTH PANEL B -->

<div style="position: absolute; top: 400px; left: 740px; height: 582px; width: 230px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 230px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">LeaderBoard - Classical</span>

<div id="schedpanel4b" style="position: absolute; top: 30px; height: 550px; width: 300px; overflow-y: scroll"></div>

</div>

</div> <!----- END OF SCHEDLAYOUTID ---->

<div id="watchgamesid" style="position: fixed; background-color: #242424; visibility: hidden; z-index: 55004;
          border: 1px solid #226B53; top: 50px; left: 100px; height: 1037px; width: 953px">


<!--- FIRST PANEL A ---->

<div style="position: absolute; top: 5px; left: 5px; height: 1015px; width: 300px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 300px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Bullet Games</span>

<div id="watchgamepanel1a" style="position: absolute; top: 30px; height: 985px; width: 300px; overflow-y: scroll"></div>

</div>

<!-- SECOND PANEL A -->

<div style="position: absolute; top: 5px; left: 320px; height: 380px; width: 300px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 300px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Top Rank Game</span>

<div id="watchgamepanel2a" style="position: absolute; top: 30px; height: 345px; width: 300px; overflow-y: scroll"></div>

</div>

<!-- THIRD PANEL A -->

<div style="position: absolute; top: 5px; left: 635px; height: 380px; width: 300px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 300px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">2nd Top Rank Game</span>

<div id="watchgamepanel3a" style="position: absolute; top: 30px; height: 345px; width: 300px; overflow-y: scroll"></div>

</div>

<!-- LARGER PANEL B -->

<div style="position: absolute; top: 400px; left: 320px; height: 620px; width: 615px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 613px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Most Watched Game</span>

<div id="watchgamepanel4a" style="position: absolute; top: 30px; height: 590px; width: 613px; overflow-y: scroll"></div>

</div>

</div> <!----- END OF WATCHGAMES ---->

<div id="forumsid" style="position: fixed; background-color: #242424; visibility: hidden; z-index: 55004;
          border: 1px solid #226B53; top: 50px; left: 100px; height: 1000px; width: 953px">


<!--- FIRST PANEL A ---->

<div style="position: absolute; top: 5px; left: 5px; height: 100px; width: 300px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 300px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Search</span>

<div id="forumspanel1a" style="position: absolute; top: 30px; height: 72px; width: 300px; overflow-y: scroll; border: 1px solid #ff0000"></div>

</div>

<!-- SECOND PANEL A -->

<div style="position: absolute; top: 120px; left: 5px; height: 280px; width: 300px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 300px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Category</span>

<div id="forumspanel4a" style="position: absolute; top: 30px; height: 252px; width: 300px; overflow-y: scroll; border: 1px solid #ff0000"></div>

</div>

<!-- THIRD PANEL A -->

<div style="position: absolute; top: 420px; left: 5px; height: 562px; width: 300px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 300px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Topics</span>

<div id="forumspanel2a" style="position: absolute; top: 30px; height: 534px; width: 300px; overflow-y: scroll; border: 1px solid #ff0000"></div>

</div>

<!-- FIRST PANEL B -->

<div style="position: absolute; top: 5px; left: 320px; height: 977px; width: 615px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 613px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Forum</span>

<div id="forumspanel4a" style="position: absolute; top: 30px; height: 948px; width: 613px; overflow-y: scroll; border: 1px solid #ff0000"></div>

</div>

</div> <!----- END OF FORUMS ---->

<div id="evaluateid" style="position: fixed; background-color: #242424; visibility: hidden; z-index: 55004;
          border: 1px solid #226B53; top: 50px; left: 100px; height: 1100px; width: 1413px">


<!--- FIRST PANEL A ---->

<div style="position: absolute; top: 5px; left: 5px; height: 100px; width: 300px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 300px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Game</span>

<div id="evalpanel1a" style="position: absolute; top: 30px; height: 72px; width: 300px; overflow-y: scroll; border: 1px solid #ff0000"></div>

</div>

<!-- SECOND PANEL A -->

<div style="position: absolute; top: 120px; left: 5px; height: 280px; width: 300px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 300px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Evaluation</span>

<div id="evalpanel2a" style="position: absolute; top: 30px; height: 252px; width: 300px; overflow-y: scroll; border: 1px solid #ff0000"></div>

</div>

<!-- THIRD PANEL A -->

<div style="position: absolute; top: 420px; left: 5px; height: 562px; width: 300px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 300px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Statistics</span>

<div id="evalpanel3a" style="position: absolute; top: 30px; height: 534px; width: 300px; overflow-y: scroll; border: 1px solid #ff0000"></div>

</div>

<!-- FIRST PANEL B -->

<div style="position: absolute; top: 5px; left: 320px; height: 1077px; width: 1075px;
            font-size: 10pt; font-weight: normal; font-family: helvetica; border: 1px solid #404040; padding: 5px 5px 5px 5px">
<span style="position: absolute; display: inline-block; top: 5px; color: #E1AC76; text-align: center; width: 1073px;
            height: 20px; background-color: #404040; color: #ababab; padding: 2px 0px 0px 2px;
            text-align: nowrap">Analysis</span>

<div id="evalpanel1b" style="position: absolute; top: 30px; height: 1048px; width: 1073px; overflow-y: scroll; border: 1px solid #ff0000"></div>

</div>

</div> <!----- END OF ANALYSIS ---->

<div id="sidepanel" class="sidepanel">
<div id="cubicleid" class="cubicle">
 <div class="cubelet" id="cube1"></div> <div class="cubelet" id="cube2"></div> <div class="cubelet" id="cube3"></div> <div class="cubelet" id="cube4"></div>
 <div class="cubelet" id="cube5"></div> <div class="cubelet" id="cube6"></div> <div class="cubelet" id="cube7"></div> <div class="cubelet" id="cube8"></div>
 <div class="cubelet" id="cube9"></div> <div class="cubelet" id="cube10"></div> <div class="cubelet" id="cube11"></div> <div class="cubelet" id="cube12"></div>
 <div class="cubelast"><span style="position: absolute; left: 2px; margin: 5px 5px 5px 5px; font-size: 20pt; 
                           cursor: pointer; font-family: helvetica; font-weight: normal; " onclick="evaluatePosition(event)">&#x1F195;</span></div>

</div>
</div>


<div id="chessboard" class="chessboard"></div> 

<div id="chessheader" class="chessheader">
 <div style="position:absolute; top: 0px; left: 0px;" ><button onclick="collapseTools(this)" id="collapseid" class="tooltip"
      style="font-size: 12pt; border: 0px; margin: 2px 2px 2px 2px" alt="Tooltips" title="Tooltips">&#8801</button></div>
 <div style="position:absolute; top: 2px; left: 35px;">
    <span id="blackrnd" class="playerrnd"></span>
    <span id="btitle" class="playertitle"></span>
    <span id="bplayer" class="playerside">Home Player</span>
    <span id="blackelo" class="playerelo">(1500)</span>
</div>
 <div style="position:absolute; top: 0px; right: 75px;"><span id="bcapture" class="playercapture">&#9813; &#9814; &#9815; &#9816; &#9817;</span></div>
 <div style="position:absolute; top: 2px; right: 10px;"><span id="btimer" class="playertimer">00:00</span></div>
</div>

<div id="chessfooter" class="chessfooter">
 <div style="position:absolute; top: -2px; left: 5px;" ><span class="sidetomove" id="sidetomoveid" >&#9679;</span> </div>
 <div style="position:absolute; top: 2px; left: 35px;">
    <span id="whiternd" class="playerrnd"></span>
    <span id="wtitle" class="playertitle"></span>
    <span id="wplayer" class="playerside">Guest Player</span>
    <span id="whiteelo" class="playerelo">(1500)</span>
  </div>
 <div style="position:absolute; top: 0px; right: 75px;"><span id="wcapture" class="playercapture">&#9819; &#9820; &#9821; &#9822; &#9823;</span></div>
 <div style="position:absolute; top: 2px; right: 10px;"><span id="wtimer" class="playertimer">00:00</span></div>
</div>

<div id="chessside0" class="chessside0"> 
      <div class="chessrate" id="chessrate"></div> 
</div>

<div id="chessxcontrol1" class="chessxcontrol" style="visibility: hidden">
      <div class="chessxgame1">
          <div id="chessxgame1" class="chessxgame" style="margin: 5px 5px 5px 5px; overflow-y:scroll; top: 0px"></div>
      </div>
      <div id="playitid" class="chessxcontrolbtn">
          <div style="position: absolute;   width: 100%; height: 100%; background-color: #dedede; border: 3px solid #dedede">
             <span class="chessplaybtn" onclick="jumpToStart(this)" style="top: 0px; left: 5px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; font-size: 10pt">&#x258E;</span>
             <span style="position:absolute; display: block; top: 0px; left: 2px; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="backwardPlay(this)" style="top: 0px; left: 25px">
             <span style="position:absolute; display: block; top: 0px; left: 0px; font-size: 10pt">&#9664;</span>
             </span>
             <span class="chessplaybtn" onclick="forwardPlay(this)" style="top: 0px; left: 45px">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px;  font-size: 10.5pt">&#9654;</span>
             </span>
             <span class="chessplaybtn" onclick="jumpToEnd(this)" style="top: 0px; left: 65px; color: #FAFAFA">
             <span style="position:absolute; display: block; top: 1.5px; left: 0px; font-size: 10.5pt">&#9654;</span>
             <span style="position:absolute; display: block; top: 0px; left: 12px; font-size: 10pt">&#x258E;</span>
             </span>
           </div>
     </div>
</div>

<div id="chessmoves" class="chessmoves">
 <div style="position: relative; width: 300px; height: 150px; display: block">
 <table class="chessmovestable">
   <tbody id="chessanalysisid">
     <tr><th colspan=3>Analysis</th></tr>
     <tr><th style="text-align: left" >Level</th><th style="text-align: right">White</th><th style="text-align: right">Black</th></tr>
     <tr style="background-color: #24262A; color: #42ABF0"><td class="chmovetdtitle">Brilliant</td>
         <td class="chessbrilliantid">0</td>
         <td class="chessbrilliantid">0</td>
      </tr>
     <tr style="color: #93D068"><td class="chmovetdtitle">Best</td>
         <td class="chessbestid">0</td>
         <td class="chessbestid">0</td>
     </tr>
     <tr><td class="chmovetdtitle">Great</td>
         <td class="chessgreatid">0</td>
         <td class="chessgreatid">0</td>
     </tr>
     <tr style="background-color: #24262A"><td class="chmovetdtitle">Good</td>
         <td class="chessgoodid">0</td>
         <td class="chessgoodid">0</td>
     </tr>
     <tr ><td class="chmovetdtitle" style="color: #42ABF0">Book</td>
         <td class="chessbookid">0</td>
         <td class="chessbookid">0</td>
     </tr>
     <tr style="background-color: #24262A"><td class="chmovetdtitle">Inaccurate</td>
         <td class="chessinaccurateid">0</td>
         <td class="chessinaccurateid">0</td>
     </tr>
     <tr style="color: #E1A132"><td class="chmovetdtitle">Mistake</td>
         <td class="chessmistakeid">0</td>
         <td class="chessmistakeid">0</td>
     </tr>
     <tr style="background-color: #24262A; color: #E14F32"><td class="chmovetdtitle">Blunder</td>
         <td class="chessblunderid">0</td>
         <td class="chessblunderid">0</td>
     </tr>
     <tr style="color: #71BCED"><td class="chmovetdtitle" style="color: #71BCED">Accuracy</td>
         <td class="chessaccuracyid">0</td>
         <td class="chessaccuracyid">0</td>
     </tr>
   </tbody>
  </table>
  </div>
 <div style="position: relative; width: 300px; height: 150px; display: block" id="bestmovesid">
  <table>
    <tbody>
    <tr>
     <td class="bestscoretd"><span class="bestscoreid" style="text-align: right; width: 100%"></span></td><td><span class="bestmoveid"></span></td></tr>
     <td class="bestscoretd"><span class="bestscoreid" style="text-align: right; width: 100%"></span></td><td><span class="bestmoveid"></span></td></tr>
     <td class="bestscoretd"><span class="bestscoreid" style="text-align: right; width: 100%"></span></td><td><span class="bestmoveid"></span></td></tr>
    </tr>
    </tbody>
  </table>
 </div>
 <div id="chessgame" class="chessgame" style="margin: 5px 5px 5px 5px; overflow-y:scroll; top: 0px"></div>
 <div style="position: relative;  width: 300px; height: 470px; display: block; overflow-y: scroll">
 <span style="color: #adadad; text-align: center; width: 100%; display: inline-block">stockfish 15 + nnue (depth 16)</span>
 <table class="chessmovestable">
   <tbody id="chessmovesid" class="chessmovesid">
     <tr style="height: 20px"><th colspan=7>Chess Moves</th></tr>
     <tr style="height: 20px"><th class="chmovetdstep"></th>
         <th></th><th></th>
         <th class="chmovetdtitle">White</th>
         <th class="chmovetdtitle">Black</th>
         <th></th><th></th>
     </tr>
     <tr><th colspan=7 style="height: 100%"></th></tr>
   </tbody>
 </table>
 </div>
 <div id="chesscontrol" class="chesscontrol" style="position: relative;  width: 300px; height: 40px; display: block; overflow-y: scroll">
             <span class="chessplaybtn" onclick="jumpToStart(this)" style="top: 0px; left: 25px; color: #808080">
             <span style="position:absolute; display: block; top: 0px; left: 0px; font-size: 18pt">&#x258E;</span>
             <span style="position:absolute; display: block; top: 0px; left: 2px; font-size: 18pt">&#9664;</span>
             </span>

             <span class="chessplaybtn" onclick="backwardPlay(this)" style="top: 0px; left: 100px; color: #808080">
             <span style="position:absolute; display: block; top: 0px; left: 0px; font-size: 18pt">&#9664;</span>
             </span>

             <span class="chessplaybtn" onclick="forwardPlay(this)" style="top: 0px; left: 170px; color: #808080">
             <span style="position:absolute; display: block; top: 3.5px; left: 0px; font-size: 18.5pt">&#9654;</span>
             </span>

             <span class="chessplaybtn" onclick="jumpToEnd(this)" style="top: 0px; left: 240px; color: #808080">
             <span style="position:absolute; display: block; top: 3.5px; left: 0px; font-size: 18.5pt">&#9654;</span>
             <span style="position:absolute; display: block; top: 0px; left: 20px; font-size: 18pt">&#x258E;</span>
             </span>
</div>

</div>

<div id="chesslisting" class="chesslisting" style="visibility: hidden; width: 860px; height: 280px; ">
 <div id="chesslistcv"  class="chesslistcv" ></div>
 <div id="chesslistor"  class="chesslistor" >
   <table><tr id="chesslisttrid" class="chesstr" style="border-collapse: collapse;">
   <td class="chesstdb" style=" width: 32px; border: 1px solid #3a3a3a"></td>
   <td class="chesstdb" style=" border: 1px solid #3a3a3a; font-size: 12pt">No</td>
   <td class="chesstdp" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 12pt; cursor: pointer" onclick="orderWhite(this)">White</td>
   <td class="chesstdl" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 10pt; cursor: pointer" onclick="orderWhiteElo(this)">ELO</td>
   <td class="chesstdp" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 12pt; cursor: pointer" onclick="orderBlack(this)">Black</td>
   <td class="chesstdl" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 10pt; cursor: pointer" onclick="orderBlackElo(this)">ELO</td>
   <td class="chesstdr" style=" border: 1px solid #3a3a3a; white-space: nowrap; font-size: 12pt; cursor: pointer" onclick="orderResult(this)">Result</td>
   <td class="chesstce" style="font-size: 12pt;  border: 1px solid #3a3a3a" >ECO</td>
   <td class="chesstde" style="font-size: 12pt;  border: 1px solid #3a3a3a; white-space; nowrap">Event</td>
   <td class="chesstdb" style="white-space: nowrap;  border: 1px solid #3a3a3a; font-size: 12pt; cursor: pointer" onclick="orderCount(this)">Cnt</td>
  </tr></table>
</div>
 <div id="chesslistid"  class="chesslistid" ><table class="chesstableid" id="chesstableid"><tbody id="chesstbodyid"></tbody></table></div>
</div>

<div id="settingsdivid" class="settingsdivid" style="top: 100px; left: 100px; width: 325px; height: 460px; visibility: hidden;">
 <div id="settingid" class="messageid" style="width: 325px; height: 460px; z-index: 15003">
     <button class="defaultbtn" style="top: 25px; left: 15px; width: 150px; height: 45px; border: 0px; 
		cursor: pointer; border-radius: 25px 0px 0px 25px " id="humanbtnid" >Human</button>
     <button class="defaultbtn" style="top: 25px; left: 165px; width: 150px; height: 45px; border: 0px; background-color: #AED8CF; cursor: pointer; border-radius: 0px 25px 25px 0px" id="computerbtnid">Computer</button>

  <div id="humanid" style="visibility: hidden" class="humanid">
     <span class="defaultspn1" style="top: 90px; left: 60px; width: 75px; text-align: center;" onclick="switchCheckBox('Rated', this)" id="isratedid">Rated&nbsp; &nbsp; &#x2714;</span>
     <span class="defaultspn1" style="top: 90px; left: 180px; width: 75px; text-align: center;" onclick="switchCheckBox('Titled', this)" id="istitledid">Titled&nbsp; &nbsp; &#x2714;</span>

     <span style="position: absolute; top: 135px; left: 30px; width: 265px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 265px"><div class="slidecon" style="left: 70px; width: 40px" id="chessrangeid"></div></div>
        <div class="slidetitle" style="top: 25px; left: 12px;">Rating range: (<span id="rangesystemid" style="color: #800000; font-weight: bold" >E</span>)&nbsp;
         min: <span id="minratingid" style="color: #800000; font-weight: bold" >1600</span>
         max: <span id="maxratingid" style="color: #800000; font-weight: bold" >1800</span>
        </div> 
     </span>

     <span style="position: absolute; top: 190px; left: 30px; width: 145px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 145px"><div class="slidecon" style="left: 12px" id="chesstimerid"></div></div>
        <div class="slidetitle" style="top: 25px; left: 30px;">Timer: <span id="gameminid" style="color: #800000; font-weight: bold">3</span> min</div>
     </span>

     <span style="position: absolute; top: 190px; left: 185px; width: 110px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 110px"><div class="slidecon" style="left: 0px" id="chessincid"></div></div>
        <div class="slidetitle" style="top: 25px; left: 3px;">Increment: <span id="gameincid" style="color: #800000; font-weight: bold">0</span> sec</div>
     </span>

     <span style="position: absolute; top: 245px; left: 40px; width: 120px">
      <span class="selectlabel" style="top: 2px; left: 0px" >Variant: </span>
      <select id="chessselectvariantid" type="text" class="selectinp" style="top: 0px; left: 60px; width: 160px" spellcheck="false" value=0 ></select>
      <span id="chessspanvariantid" type="text" class="selectval" style="top: 2px; left: 65px; width: 65px">Standard</span>
     </span>
     <div id="chessvariantdivid" class="divoption" style="visibility: hidden; top: 265px; left: 100px"><div 
            style="position: absolute; overflow-y: scroll; top: 5px; left: 5px"><ul id="chessvariantid" class="uloption"></ul></div></div>

     <span style="position: absolute; top: 280px; left: 40px; width: 120px">
      <span class="selectlabel" style="top: 2px; left: 0px" >Piece: </span>
      <select id="chessselectpieceid" type="text" class="selectinp" style="top: 0px; left: 60px; width: 160px" spellcheck="false" value=2></select>
      <span id="chessspanpieceid" type="text" class="selectval" style="top: 2px; left: 65px; width: 65px">Random</span>
     </span>
     <div id="chesspiecedivid" class="divoption" style="visibility: hidden; top: 300px; left: 100px"><div 
             style="position: absolute; overflow-y: scroll; top: 5px; left: 5px"><ul id="chesspieceid" class="uloption"></ul></div></div>

     <span style="position: absolute; top: 315px; left: 40px; width: 120px">
      <span class="selectlabel" style="top: 2px; left: 0px" >Player: </span>
      <select id="chessselectplayerid" type="text" class="selectinp" style="top: 0px; left: 60px; width: 160px" spellcheck="false" value=0 ></select>
      <span id="chessspanplayerid" type="text" class="selectval" style="top: 2px; left: 65px; width: 65px">Random Player(s)</span>
     </span>
     <div id="chessplayerdivid" class="divoption" style="visibility: hidden; top: 335px; left: 100px"><div 
             style="position: absolute; overflow-y: scroll; top: 5px; left: 5px"><ul id="chessplayerid" class="uloption"></ul></div></div>

     <span style="position: absolute; top: 350px; left: 100px; width: 145px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 145px"><div class="slidecon" style="left: 12px" id="chesssimulid"></div></div>
        <span id="simulabelid" style="position: absolute; display: inline-block; top: 0px; left: 155px; color: #800000; font-weight: normal"></span> 
        <div class="slidetitle" style="top: 25px; left: 5px;">Challenge: <span id="simulid" style="color: #800000; font-weight: bold">1</span> player(s)
        </div>
     </span>

     <button class="defaultbtn" style="top: 405px; left: 15px; width: 295px; height: 45px; border: 0px; cursor: pointer" id="seekbtnid" >Seek For A Match</button>
  </div>

  <div id="computerid" style="visibility: hidden" class="computerid">

     <span class="defaultspn1" style="top: 90px; left: 15px; width: 120px" onclick="switchCheckBox('NNUE', this)" id="isnnueid">NNUE &nbsp; &nbsp; &#x2714;</span>
     <span class="defaultspn1" style="top: 90px; left: 170px; width: 120px" onclick="switchCheckBox('Limit Strength', this)" id="islimstrengthid">Limit Strength&nbsp; &nbsp; &#x2714;</span>

     <span style="position: absolute; top: 135px; left: 30px; width: 265px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 265px"><div class="slidecon" style="left: 65px" id="chessucieloid"></div></div>
        <div class="slidetitle" style="top: 25px; left: 85px;">Rating: (<span id="crangesystem" style="color: #800000; font-weight: bold" >E</span>)&nbsp;
         <span id="cucieloid" style="color: #800000; font-weight: bold" >1500</span>
        </div>
     </span>

     <span style="position: absolute; top: 185px; left: 30px; width: 145px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 145px"><div class="slidecon" style="left: 15px" id="chessmovetimeid"></div></div>
        <div class="slidetitle" style="top: 25px; left: 5px;">Move time: <span id="cmovetimeid" style="color: #800000; font-weight: bold">50</span> msec</div>
     </span>

     <span style="position: absolute; top: 185px; left: 185px; width: 110px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 110px"><div class="slidecon" style="left: 40px" id="chessdepthid"></div></div>
        <div class="slidetitle" style="top: 25px; left: 25px;">Depth: <span id="cdepthid" style="color: #800000; font-weight: bold">10</span></div>
     </span>


     <span style="position: absolute; top: 235px; left: 30px; width: 145px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 145px"><div class="slidecon" style="left: 12px" id="chesscompminid"></div></div>
        <div class="slidetitle" style="top: 25px; left: 35px;">Timer: <span id="cgameminid" style="color: #800000; font-weight: bold">3</span> min</div>
     </span>

     <span style="position: absolute; top: 235px; left: 185px; width: 110px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 110px"><div class="slidecon" style="left: 0px" id="chesscompincid"></div></div>
        <div class="slidetitle" style="top: 25px; left: 5px;">Increment: <span id="cgameincid" style="color: #800000; font-weight: bold">0</span> sec</div>
     </span>

   <span style="position: absolute; top: 290px; left: 40px; width: 120px">
      <span class="selectlabel" style="top: 2px; left: 0px" >Variant: </span>
      <select id="chesscompselectvariantid" type="text" class="selectinp" style="top: 0px; left: 60px; width: 160px" spellcheck="false" value=0 ></select>
      <span id="chesscompspanvariantid" type="text" class="selectval" style="top: 2px; left: 65px; width: 65px">Standard</span>
     </span>
     <div id="chesscompvariantdivid" class="divoption" style="visibility: hidden; top: 310px; left: 100px"><div
            style="position: absolute; overflow-y: scroll; top: 5px; left: 5px"><ul id="chesscompvariantid" class="uloption"></ul></div></div>

     <span style="position: absolute; top: 325px; left: 40px; width: 120px">
      <span class="selectlabel" style="top: 2px; left: 0px" >Piece: </span>
      <select id="chesscompselectpieceid" type="text" class="selectinp" style="top: 0px; left: 60px; width: 160px" spellcheck="false" value=2 ></select>
      <span id="chesscompspanpieceid" type="text" class="selectval" style="top: 2px; left: 65px; width: 65px">Random</span>
     </span>
     <div id="chesscomppiecedivid" class="divoption" style="visibility: hidden; top: 345px; left: 100px"><div
             style="position: absolute; overflow-y: scroll; top: 5px; left: 5px"><ul id="chesscomppieceid" class="uloption"></ul></div></div>

     <span style="position: absolute; top: 360px; left: 100px; width: 145px">
        <div class="slidediv" style="top: 0px; left: 0px; width: 145px"><div class="slidecon" style="left: 12px" id="chesscompsimulid"></div></div>
        <span id="csimulabelid" style="position: absolute; display: inline-block; top: 0px; left: 155px; color: #800000; font-weight: normal"></span>
        <div class="slidetitle" style="top: 25px; left: 5px;">Challenge: <span id="csimulid" style="color: #800000; font-weight: bold">1</span> engine(s)
        </div>
     </span>

     <button class="defaultbtn" style="top: 405px; left: 15px; width: 295px; height: 45px; border: 0px; cursor: pointer;" id="playcompbtnid" >Start Game</button>
  </div>

 </div>
 <span class="settingscloseid" style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer; z-index: 15003;
             border: 0px solid #ababab; position: absolute; top: 12px; left: 322px" >&#x2715</span>
</div>

<div id="signupdivid"  style="position: fixed; top: 200px; left: 300px; width: 440px; height: 250px; visibility: hidden; border-radius: 10px;
        box-shadow: 3px 3px 3px 3px rgb(50, 50, 50, 0.3);
        border: 3px solid #787060; background-color: #D9E8E8; margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15000;">
<div id="signupid" class="messageid" style="width: 440px; height: 250px; z-index: 15001 !important;">
     <span class="defaultspn" style="top: 30px; left: 74px">Username</span><input type="text" class="inputclass" style="top: 30px; left: 180px" id="su_usernameid" spellcheck="false" />
     <span class="defaulterr" style="top: 30px; left: 360px" onclick="showError(this)" id="err1001" >&#x2757;</span>
     <span class="defaultspn" style="top: 60px; left: 75px">Password</span><input type="password" class="inputclass" style="top: 60px; left: 180px" id="su_passwdid" spellcheck="false" />
     <span class="defaulterr" style="top: 60px; left: 360px" onclick="showError(this)" id="err1002" >&#x2757;</span>
     <span class="defaultspn" style="top: 95px; left: 69px">First Name</span><input type="text" class="inputclass" style="top: 95px; left: 180px" id="su_firstnameid" spellcheck="false" />
     <span class="defaultspn" style="top: 125px; left: 71px">Last Name</span><input type="text" class="inputclass" style="top: 125px; left: 180px" id="su_lastnameid" spellcheck="false" />
     <span class="defaultspn" style="top: 155px; left: 40px">Email Address</span><input type="text" class="inputclass" style="top: 155px; left: 180px" id="su_emailid" spellcheck="false" />
     <span class="defaulterr" style="top: 155px; left: 360px" onclick="showError(this)" id="err1003" >&#x2757;</span>
     <button class="defaultbtn" style="top: 190px; left: 20px; width: 400px; height: 45px; border: 0px; cursor: pointer" onclick="signup('signupdivid')" >Sign Up</button>
</div>
 <span  style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer; z-index: 15002;
             border: 0px solid #ababab; position: absolute; top: 12px; left: 437px" onclick="closeMessage(this.parentNode)" >&#x2715</span>
</div>

<div id="signindivid"  style="position: fixed; top: 200px; left: 300px; width: 440px; height: 190px; visibility: hidden; border-radius: 10px;
        box-shadow: 3px 3px 3px 3px rgb(50, 50, 50, 0.3);
        border: 3px solid #787060; background-color: #D9E8E8; margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15000;">
<div id="loginid" class="messageid" style="width: 440px; height: 190px; z-index: 15001 !important;">
     <span class="defaultspn" style="top: 30px; left: 74px">Username</span><input type="text" class="inputclass" style="top: 30px; left: 180px" id="si_usernameid" spellcheck="false" />
     <span class="defaulterr" style="top: 30px; left: 360px" onclick="showError(this)" id="err1004" >&#x2757;</span>
     <span class="defaultspn" style="top: 60px; left: 75px">Password</span><input type="password" class="inputclass" style="top: 60px; left: 180px" id="si_passwdid" spellcheck="false" />
     <span class="defaulterr" style="top: 60px; left: 360px" onclick="showError(this)" id="err1005" >&#x2757;</span>
     <button class="defaultbtn" style="top: 100px; left: 20px; width: 400px; height: 45px; border: 0px; cursor: pointer" onclick="signin('signindivid')" >Login</button>
     <span style="color: #0000ff; position: absolute; display: block; top: 160px; left: 100px; cursor: pointer" onclick="showSignUp('signupdivid')" id="registerspanid">Register</span>
     <span style="color: #0000ff; position: absolute; display: block; top: 160px; left: 240px; cursor: pointer" onclick="showPwdReset('signupdivid')" id="resetpwdid">Forgot Password?</span>
</div>
 <span  style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer; z-index: 15002;
             border: 0px solid #ababab; position: absolute; top: 12px; left: 437px" onclick="closeMessage(this.parentNode)" >&#x2715</span>
</div>


<div id="machineid" style="visibility: hidden;  margin: 0px 0px 0px 0px; z-index: 50;">
 <div style="position: absolute; top: 40px; left: 50px; width: 420px; height: 100px;
        border: 3px solid #000000; background-color: #DEDEDE; margin: 0px 0px 0px 0px; z-index: 30;">
    <div style="position: absolute; top: 10px; left: 25px; width: 400px; z-index: 25" id="blackpromotionid">
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 50px; position: absolute; top: 0px; left: 0">&#9818;</span>
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 12pt; padding: 2px; position: absolute; top: 11px; left: 65px">
           <input class="engineclass" type="radio" name="blackplayer" id="blackplayerid" value="human" checked />Human<br>
           <input class="engineclass" type="radio" name="blackplayer" id="blackplayerid" value="machine" />Machine
         </span>
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 50px; position: absolute; top: 0px; left: 200px">&#9812;</span>
         <span style="cursor: pointer; z-index: 20; border: 1px solid #ababab; font-size: 12pt; padding: 2px; position: absolute; top: 11px; left: 265px">
           <input class="engineclass" type="radio" name="whiteplayer" id="whiteplayerid" value="human" checked />Human<br>
           <input class="engineclass" type="radio" name="whiteplayer" id="whiteplayerid" value="machine"/>Machine
         </span>
    </div>
    <span class="engineclass" id="engineid" style="cursor: pointer; z-index: 20; color: #8a8a8a; font-weight: bold; font-size: 10pt; cursor: pointer;
             border: 0px solid #ababab; position: absolute; top: 0px; left: 402px">&#x2715</span>
 </div>
</div>

<div id="setpieceid"  style="position: absolute; width: 40px; visibility: hidden; padding: 5px">
 <div id="bpieceid" class="pieceid" style="top: 0px; ">
  <img id="qdtid" src="/images/rmoo_qdt.svg" style="width: 40px; height: 40px; top: 5px" class="setpieces">
  <span id="pcaptureid_qdt" class="piecebnumid" style="top: 30px">8</span>
  <img id="rdtid" src="/images/rmoo_rdt.svg" style="width: 40px; height: 40px; top: 45px" class="setpieces">
  <span id="pcaptureid_rdt" class="piecebnumid" style="top: 70px">8</span>
  <img id="bdtid" src="/images/rmoo_bdt.svg" style="width: 40px; height: 40px; top: 85px" class="setpieces">
  <span id="pcaptureid_bdt" class="piecebnumid" style="top: 110px">8</span>
  <img id="ndtid" src="/images/rmoo_ndt.svg" style="width: 40px; height: 40px; top: 125px" class="setpieces">
  <span id="pcaptureid_ndt" class="piecebnumid" style="top: 150px">8</span>
  <img id="pdtid" src="/images/rmoo_pdt.svg" style="width: 40px; height: 40px; top: 165px" class="setpieces">
  <span id="pcaptureid_pdt" class="piecebnumid" style="top: 190px">8</span>
 </div>
 <div id="wpieceid" class="pieceid" style="top: 0px; ">
  <img id="pltid" src="/images/rmoo_plt.svg" style="width: 40px; height: 40px; top: 5px" class="setpieces">
  <span id="pcaptureid_plt" class="piecewnumid" style="top: 30px">8</span>
  <img id="nltid" src="/images/rmoo_nlt.svg" style="width: 40px; height: 40px; top: 45px" class="setpieces">
  <span id="pcaptureid_nlt" class="piecewnumid" style="top: 70px">8</span>
  <img id="bltid" src="/images/rmoo_blt.svg" style="width: 40px; height: 40px; top: 85px" class="setpieces">
  <span id="pcaptureid_blt" class="piecewnumid" style="top: 110px">8</span>
  <img id="rltid" src="/images/rmoo_rlt.svg" style="width: 40px; height: 40px; top: 125px" class="setpieces">
  <span id="pcaptureid_rlt" class="piecewnumid" style="top: 150px">8</span>
  <img id="qltid" src="/images/rmoo_qlt.svg" style="width: 40px; height: 40px; top: 165px" class="setpieces">
  <span id="pcaptureid_qlt" class="piecewnumid" style="top: 190px">8</span>
 </div>
</div>

<div id="threechecksid"  style="position: absolute; width: 40px; visibility: hidden; padding: 5px">
 <div id="bpieceid" class="pieceid" style="top: 0px; height: 130px ">
  <img id="qdtid" src="/images/rmoo_kdt.svg" style="width: 40px; height: 40px; top: 5px" class="setpieces">
  <span id="pcaptureid_kdt1" class="piecebchkid" style="top: 18px;">+</span>
  <img id="rdtid" src="/images/rmoo_kdt.svg" style="width: 40px; height: 40px; top: 45px" class="setpieces">
  <span id="pcaptureid_kdt2" class="piecebchkid" style="top: 58px">+</span>
  <img id="bdtid" src="/images/rmoo_kdt.svg" style="width: 40px; height: 40px; top: 85px" class="setpieces">
  <span id="pcaptureid_kdt3" class="piecebchkid" style="top: 98px">+</span>
 </div>
 <div id="wpieceid" class="pieceid" style="top: 0px; height: 130px">
  <img id="pltid" src="/images/rmoo_klt.svg" style="width: 40px; height: 40px; top: 5px" class="setpieces">
  <span id="pcaptureid_klt1" class="piecewchkid" style="top: 18px">+</span>
  <img id="nltid" src="/images/rmoo_klt.svg" style="width: 40px; height: 40px; top: 45px" class="setpieces">
  <span id="pcaptureid_klt2" class="piecewchkid" style="top: 58px">+</span>
  <img id="bltid" src="/images/rmoo_klt.svg" style="width: 40px; height: 40px; top: 85px" class="setpieces">
  <span id="pcaptureid_klt3" class="piecewchkid" style="top: 98px">+</span>
 </div>
</div>

<div id="setfenid"  style="position: absolute; top: 840px; left: 170px; width: 610px; height: 40px; visibility: hidden; border-radius: 25px 25px 25px 25px;
        border: 3px 3px 3px 3px solid #81d765; background-color: #D9E8E8; margin: 0px 0px 0px 0px">
 <div style="position: absolute; top: 0px; left: 0px; border-radius: 25px 0px 0px 25px; background-color: #81d765; color: #252525; width: 60px; height: 40px;
               font-size: 16px; font-weight: normal; font-family: helvetica; text-align: center; cursor: pointer"
                onclick="setFEN(this)" ><span style="position: absolute; display: block; margin: 10px 5px 5px 20px">Set</span></div>
 <div style="position: absolute; top: 0px; left: 50px; background-color: #81d765; color: #252525; width: 60px; height: 40px;
		font-size: 16px; font-weight: normal; font-family: helvetica; text-align: center; cursor: pointer"
                onclick="clearFEN(this)" ><span style="position: absolute; display: block; margin: 10px 5px 5px 10px">Clear</span></div>
      <input type="text" style="position: absolute; width: 420px; height: 35px; outline: 0px; border: 0px; background-color: #D9E8E8;
                  left: 120px; top: 0px; color: #4a4a4a; font-size: 10pt; font-weight: normal; font-family: helvetica" autocomplete="off" autocorrect="off"
                spellcheck="false"
                value="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQKq - 0 1"/>
 <div style="position: absolute; top: 0px; right: 0px; border-radius: 0px 25px 25px 0px; background-color: #81d765; color: #252525; width: 60px; height: 40px;
		font-size: 16px; font-weight: normal; font-family: helvetica; text-align: center; cursor: pointer"
                onclick="saveFEN(this)" ><span style="position: absolute; display: block; margin: 10px 5px 5px 10px">Save</span></div>
</div>

<div id="errordivid"  style="position: fixed; top: 0px; left: 300px; width: 240px; height: 50px; visibility: hidden; border-radius: 10px;
        box-shadow: 2px 2px 2px 2px rgb(50, 50, 50, 0.2); background-color: #f7e5ce; #color: #252525;
        border: 0px solid #787060;  margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15003;">
</div>

<div id="messagedivid"  style="position: absolute; top: 140px; left: 140px; width: 240px; height: 250px; visibility: hidden; border-radius: 10px;
        box-shadow: 4px 4px 4px 4px rgb(50, 50, 50, 0.5);
        border: 3px solid #787060; background-color: #FBF5ED; margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15000;">
 <div id="messageid" class="messageid" style="width: 240px; height: 250px; z-index: 15001;"></div>
 <span  style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer; z-index: 15002;
             border: 0px solid #ababab; position: absolute; top: 12px; left: 237px" onclick="closeMessage(this.parentNode)" >&#x2715</span>
</div>

<div id="waitingmatchid"  style="position: absolute; top: 140px; left: 140px; width: 300px; height: 120px; visibility: hidden; border-radius: 10px;
        box-shadow: 4px 4px 4px 4px rgb(50, 50, 50, 0.5);
        border: 3px solid #787060; background-color: #FBF5ED; margin: 0px 0px 0px 0px; padding: 10px 10px 10px 10px; z-index: 15000;">
 <div id="waitingid" class="messageid" style="width: 300px; height: 120px; z-index: 15001; font-weight: bold; font-size: 16pt; font-family: helvetica; text-align: center">
  <span style="position: absolute; display: block; bottom: 0px; width: 100%; height: 70%; color: #477551" id="wmsgid"></span>
 </div>
 <span  style="cursor: pointer; z-index: 20; color: #5a5a5a; font-weight: bold; font-size: 10pt; cursor: pointer; z-index: 15002;
             border: 0px solid #ababab; position: absolute; top: 12px; left: 297px" onclick="closeMessage(this.parentNode)" >&#x2715</span>
</div>

<div id="promoteid" style="position: absolute; visibility: hidden;  margin: 0px 0px 0px 0px; top: 100px; left: 100px">
 <div style="position: absolute; top: 0px; left: 0px; width: 300px; height: 100px; 
        border: 3px solid #000000; background-color: #DEDEDE; margin: 0px 0px 0px 0px; z-index: 10;">
    <div class="promocontain" id="blackpromotionid" > 
         <span id='Q' class="promoclass">&#9819;</span>
         <span id='R' class="promoclass">&#9820;</span>
         <span id='B' class="promoclass">&#9821;</span>
         <span id='N' class="promoclass">&#9822;</span>
    </div>
    <div class="promocontain" id="whitepromotionid">
         <span id='Q' class="promoclass">&#9813;</span>
         <span id='R' class="promoclass">&#9814;</span>
         <span id='B' class="promoclass">&#9815;</span>
         <span id='N' class="promoclass">&#9816;</span>
    </div>
 </div>
</div>


</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pegjs/0.9.0/peg.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="/jscripts/flags.js"></script>
<script type="text/javascript">

    var RMOO_PIECES_   = 'rmoo'; // 'rmoo' vs 'default'
    var HDR_FTR_HSIZE = 25;
    var BOARDSIZE_ =  840;
    var BOARDOFFSET_ = 0;
    var PIECESIZE_ = 0;
    const bINITFEN_      = "RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbkqbnr w KQkq - 0 1";
    const wINITFEN_      = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
    const wINITFEN960_   = "rkbnnbqr/pppppppp/8/8/8/8/PPPPPPPP/RKBNNBQR w KQkq - 0 1";
    const bINITFENHORDE_ = "RNBKQBNR/PPPPPPPP/8/1pp2pp1/pppppppp/pppppppp/pppppppp/pppppppp w KQ - 0 1";
    const wINITFENHORDE_ = "rnbqkbnr/pppppppp/8/1PP2PP1/PPPPPPPP/PPPPPPPP/PPPPPPPP/PPPPPPPP w kq - 0 1";
    var   _CONTROLON_ = { sidepanel: true, boardnum: true, piecemove: true, fixed: false, border: true, header: true  }
    var   _CONTROLOFF_ = { sidepanel: false, boardnum: false, piecemove: true, fixed: true, border: false, header: false  }
    var   _NO_POSSIBLE_MOVES_ = false;
    var   _POSSIBLE_STALE_MATE_ = false;
    var   _POSSIBLE_CHECK_MATE_ = false;
    var   _CHECK_MATE_ = false;
    var   _STALE_MATE_ = false;
    var   CHESSGAME_   = null;
    var   BOARDS_    = [];
    var   SESSION_   = {};
    var   GUEST      = 201;
    var   REGISTERED = 202;
    var   CONFIG_    = { ratesystem: 'elo', boards: {}, layout: { free: true, coor: { col: 2, row: 5, width: 480, height: 480 } } };
    const HUMAN        = "human";
    const MACHINE      = "machine";
    const MANUAL       = "manual";
    const NOTMANUAL    = "notmanual";
    const WHITE        =  97;
    const BLACK        =  98;
    const UNMOVE       = 100;
    const GOODMOVE     = 101;
    const ENPASSANT    = 102;
    const EATPIECE     = 103;
    const CASTLESHORT  = 104;
    const CASTLELONG   = 105;
    const DROPPED      = 106; // for CrazyHouse games
    const ATOMIC_IMG   = '/images/rmoo_atomic.svg';
    const TIMER_BULLET_ = 1200; // ( 1000 ms * 60 sec * 1 min ) / 50 ms callback 
    const TIMER_BLITZ_ = 3600;  // ( 1000 ms * 60 sec * 3 min ) / 50 ms callback 
    const TIMER_RAPID_ = 12000; // ( 1000 ms * 60 sec * 10 min ) / 50 ms callback
    const TIMER_CLASSIC_ = 60000; // ( 1000 ms * 60 sec * 50 min ) / 50 ms callback (should be able to play 40 moves in 50 min.
    const horiz = [ "a", "b", "c", "d", "e", "f", "g", "h" ];
    const vertical = [1, 2, 3, 4, 5, 6, 7, 8];
    const chessdiv   = document.getElementById("chessdiv");
    const sidepanel  = document.getElementById("sidepanel");
    const cubicle  = document.getElementById("cubicleid");
    const chessboard = document.getElementById("chessboard");
    const chessgame = document.getElementById("chessgame");
    const chessgame1 = document.getElementById("chessgame1");
    const chessheader = document.getElementById("chessheader");
    const chessfooter = document.getElementById("chessfooter");
    const chessmoves = document.getElementById("chessmoves");
    const chessmovesid = document.getElementById("chessmovesid");
    const chessanalysisid = document.getElementById("chessanalysisid");
    const moveid = document.getElementById("moveid");
    const chessrate = document.getElementById("chessrate");
    const chessside0 = document.getElementById("chessside0");
    const engineid = document.getElementById("engineid");
    const whitepromotionid = document.getElementById("whitepromotionid");
    const blackpromotionid = document.getElementById("blackpromotionid");
    const btimer = document.getElementById("btimer");
    const wtimer = document.getElementById("wtimer");

    // chesslisting
    const chesstableid = document.getElementById('chesstableid');
    const chesstbodyid = document.getElementById('chesstbodyid');
    const chessls = document.getElementById('chesslisting');
    const chessid = document.getElementById('chesslistid');
    const chesscv = document.getElementById('chesslistcv');
    const chessor = document.getElementById('chesslisttrid');
    const condiv  = document.getElementById('playcontrolid');

    // crazyhouse
    const setpieceid = document.getElementById('setpieceid');

    // for set position
    const setfenid = document.getElementById('setfenid');

    // king of the hill
    const threechecksid = document.getElementById('threechecksid');

    // message window
    const messagedivid   = document.getElementById('messagedivid');
    const waitingmatchid = document.getElementById('waitingmatchid');
    const signupdivid    = document.getElementById('signupdivid');
    const signindivid    = document.getElementById('signindivid');
    const othertoolsid   = document.getElementById('othertoolsid');
    const searchid       = document.getElementById('searchid');
    const gearid         = document.getElementById('gearid');
    const geartoolsid    = document.getElementById('geartoolsid');
    const signinid       = document.getElementById('signinid');
    const registerid     = document.getElementById('registerid');
    const settingsdivid  = document.getElementById('settingsdivid');
    const blanket        = document.getElementById('chessblanket');

    // profile
    const photoimageid = document.getElementById('photoimageid');
    const pr_file = document.getElementById('pr_file');
    const profileid = document.getElementById('profileid');
    const flagsdivid = document.getElementById('flagsdivid');
    const flagsid = document.getElementById('flagsid');
    const flagsoptionid = document.getElementById('flagsoptionid');
    const flagsoptionspanid = document.getElementById('flagsoptionspanid');
    const titledivid = document.getElementById('titledivid');
    const titleid = document.getElementById('titleid');
    const titleoptionid = document.getElementById('titleoptionid');
    const titleoptionspanid = document.getElementById('titleoptionspanid');
   // const ratedivid = document.getElementById('ratedivid');
   // const rateid = document.getElementById('rateid');
    const rateoptionid = document.getElementById('rateoptionid');
    const rateoptionspanid = document.getElementById('rateoptionspanid');
    const profilesaveid = document.getElementById('profilesaveid');
    const profileupdateid = document.getElementById('profileupdateid');
    const profilecloseid = document.getElementById('profilecloseid');
    const ratingid = document.getElementById('ratingid');

    // tournaments
    const caldiv = document.getElementById('caldivid');
    const tourneypdateid = document.getElementById('tourneyupdateid');

    const tourneytypedivid = document.getElementById('tourneytypedivid');
    const tourneytypeid = document.getElementById('tourneytypeid');
    const tourneytypeoptionid = document.getElementById('tourneytypeoptionid');
    const tourneytypeoptionspanid = document.getElementById('tourneytypeoptionspanid');

    const tourneyvariantdivid = document.getElementById('tourneyvariantdivid');
    const tourneyvariantid = document.getElementById('tourneyvariantid');
    const tourneyvarintoptionid = document.getElementById('tourneyvariantoptionid');
    const tourneyvariantoptionspanid = document.getElementById('tourneyvariantoptionspanid');

    const tourneytimerdivid = document.getElementById('tourneytimerdivid');
    const tourneytimerid = document.getElementById('tourneytimerid');
    const tourneytimeroptionid = document.getElementById('tourneytimeroptionid');
    const tourneytimeroptionspanid = document.getElementById('tourneytimeroptionspanid');

    const tourneyincdivid = document.getElementById('tourneyincdivid');
    const tourneyincid = document.getElementById('tourneyincid');
    const tourneyincoptionid = document.getElementById('tourneyincoptionid');
    const tourneyincoptionspanid = document.getElementById('tourneyincoptionspanid');

    const tourneyrecdivid = document.getElementById('tourneyrecdivid');
    const tourneyrecid = document.getElementById('tourneyrecid');
    const tourneyrecoptionid = document.getElementById('tourneyrecoptionid');
    const tourneyrecoptionspanid = document.getElementById('tourneyrecoptionspanid');

    const tourneyhrdivid = document.getElementById('tourneytimehrdivid');
    const tourneyhrid = document.getElementById('tourneytimehrid');
    const tourneyhroptionid = document.getElementById('tourneytimehroptionid');
    const tourneyhroptionspanid = document.getElementById('tourneytimehroptionspanid');

    const tourneymindivid = document.getElementById('tourneytimemindivid');
    const tourneyminid = document.getElementById('tourneytimeminid');
    const tourneyminoptionid = document.getElementById('tourneytimeminoptionid');
    const tourneyminoptionspanid = document.getElementById('tourneytimeminoptionspanid');

    const tourneyforfeitdivid = document.getElementById('tourneyforfeitdivid');
    const tourneyforfeitid = document.getElementById('tourneyforfeitid');
    const tourneyforfeitoptionid = document.getElementById('tourneyforfeitoptionid');
    const tourneyforfeitoptionspanid = document.getElementById('tourneyforfeitoptionspanid');

    // settings humanoid_
    const chessvariantdivid = document.getElementById('chessvariantdivid');
    const chessselectvariantid = document.getElementById('chessselectvariantid');
    const chessspanvariantid = document.getElementById('chessspanvariantid');
    const chessvariantid = document.getElementById('chessvariantid');

    const chesspiecedivid = document.getElementById('chesspiecedivid');
    const chessselectpieceid = document.getElementById('chessselectpieceid');
    const chessspanpieceid = document.getElementById('chessspanpieceid');
    const chesspieceid = document.getElementById('chesspieceid');

    const chessplayerdivid = document.getElementById('chessplayerdivid');
    const chessselectplayerid = document.getElementById('chessselectplayerid');
    const chessspanplayerid = document.getElementById('chessspanplayerid');
    const chessplayerid = document.getElementById('chessplayerid');

    // settings machinoid_
    const chesscompvariantdivid = document.getElementById('chesscompvariantdivid');
    const chesscompselectvariantid = document.getElementById('chesscompselectvariantid');
    const chesscompspanvariantid = document.getElementById('chesscompspanvariantid');
    const chesscompvariantid = document.getElementById('chesscompvariantid');

    const chesscomppiecedivid = document.getElementById('chesscomppiecedivid');
    const chesscompselectpieceid = document.getElementById('chesscompselectpieceid');
    const chesscompspanpieceid = document.getElementById('chesscompspanpieceid');
    const chesscomppieceid = document.getElementById('chesscomppieceid');

    // notice & messages
    const noticeid = document.getElementById('noticeid');

    // watch game panels
    const watchgamesid = document.getElementById('watchgamesid');
    const watchgamepanel1a = document.getElementById("watchgamepanel1a");
    const watchgamepanel2a = document.getElementById("watchgamepanel2a");
    const watchgamepanel3a = document.getElementById("watchgamepanel3a");
    const watchgamepanel4a = document.getElementById("watchgamepanel4a");

    // eval panels
    const evalpanel1a = document.getElementById("evalpanel1a");
    const evalpanel2a = document.getElementById("evalpanel2a");
    const evalpanel3a = document.getElementById("evalpanel3a");
    const evalpanel1b = document.getElementById("evalpanel1b");

    // list tourneys
    const schedtourneyid = document.getElementById('schedtourneyid');
    const schedpanel1a = document.getElementById('schedpanel1a');
    const schedpanel2a = document.getElementById('schedpanel2a');
    const schedpanel3a = document.getElementById('schedpanel3a');
    const schedpanel1b = document.getElementById('schedpanel1b');
    const schedpanel2b = document.getElementById('schedpanel2b');
    const schedpanel3b = document.getElementById('schedpanel3b');
    const schedpanel4b = document.getElementById('schedpanel4b');

    // evaluation
    const evaluateid = document.getElementById('evaluateid');

    // formus
    const forumsid = document.getElementById('forumsid');

    // layout
    const layoutid = document.getElementById('layoutid');
    const pr_free_layout = document.getElementById('pr_free_layout');
    const pr_columns = document.getElementById('pr_columns');
    const pr_rows = document.getElementById('pr_rows');

    // profile errors

    // promotion template
    const promoteid = document.getElementById("promoteid")


    // Controlling window display
    var ZINDEX_ = 50;


    const BOARDCOLOR_ = { 
                          "ala chess.com theme" : { sd: '#c8d0b5', dt: '#708f4f', lt: '#eaecd6', hdt: '#506f2f', hlt: '#babca6' }, 
                          "ala lichess.com theme" : { sd: '#d5bfa6', dt: '#aa8965', lt: '#e8dabf', hdt: '#7a5935', hlt: '#b8aa8f' }, 
                         "Green 1" :      { sd: '#a7b093', dt: '#8b9f60', lt: '#e9efdc', hdt: '#6b7f40', hlt: '#b9bfac' },
                         "Green 2" :      { sd: '#a0ab89', dt: '#64835b', lt: '#e9efdc', hdt: '#44633b', hlt: '#b9bfac' },
                         "Brown 1" :      { sd: '#a19686', dt: '#c79361', lt: '#fbf2e9', hdt: '#a77341', hlt: '#cbc2b9' },
                         "Brown 2" :      { sd: '#a19686', dt: '#a47a4f', lt: '#e5d8cc', hdt: '#845a2f', hlt: '#b5a89c' },
                         "Grey 1" :       { sd: '#aaa7b5', dt: '#929195', lt: '#ebeaed', hdt: '#727175', hlt: '#bbbabd' },
                         "Purple" :       { sd: '#ae9ba3', dt: '#9d7287', lt: '#ded9db', hdt: '#7d5267', hlt: '#aec99b' },
                         "Cyan 1" :       { sd: '#81b4ad', dt: '#50938a', lt: '#d5eae7', hdt: '#30736a', hlt: '#a5bab7' },
                         "Blue 1" :       { sd: '#7c939c', dt: '#418196', lt: '#d6e2e6', hdt: '#216176', hlt: '#a6b2b6' },
                         "Blue 2" :       { sd: '#9fbcdc', dt: '#4e7b9c', lt: '#e3e9ef', hdt: '#2e5b7c', hlt: '#b3b9bf' },
                         "Blue 3" :       { sd: '#9fbcdc', dt: '#6b86a4', lt: '#e3e9ef', hdt: '#4b6684', hlt: '#b3b9bf' },
                         "Red 1" :        { sd: '#b6a4a6', dt: '#b37279', lt: '#daccce', hdt: '#935259', hlt: '#aa9c9e' }
                       };

    // Titles
    titles =     [ 
                   { code: '', item: 'None', initial: 'N' }, 
                   { code: '', item: 'Woman Grandmaster (WGM)', initial: 'WGM' }, 
 	           { code: '', item: 'Woman International Master (WIM)', initial: 'WIM' }, 
		   { code: '', item: 'Woman FIDE Master (WFM)', initial: 'WFM' }, 
                   { code: '', item: 'Woman Candidate Master (WCM)', initial: 'WCM' },
                   { code: '', item: 'Woman National Master (WNM)', initial: 'WNM' },
                   { code: '', item: 'Grandmaster (GM)', initial: 'GM' }, 
 	           { code: '', item: 'International Master (IM)', initial: 'IM' }, 
		   { code: '', item: 'FIDE Master (FM)', initial: 'FM' }, 
                   { code: '', item: 'Candidate Master (CM)', initial: 'CM' },
                   { code: '', item: 'National Master (NM)', initial: 'NM' } ];

    // Tournament types
    const tourneytypes = [
                    { code: '', item: 'Ladder Style', initial: 'LS' },
                    { code: '', item: 'Simultaneous Style', initial: 'SI' },
                    { code: '', item: 'Round robin', initial: 'RR' },
                    { code: '', item: 'Swiss system', initial: 'SS' },
                    { code: '', item: 'Single elimination', initial: 'SE' },
                    { code: '', item: 'Double elimination', initial: 'DE' },
                    { code: '', item: 'Scheveningen system', initial: 'SC' }
                   ];

    const tourneyrecs = [
                    { code: '', item: 'None', initial: 'N' },
                    { code: '', item: 'Hourly', initial: 'H' },
                    { code: '', item: 'Every two hours', initial: 'H2' },
                    { code: '', item: 'Every three hours', initial: 'H3' },
                    { code: '', item: 'Daily', initial: 'D' },
                    { code: '', item: 'Weekly', initial: 'W' },
                    { code: '', item: 'Monthly', initial: 'M' }
                  ];

     const xpossible_timer = ['&half;', 1,'1&half;',2,'2&half;', 3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,35,40,45,50,
                                 55,60,65,70,75,80,90,100,120,140,150,160,170,180,200,220,240,260,280, 300 ];
     const xpossible_inc = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,35,40,45,50,55,60,70,80,90,100,120 ];

    const tourneytimer   = [
                    { code: '', item: '&half;', initial: 0.50 }, { code: '', item: '1', initial: 1 }, { code: '', item: '1&half;', initial: 1.50 }, 
                    { code: '', item: '2', initial: 2 }, { code: '', item: '2&half;', initial: 2.5 }, { code: '', item: '3', initial: 3 }, 
                    { code: '', item: '4', initial: 4 }, { code: '', item: '5', initial: 5 }, { code: '', item: '6', initial: 6 }, 
                    { code: '', item: '7', initial: 7 }, { code: '', item: '8', initial: 8 }, { code: '', item: '9', initial: 9 }, 
                    { code: '', item: '10', initial: 10 }, { code: '', item: '11', initial: 11 }, { code: '', item: '12', initial: 12 }, 
                    { code: '', item: '13', initial: 13 }, { code: '', item: '14', initial: 14 }, { code: '', item: '15', initial: 15 }, 
		    { code: '', item: '16', initial: 16 }, { code: '', item: '17', initial: 17 }, { code: '', item: '18', initial: 18 }, 
                    { code: '', item: '19', initial: 19 }, { code: '', item: '20', initial: 20 }, { code: '', item: '25', initial: 25 },
                    { code: '', item: '30', initial: 30 }, { code: '', item: '35', initial: 35 }, { code: '', item: '40', initial: 40 },
                    { code: '', item: '45', initial: 45 }, { code: '', item: '50', initial: 50 }, { code: '', item: '55', initial: 55 },
                    { code: '', item: '60', initial: 60 }, { code: '', item: '65', initial: 65 }, { code: '', item: '70', initial: 70 },
                    { code: '', item: '80', initial: 80 }, { code: '', item: '90', initial: 90 }, { code: '', item: '100', initial: 100 },
                    { code: '', item: '120', initial: 120 }, { code: '', item: '140', initial: 140 }, { code: '', item: '150', initial: 150 },
                    { code: '', item: '160', initial: 160 }, { code: '', item: '170', initial: 170 }, { code: '', item: '180', initial: 180 },
                    { code: '', item: '200', initial: 200 }, { code: '', item: '220', initial: 220 }, { code: '', item: '240', initial: 240 },
                    { code: '', item: '260', initial: 260 }, { code: '', item: '280', initial: 280 }, { code: '', item: '300', initial: 300 }
                     ];

    const tourneyinc   = [ { code: '', item: '0', initial: 0 },
                    { code: '', item: '1', initial: 1 }, { code: '', item: '2', initial: 2 }, { code: '', item: '3', initial: 3 }, 
                    { code: '', item: '4', initial: 4 }, { code: '', item: '5', initial: 5 }, { code: '', item: '6', initial: 6 }, 
                    { code: '', item: '7', initial: 7 }, { code: '', item: '8', initial: 8 }, { code: '', item: '9', initial: 9 }, 
                    { code: '', item: '10', initial: 10 }, { code: '', item: '11', initial: 11 }, { code: '', item: '12', initial: 12 }, 
                    { code: '', item: '13', initial: 13 }, { code: '', item: '14', initial: 14 }, { code: '', item: '15', initial: 15 }, 
		    { code: '', item: '16', initial: 16 }, { code: '', item: '17', initial: 17 }, { code: '', item: '18', initial: 18 }, 
                    { code: '', item: '19', initial: 19 }, { code: '', item: '20', initial: 20 }, { code: '', item: '25', initial: 25 },
                    { code: '', item: '30', initial: 30 }, { code: '', item: '35', initial: 35 }, { code: '', item: '40', initial: 40 },
                    { code: '', item: '45', initial: 45 }, { code: '', item: '50', initial: 50 }, { code: '', item: '55', initial: 55 },
                    { code: '', item: '60', initial: 60 }, { code: '', item: '65', initial: 65 }, { code: '', item: '70', initial: 70 },
                    { code: '', item: '80', initial: 80 }, { code: '', item: '90', initial: 90 }, { code: '', item: '100', initial: 100 },
                    { code: '', item: '120', initial: 120 }
                     ];

    const tourneyhr   = [
                    { code: '', item: '00', initial: 00 },
                    { code: '', item: '01', initial: 01 }, { code: '', item: '02', initial: 02 }, { code: '', item: '03', initial: 03 },
                    { code: '', item: '04', initial: 04 }, { code: '', item: '05', initial: 05 }, { code: '', item: '06', initial: 06 },
                    { code: '', item: '07', initial: 07 }, { code: '', item: '08', initial: 08 }, { code: '', item: '09', initial: 09 },
                    { code: '', item: '10', initial: 10 }, { code: '', item: '11', initial: 11 }, { code: '', item: '12', initial: 12 },
                    { code: '', item: '13', initial: 13 }, { code: '', item: '14', initial: 14 }, { code: '', item: '15', initial: 15 },
                    { code: '', item: '16', initial: 16 }, { code: '', item: '17', initial: 17 }, { code: '', item: '18', initial: 18 },
                    { code: '', item: '19', initial: 19 }, { code: '', item: '20', initial: 20 }, { code: '', item: '21', initial: 21 },
                    { code: '', item: '22', initial: 22 }, { code: '', item: '23', initial: 23 }
                  ];

    const tourneymin  = [
                    { code: '', item: '00', initial: 00 }, { code: '', item: '05', initial: 05 }, { code: '', item: '10', initial: 10 },
                    { code: '', item: '15', initial: 15 }, { code: '', item: '20', initial: 20 }, { code: '', item: '25', initial: 25 },
                    { code: '', item: '30', initial: 30 }, { code: '', item: '35', initial: 35 }, { code: '', item: '40', initial: 40 },
                    { code: '', item: '45', initial: 45 }, { code: '', item: '50', initial: 50 }, { code: '', item: '55', initial: 55 }
                  ];

    const tourneyforfeit   = [ { code: '', item: '0', initial: 0 },
                    { code: '', item: '	&#8537; (10s)', initial: 10 }, { code: '', item: '&#188; (15s)', initial: 15 }, { code: '', item: '&#8531; (20s)', initial: 20 }, 
                    { code: '', item: '&half; (30s)', initial: 30 }, { code: '', item: '&#8532; (40s)', initial: 40 }, { code: '', item: '&#190; (45s)', initial: 45 }, 
                    { code: '', item: '1', initial: 60 }, { code: '', item: '2', initial: 120 }, { code: '', item: '3', initial: 180 },
                    { code: '', item: '4', initial: 240}, { code: '', item: '5', initial: 300 }, { code: '', item: '8', initial: 480 },
                    { code: '', item: '10', initial: 600 }, { code: '', item: '15', initial: 900 }
                     ];

    // Variants
    const STANDARD    = 'Standard';
    const CHESS960    = 'Chess960';
    const CRAZYHOUSE  = 'Crazy House';
    const KINGOFTHEHILL  = 'King Of The Hill';
    const THREECHECKS = 'Three Checks';
    const ATOMIC    = 'Atomic';
    const HORDE     = 'Horde';
    const THEMOLE    = 'The Mole';
    const THETRAITOR = 'The Traitor';
    const ANTICHESS = 'AntiChess';

    const recvariants = ['Standard', 'Chess960', 'Crazy House', 'King Of The Hill', 'Three Checks', 'Atomic', 'Horde', 
				'The Mole', 'The Traitor', 'AntiChess'];

    const timer_types = ['Bullet', 'Blitz', 'Rapid', 'Classical'];

    const variants = [
                    { code: '', item: 'Standard', initial: 'Std' }, 
                    { code: '', item: 'Chess960', initial: 'c960' }, 
                    { code: '', item: 'Crazy House', initial: 'crazyh' }, 
                    { code: '', item: 'King Of The Hill', initial: 'kinghill' }, 
                    { code: '', item: 'Three Checks', initial: 'threechecks' }, 
                    { code: '', item: 'Atomic', initial: 'atomic' }, 
                    { code: '', item: 'Horde', initial: 'horde' }, 
                    { code: '', item: 'The Mole', initial: 'mole' },
                    { code: '', item: 'The Traitor', initial: 'traitor' } 
                ];

    const tourneyvariants = variants;

    const compvariants = [
                    { code: '', item: 'Standard', initial: 'Std' }, 
                    { code: '', item: 'Chess960', initial: 'c960' },
                    { code: '', item: 'The Mole', initial: 'mole' },
                    { code: '', item: 'The Traitor', initial: 'traitor' }
                ];

    const pieces = [
                    { code: '', item: 'White', initial: 'w' }, 
                    { code: '', item: 'Black', initial: 'b' }, 
                    { code: '', item: 'Random', initial: 'r' }
                ];

    const players = [
                    { code: '', item: 'Random Player(s)', initial: 'r' }, 
                    { code: '', item: 'Friend(s)', initial: 'f' }
                ];

    // Game status
    const STATUS   = { DONE: 1100, RESIGN: 1200, NEW: 1300, PLAYING: 1400, INIT: 1500, INTERRUPTED: 1600, 
		       STOPPED: 1700, ILLEGAL: 1800, HALTED: 1900, SET: 2000, JOINING: 2100, NOTPLAYING: 2200, 
		       SEEKMATCH: 2300, SEEKSIMUL: 2400,  SIMULPLAYING: 2500, EVALUATING: 2600, CANCELED: 2700 };
    const GAMEOVER = { CHECKMATE: 1100, STALEMATE: 1200, ABANDONED: 1300, TIMEOUT: 1400, REPETITION: 1500, DRAWACCEPTED: 1600, RESIGNED: 1700, 
                       INSUFFICIENT: 1800, KINGOFTHEHILL: 1900, THREECHECKS: 2000, ATOMIC: 2001, HORDE: 2002, ABORTED: 2003, FORFEITED: 2004 };


     const possible_ranges =  [
               { mi: 800, ma: 900 },   { mi:  800, ma: 1000 },
               { mi: 900, ma: 1000 },  { mi:  900, ma: 1100 },
               { mi: 1000, ma: 1100 }, { mi: 1000, ma: 1200 },
               { mi: 1100, ma: 1200 }, { mi: 1100, ma: 1300 },
               { mi: 1200, ma: 1300 }, { mi: 1200, ma: 1400 },
               { mi: 1300, ma: 1400 }, { mi: 1300, ma: 1500 },
               { mi: 1400, ma: 1500 }, { mi: 1400, ma: 1600 },
               { mi: 1500, ma: 1600 }, { mi: 1500, ma: 1700 },
               { mi: 1600, ma: 1700 }, { mi: 1600, ma: 1800 },
               { mi: 1700, ma: 1800 }, { mi: 1700, ma: 1900 },
               { mi: 1800, ma: 1900 }, { mi: 1800, ma: 1200 },
               { mi: 1900, ma: 2000 }, { mi: 1900, ma: 2100 },
               { mi: 2000, ma: 2100 }, { mi: 2000, ma: 2200 },
               { mi: 2100, ma: 2200 }, { mi: 2100, ma: 2300 },
               { mi: 2200, ma: 2300 }, { mi: 2200, ma: 2400 },
               { mi: 2300, ma: 2400 }, { mi: 2300, ma: 2500 },
               { mi: 2400, ma: 2500 }, { mi: 2400, ma: 2600 },
               { mi: 2500, ma: 2600 }, { mi: 2500, ma: 2700 },
               { mi: 2600, ma: 2700 }, { mi: 2600, ma: 2800 },
               { mi: 2700, ma: 2800 }, { mi: 2700, ma: 2900 },
               { mi: 2800, ma: 2900 }, { mi: 2800, ma: 3000 },
               { mi: 2900, ma: 3000 }, { mi: 2900, ma: 3100 },
               { mi: 3000, ma: 3100 }, { mi: 3000, ma: 3200 },
               { mi: 3100, ma: 3200 }, { mi: 3100, ma: 3300 },
               { mi: 3200, ma: 3300 }, { mi: 3300, ma: 3400 },
               { mi: 3400, ma: 3500 }, { mi: 3500, ma: 3600 },
               { mi: 3600, ma: 3700 }, { mi: 3700, ma: 3800 },
               { mi: 3800, ma: 4000 } ];
     const possible_rating = [ 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900,
                                  2000, 2100, 2200, 2300, 2400, 2500, 2600, 2700, 2800, 2900, 3000, 3100, 3200, 3300,
                                  3400, 3500 ];
     const possible_movetime = [10,20,30,40,50,75,100,200,500,1000,1200,1400,1500,1700,2000,2400,2600,2800,3000,
                                 3200,3400,3600,3800,4000,4500,5000,5500,6000,6500,7000,7500,8000,8500,9000,9500, 9900];
     const possible_depth = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];

     const possible_timer = ['&half;', 1,'1&half;',2,'2&half;', 3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,35,40,45,50,
                                 55,60,65,70,75,80,90,100,120,140,150,160,170,180,200,230,260,300 ];
     const possible_inc = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,35,40,45,50,55,60,70,80,90,100,120 ];

     // const possible_simul = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,35,40,45,50 ];
     const possible_simul = [1,2,3,4,5,6,7,8 ];
     const possible_csimul = [1,2,3,4];

    // Engine Move
    var ENGINEMOVE_ = null;

    // Engine commands
    _UCI_ = 'uci';
    _ISREADY_ = 'isready';  // set engine options prior to readiness
    _GO_ = 'go';  // after ucinewgame and position

    function gameType(gamemin) {
       var timer = 0, gametype = 4;
       if (gamemin == 0) timer = 0.50; else
       if (gamemin == 1) timer = 1.00; else
       if (gamemin == 2) timer = 1.50; else
       if (gamemin == 3) timer = 2.00; else
       if (gamemin == 4) timer = 2.50; else timer = parseInt(possible_timer[gamemin]);
       if (timer < 3)   gametype = 1; else  /* bullet */
       if (timer <= 10) gametype = 2; else  /* blitz */
       if (timer < 59)  gametype = 3;       /* rapid */
       return gametype;
    }

    function gameColor(piece) {
       if (piece == 1) return WHITE;
       if (piece == 2) return BLACK;
       if (piece == 3) { const rnd = Math.random(); return (rnd >= 0.5) ? BLACK : WHITE; }
    }

    function clone(obj) {
       return Object.assign({}, obj );
    }

    function initRating(rateit = 1500) {
        var ratesystem = { elo: rateit, rmoo: rateit, glicko: rateit, glicko_d: 350, glicko_v: 0.06 }; // initial deviation = 350
        var gametype = { Bullet: clone(ratesystem),  /* bullet */
                         Blitz: clone(ratesystem),  /* blitz */
                         Rapid: clone(ratesystem),  /* rapid */
                         Classical: clone(ratesystem)   /* classical */
                       };
        var rating = {
                "Standard"         : clone(gametype),  /* standard */
                "Chess960"         : clone(gametype),  /* chess960 */
                "Crazy House"      : clone(gametype),  /* crazyhouse */
                "King Of The Hill" : clone(gametype),  /* kingofthehill */
                "Three Checks"     : clone(gametype),  /* threechecks */
                "Atomic"           : clone(gametype),  /* atomic */
                "Horde"            : clone(gametype),  /* horde */
                "The Mole"         : clone(gametype),  /* the mole */
                "The Traitor"      : clone(gametype),  /* the traitor */
                "AntiChess"        : clone(gametype)   /* antichess */
              };
        return rating;
    }

    // styleSheets
    const sheet = document.styleSheets[0]

    // log
    function log(msg) { console.log(msg); } 

    // UTC today
    const UTCdate = function(dt) { return (new Date(new Date(dt).toUTCString().replace(/ GMT/,'')) / 1); };
    const UTCtoday = function() { return (new Date(new Date().toUTCString().replace(/ GMT/,'')) / 1); };
    const LOCALdate = function(dt) { return daylocal(daylocal(dt) + ' GMT'); };

    // calendar
    nmonth = ['January', 'February', 'March', 'April', 'May', 'June','July','August','September','October','November','December'];
    dmonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    week = ['S','M','T','W','T','F','S'];

    function isLeapYear(Y) {
       return ((Y % 4 == 0 && Y % 100 != 0) || Y % 400 == 0);
       return false;
    }

    // rely on the client
    function dayOfWeek(Y, M, D) {
      return new Date(Y, M-1, D).getUTCDay(); 
    }

    function chooseDate() {
      var dt = this.date_;
      var date_ = nmonth[dt.m - 1] + ' ' + dt.d + ' ' + dt.y;
      caldiv.spanid_.innerHTML = date_;
      caldiv.itemid_.value_ = dt;
      caldiv.style.visibility = 'hidden';
      log(this.date_);
    }


    const rules = sheet.rules || sheet.cssRules;
    function getCSS(cls) {
       var sheets = document.styleSheets;
       var rules = null;
       for (var p in sheets) {
          var sheet = sheets[p];
          if (sheet.title == "mycsslist") {  rules = sheet.rules || sheet.cssRules; break }
       }
       for (var p in rules) {
         var rule = rules[p];
         if (rule.selectorText == cls) { return rule; }
       }
       return null;
    }

    function authorizeView() {
log("authorizing ...");
        const signin = signindivid;
        const signup = signupdivid;
        blanket.style.visibility = 'hidden';
        signup.style.visibility = 'hidden';
        signin.style.visibility = 'hidden';
        signinid.style.visibility = 'hidden';
        registerid.style.visibility = 'hidden';
        othertoolsid.style.visibility = 'visible';
        hideErrors();
    }
  
    function unauthorizeView() {
        const signin = signindivid;
        const signup = signupdivid;
        blanket.style.visibility = 'hidden';
        signup.style.visibility = 'hidden';
        signin.style.visibility = 'hidden';
        signinid.style.visibility = 'visible';
        registerid.style.visibility = 'visible';
        othertoolsid.style.visibility = 'hidden';
        hideErrors();
    }

    function guestSession(socketid) {
      const req = new XMLHttpRequest();
      req.onreadystatechange = function() {
         if (this.readyState == 4 && this.status == 200) {
            const usernameid = document.getElementById('usernameid');
            var res = JSON.parse(req.responseText);
log("what is this session?");
log(res);
            if (res.registered != null && res.registered) {
log("got here ...");
               var sess = res.session; 
               if (sess.code || typeof(sess.code) == "undefined") {
log("got here too?");
                     if (sess.errid) {
                        notice("err" + sess.errid);
                     } else {
                        notice("Server error!");
                     }
                } else {
log("got here too?");
                     signedinPlayer(sess);
                }
            } else {
log("utype");
log(res);
               SESSION_.sessionid       = res.token;
               SESSION_.username        = res.username;
               SESSION_.utype           = res.utype;
               SESSION_.socketid        = socketid;
               SESSION_.rating          = initRating();
               SESSION_.machine_rating  = null;
               usernameid.innerHTML = res.username;
               unauthorizeView();
            }
         }
      };
      req.open('POST', 'http://localhost:3000/guest', true);
      req.setRequestHeader("Content-Type", "application/json");
      const data = JSON.stringify({ socket: {socketid: socketid} } ); 
      req.send(data);
      return true;
    }

    function machineScore(game) {  // score garnered after playing an engine.
log("get the score ...");
log(game);
      const req = new XMLHttpRequest();
      req.onreadystatechange = function() {
         if (this.readyState == 4 && this.status == 200) {
            const usernameid = document.getElementById('usernameid');
            var res = JSON.parse(req.responseText);
            var game    = res.game;
            var nrating = res.nrating;
            if (SESSION_.sessionid == res.sessionid && SESSION_.username == res.username) {
               var this_ = getGame(game.gameid);
log(this_.rematch_);
               if (nrating != null && this_ != null) {
                  this_.GAME_STATE.gameover_ = game.status;
                  this_.GAME_STATE.gameoverside_ = (game.rt == "0-1") ? WHITE : BLACK;
                  updateRating(this_, game, this_.rematch_, nrating);
                  this_.msgDone(this_, nrating, game.ratesystem);
               } else {
                  this_.notice("Unable to generate score ...");
               }
            } else {
                  this_.notice("Unable to generate score ...");
            }
         }
      };
      req.open('POST', 'http://localhost:3000/machinescore', true);
      req.setRequestHeader("Content-Type", "application/json");
      const data = JSON.stringify(game);
      req.send(data);
      return true;
    }

    function getScore(game) {
        const gametype = timer_types[game.gametype - 1];
        var variant  = null;
        if (game.WPLAYER_ == MACHINE || game.BPLAYER_ == MACHINE) {
            variant = compvariants[tourney.settings.variant - 1].item;
        } else {
            variant = variants[tourney.settings.variant - 1].item;
        }
        var wrating = game.wgame.rating[variant][gametype];
        var brating = game.bgame.rating[variant][gametype];
        var points = { elo_p : 0, rmoo_p: 0, glicko_p: 0 };
        return { wrating: wrating, brating: brating, wpoints: points, bpoints: points  };
    }

    function updateRating(this_, game, tourney, nrating) { // rating after playing an engine.
        const session = SESSION_;

        const gametype = timer_types[tourney.gametype - 1];
        var variant  = null;
        if (this_.WPLAYER_ == MACHINE || this_.BPLAYER_ == MACHINE) {
            variant = compvariants[tourney.settings.variant - 1].item;
        } else {
            variant = variants[tourney.settings.variant - 1].item;
        }
log("score variant ...");
log(this_.WPLAYER_);
log(this_.BPLAYER_);
log(variant);
log(nrating);
        var mrating = null, mrating_ = null, hrating = null, hrating_ = null;
        var hn_rating = null, mn_rating = null;
        var hsrating_ = session.rating[variant][gametype];          // (hs) - human session
        var msrating_ = session.machine_rating[variant][gametype];  // (ms) - machine session
       
        if (tourney.wgame.player == MACHINE) {
           mrating   = tourney.wgame.rating;
           mrating_  = mrating[variant][gametype];  // this_.rematch_
           hrating   = tourney.bgame.rating;
           hrating_  = hrating[variant][gametype];  // this_.rematch_
           mn_rating = nrating.wrating; 
           hn_rating = nrating.brating; 
        } else {
           mrating   = tourney.bgame.rating;
           mrating_  = mrating[variant][gametype];  // this_.rematch_
           hrating   = tourney.wgame.rating;
           hrating_  = hrating[variant][gametype];  // this_.rematch_
           mn_rating = nrating.brating; 
           hn_rating = nrating.wrating; 
        }

        hsrating_.elo      = hrating_.elo      = hn_rating.elo;
        hsrating_.glicko   = hrating_.glicko   = hn_rating.glicko;
        hsrating_.glicko_d = hrating_.glicko_d = hn_rating.glicko_d;
        hsrating_.glicko_v = hrating_.glicko_v = hn_rating.glicko_v;
        hsrating_.rmoo     = hrating_.rmoo     = hn_rating.rmoo;

        msrating_.elo      = mrating_.elo      = mn_rating.elo;
        msrating_.glicko   = mrating_.glicko   = mn_rating.glicko;
        msrating_.glicko_d = mrating_.glicko_d = mn_rating.glicko_d;
        msrating_.glicko_v = mrating_.glicko_v = mn_rating.glicko_v;
        msrating_.rmoo     = mrating_.rmoo     = mn_rating.rmoo;

log("final ratings ...");
log(hsrating_);
log(msrating_);
log(tourney);

    }

    function switchDate() {
      const tb = document.getElementById('caltableid');
      const tm = document.getElementById('calmonthid');
      const fm = document.getElementById('calfmid');
      const bm = document.getElementById('calbmid');
      const day = new Date().getDate();
      const year = new Date().getFullYear();
      const month = new Date().getMonth();
      var tr = tb.firstChild;
      var dt = this.date_, Y = 0, M = 0;
      log(this.date_);

      var cnt = 0;

      if ((dt.m + dt.d) < 1) {
           Y = dt.y - 1;
           M = 12;
      } else
      if ((dt.m + dt.d) > 12 ) {
           Y = dt.y + 1;
           M = 1;
      } else {
           Y = dt.y; M = dt.m + dt.d;
      }

      fm.date_ = { y: Y, m: M, d: -1 };
      bm.date_ = { y: Y, m: M, d: 1 };

      const start = dayOfWeek(Y, M, 1) + 1; 
      const ymonth = (isLeapYear(Y) && M==2) ? dmonth[M - 1] + 1:dmonth[M - 1];

      tm.innerHTML = nmonth[M - 1] + ',' + Y;
      for (var j=0;j<6;j++) {
         tr = tr.nextSibling;
         var td = tr.firstChild;
         for (var i=1;i<=7;i++) {
            const c = j * 7 + i;
            if (c >= start && cnt < ymonth) {
               cnt ++;
               td.innerHTML = cnt;
               td.onclick = chooseDate;
               td.date_ = { y: Y, m: M, d: cnt };
            } else {
               td.innerHTML = '';
               td.onclick = function() {};
            }
            if (day == cnt  && year == Y && month == M - 1) {
              td.style.backgroundColor = "#afafaf";
            } else {
              td.style.backgroundColor = "";
            }
            td = td.nextSibling;
         }
      }
    }

    function populateCalendar(Y, M) {
      const tb = document.getElementById('caltableid');
      var cnt = 0;
      const day = new Date().getDate();
      const year = new Date().getFullYear();
      const month = new Date().getMonth();

      const start = dayOfWeek(Y, M, 1) + 1; 
      const ymonth = (isLeapYear(Y) && M==2) ? dmonth[M - 1] + 1:dmonth[M - 1];

      for (var j=0;j<6;j++) {
         const tr = document.createElement('tr');
         for (var i=1;i<=7;i++) {
            const td = document.createElement('td');
            const c = j * 7 + i;
            if (c >= start && cnt < ymonth) {
               cnt ++;
               td.innerHTML = cnt;
               td.onclick = chooseDate;
               td.date_ = { y: Y, m: M, d: cnt };
            } else {
               td.innerHTML = '';
               td.onclick = function() {};
            }
            td.style="font-size: 9pt; text-align: right; margin: 0px 0px 0px 0px; padding: 2px 2px 2px 2px; cursor: pointer;";
            if (day == cnt  && year == Y && month == M - 1) {
              td.style.backgroundColor = "#afafaf";
            } else {
              td.style.backgroundColor = "";
            }
            td.style.color = ((i==1) ? '#800000' : '#0000FF');
            td.onmousedown = function() { this.style.fontWeight = 'bold'; };
            td.onmouseup   = function() { this.style.fontWeight = 'normal'; };
            tr.appendChild(td);
         }
         tb.appendChild(tr);
      }
    }

    function calendar(Y=2023, M=01) {

      const tb = document.createElement('table');
      tb.id = 'caltableid';
      caldiv.style = 'background-color: #dedede; white-space: nowrap; border: 1px solid #808080; ' +
		  'font-size: 10pt; font-weight: normal; font-family: helvetica; padding: 5px 5px 5px 5px';

      const fm = document.createElement('span'); fm.innerHTML = '&#x2190'; 
		fm.style='position: absolute; left: 5px; white-space: normal; font-size: 10pt;  padding: 2px 0px 2px 0px; cursor: pointer';
                fm.date_ = { y: Y, m: M, d: -1 };
                fm.onclick = switchDate;
                fm.id = 'calfmid';
      const bm = document.createElement('span'); bm.innerHTML = '&#x2192'; 
                bm.style='position: absolute; right: 5px; white-space:normal; font-size: 10pt; padding: 2px 0px 2px 0px; cursor: pointer';
                bm.date_ = { y: Y, m: M, d: 1 };
                bm.onclick = switchDate;
                bm.id = 'calbmid';
      const smonth = document.createElement('span');
      smonth.style='text-align: center; width: 100%; display: inline-block; background-color: #4BB7DF; white-space: normal;' +
		 'font-size: 11pt; font-weight: normal; font-family; helvetica; color: #ffffff; padding: 2px 0px 2px 0px';
      smonth.innerHTML = nmonth[M-1] + ',' + Y;
      smonth.id = 'calmonthid';
      caldiv.appendChild(fm);
      caldiv.appendChild(smonth);
      caldiv.appendChild(bm);

      const func = function() { caldiv.style.visibility = 'hidden'; return true  }
      caldiv.addEventListener('mouseleave', func, false);

      const tr = document.createElement('tr');
      for (var i=0; i<7;i++) {
          const td = document.createElement('td');
          td.innerHTML = week[i];
          td.style="font-size: 9pt; text-align: right; margin: 0px 0px 0px 0px; padding: 2px 2px 2px 2px";
          td.style.color = ((i==0) ? '#800000' : '#000000');
          tr.appendChild(td);
      } 
      tb.append(tr);

      caldiv.appendChild(tb);

      populateCalendar(Y, M); 
     
    }    

    const mn = new Date().getMonth(), yr = new Date().getFullYear();
    calendar(yr, mn + 1);

    // load calendar
    function loadCalendar(itemid, spanitem) {
      var top = parseInt(itemid.parentNode.style.top) + 20;
      var left = parseInt(itemid.parentNode.style.left) + 5;
      caldiv.style.top = top + 'px';
      caldiv.style.left = left + 'px';
      caldiv.spanid_ = spanitem;
      caldiv.itemid_ = itemid;

      const func = function chosenTitle() {
            var value = this.lastChild.innerHTML;
            this.myspan_.innerHTML = (value.length > 35) ? value.slice(0,35) + ' ...' : value;
            this.myitem_.value_ = parseInt(this.p_) + 1;
            this.mydiv_.style.visibility = 'hidden';

      }

      const func1 = function() { this.style.visibility = 'hidden'; }
      const func2 = function() { closeOptions(); this.mydiv_.style.visibility = 'visible'; }
      const func3 = function() { this.mydiv_.style.visibility = 'hidden'; }

      itemid.onclick = function() {
                caldiv.style.visibility = 'visible';
          }
      itemid.onclick = func2;     itemid.mydiv_ = caldiv;
      spanitem.onclick = func2;  spanitem.mydiv_ = caldiv;
      itemid.onmouseup = function() { spanitem.style.color = '#14815C'; }
      itemid.onmousedown = function() { spanitem.style.color = '#808080'; }
      spanitem.onmouseup = function() { spanitem.style.color = '#14815C'; }
      spanitem.onmousedown = function() { spanitem.style.color = '#808080'; }
    }

    loadCalendar(tourneydateoptionid, tourneydateoptionspanid);

    // load title
    var options_ = [ caldiv ];
    function closeOptions() {
       for (var p in options_) {
          const option = options_[p];
          option.style.visibility = 'hidden';
       }
    }
    function loadOption(divitem, itemid, ulid, spanitem, width, height, items) {

      const func = function chosenTitle() {
            var value = this.lastChild.innerHTML; /* li node */
            this.myspan_.innerHTML = (value.length > 35) ? value.slice(0,35) + ' ...' : value;
            this.myitem_.value_ = parseInt(this.p_) + 1;
            this.mydiv_.style.visibility = 'hidden';
            
      }

      const func1 = function() { this.style.visibility = 'hidden'; return true }
      const func2 = function() { 
                        closeOptions();
                        this.mydiv_.style.visibility = 'visible'; 
                    }
      const func3 = function() { this.mydiv_.style.visibility = 'hidden'; }

      options_.push(divitem);
      
      for (var p in items) {
        const item = items[p];
        const li = document.createElement('li');
        const sp1 = document.createElement('i');
        const sp2 = document.createElement('span');
        sp1.innerHTML = item.code;
        sp2.innerHTML = item.item;
        li.appendChild(sp1); li.appendChild(sp2);
        sp1.style = "padding: 0px 5px 0px 5px; font-size: 14pt";
        sp2.style = "padding: 0px 5px 0px 5px; font-size: 9pt; font-weight: normal; font-family: helvetica";
        li.style = "left: 0px; color: #14815c"; // font-size: 9pt; font-weight: normal; font-family: helvetica";
        li.style.backgroundColor = (parseInt(p) % 2)  ? '#e8e8e8' : '#fafafa';
        li.p_ = p;
        li.onmouseover = function() { this.style.backgroundColor = '#B8C2CD'; }
        li.onmouseout = function() { this.style.backgroundColor = (parseInt(this.p_) % 2)  ? '#e8e8e8' : '#fafafa'; }
        li.onmouseup = function() { this.style.color = '#14815c'; }
        li.onmousedown = function() { this.style.color = '#414141'; }
        li.onclick = func;
        li.mydiv_ = divitem;
        li.myspan_ = spanitem;
        li.myitem_ = itemid;
        ulid.appendChild(li);
      }
      ulid.className = "uloption";
      divitem.className = "divoption";
      divitem.style.visibility = 'hidden';
      divitem.style.width = width + 'px';
      divitem.style.height = height + 'px';
      divitem.firstChild.style.width = (width - 10) + 'px';
      divitem.firstChild.style.height = (height - 10) + 'px';
      divitem.addEventListener('mouseleave', func1, false);
      itemid.onclick = func2;     itemid.mydiv_ = divitem;
      spanitem.onclick = func2;  spanitem.mydiv_ = divitem;
      itemid.onmouseup = function() { spanitem.style.color = '#14815C'; }
      itemid.onmousedown = function() { spanitem.style.color = '#808080'; }
      spanitem.onmouseup = function() { spanitem.style.color = '#14815C'; }
      spanitem.onmousedown = function() { spanitem.style.color = '#808080'; }
    }
 
    loadOption(flagsdivid, flagsoptionid, flagsid, flagsoptionspanid, 300, 210, flags);

    loadOption(titledivid, titleoptionid, titleid, titleoptionspanid, 250, 110, titles);

    loadOption(tourneytypedivid, tourneytypeoptionid, tourneytypeid, tourneytypeoptionspanid, 200, 145, tourneytypes);

    loadOption(tourneyvariantdivid, tourneyvariantoptionid, tourneyvariantid, tourneyvariantoptionspanid, 200, 155, tourneyvariants);

    loadOption(tourneyrecdivid, tourneyrecoptionid, tourneyrecid, tourneyrecoptionspanid, 200, 100, tourneyrecs);

    loadOption(tourneytimerdivid, tourneytimeroptionid, tourneytimerid, tourneytimeroptionspanid, 75, 200, tourneytimer);

    loadOption(tourneyincdivid, tourneyincoptionid, tourneyincid, tourneyincoptionspanid, 75, 200, tourneyinc);

    loadOption(tourneyhrdivid, tourneyhroptionid, tourneyhrid, tourneyhroptionspanid, 55, 100, tourneyhr);

    loadOption(tourneymindivid, tourneyminoptionid, tourneyminid, tourneyminoptionspanid, 55, 100, tourneymin);

    loadOption(tourneyforfeitdivid, tourneyforfeitoptionid, tourneyforfeitid, tourneyforfeitoptionspanid, 75, 145, tourneyforfeit);

    loadOption(chessvariantdivid, chessselectvariantid, chessvariantid, chessspanvariantid, 150, 210, variants);
    loadOption(chesspiecedivid, chessselectpieceid, chesspieceid, chessspanpieceid, 150, 80, pieces);
    loadOption(chessplayerdivid, chessselectplayerid, chessplayerid, chessspanplayerid, 150, 60, players);

    loadOption(chesscompvariantdivid, chesscompselectvariantid, chesscompvariantid, chesscompspanvariantid, 150, 100, compvariants);
    loadOption(chesscomppiecedivid, chesscompselectpieceid, chesscomppieceid, chesscompspanpieceid, 150, 80, pieces);

    function validateFile() {
       var value = this.value;
       var file = this.files[0];
       var size = file.size / 1024; /* kbytes */
       var ext_expr  = /(\.svg|\.png|\.gif|\.jpg|\.jpeg)$/i;
       var mimetype_expr = /^image\/(svg|svg\+xml|png|gif||jpg|jpeg)$/i;
       if (value.match(ext_expr) && file.type.match(mimetype_expr)) {
         if (size < 264) { /* less than 264kb */
            log(size); 
         }
       }
    }

    function mouseDownChessDiv(e) {
         const items = [ profileid, tourneyid, geartoolsid,
                         flagsdivid, titledivid, tourneytypedivid, tourneyvariantdivid, tourneytimerdivid, tourneyincdivid,
			 tourneyrecdivid, tourneyhrdivid, tourneymindivid, tourneyforfeitdivid, caldiv ];
         for (var p in items) {
             const item = items[p];
             if (item.leftroad_) { 
                   item.style.visibility = 'hidden'; item.leftroad_ = false; 
             }
         }
         if (e.target.id == 'chessdiv' || e.target.id == 'settingid') {
             closeOptions();
         }
log("down ...");
         return true;
    }

    function mouseDoubleChessDiv(e) {
       e.preventDefault();
       if (e.target != null && e.target.className == 'cellcontainer') {
            const contr = e.target.closest(".chesscontainer");
            if (contr != null) {
              const this_ = contr.game_;
              this_.maxSize(e, this_) ;
            }
       } 
       return true;
    }

    function initial_settings() {

         chessdiv.onmousedown = mouseDownChessDiv;
         chessdiv.ondblclick = mouseDoubleChessDiv;

         signinid.onmousedown = function() { this.style.color = '#ffffff' }
         signinid.onmouseup = function() { this.style.color = '#81d765' }

         registerid.onmousedown = function() { this.style.color = '#ffffff' }
         registerid.onmouseup = function() { this.style.color = '#a1f785' }

         const regid = document.getElementById('registerspanid');
         regid.onmousedown = function() { this.style.color = '#2A2A2A' }
         regid.onmouseup = function() { this.style.color = '#0000FF' }

         const reset = document.getElementById('resetpwdid');
         reset.onmousedown = function() { this.style.color = '#2A2A2A' }
         reset.onmouseup = function() { this.style.color = '#0000FF' }

         pr_file.onchange = validateFile;

         profileupdateid.onclick = function() {
             profileid.style.visibility = 'visible';
             tourneyid.style.visibility = 'hidden';
             profileid.leftroad_ = false;
             notice("Profile Update.");
         }

         profilecloseid.onclick = function() {
             profileid.style.visibility = 'hidden';
             tourneyid.style.visibility = 'hidden';
             profileid.leftroad_ = false;
         }

         tourneyupdateid.onclick = function() {
             tourneyid.style.visibility = 'visible';
             profileid.style.visibility = 'hidden';
             tourneyid.leftroad_ = false;
             notice("Tournament  Registration");
         }

         tourneycloseid.onclick = function() {
             profileid.style.visibility = 'hidden';
             tourneyid.style.visibility = 'hidden';
             tourneyid.leftroad_ = false;
         }

         addLeaveEvent(profileid, [flagsdivid,titledivid]); // add children
         addLeaveEvent(tourneyid, [tourneytypedivid, tourneyvariantdivid, tourneytimerdivid, tourneyincdivid,
                                   tourneyrecdivid, tourneyhrdivid, tourneymindivid, tourneyforfeitdivid, caldiv]);
         
         profilesaveid.onclick = function() { // saveProfile
             const pr_username  = document.getElementById('pr_username').value;
             const pr_firstname = document.getElementById('pr_firstname').value;
             const pr_lastname  = document.getElementById('pr_lastname').value;
             const pr_email     = document.getElementById('pr_email').value;
             const pr_phone     = document.getElementById('pr_phone').value;
             const pr_desc      = document.getElementById('pr_desc').value;
             const pr_flags     = flagsoptionid.value_; 
             const pr_title     = titleoptionid.value_; 
             const pr_rating    = document.getElementById('pr_rating').value; 

             const profile = { sessionid: SESSION_.sessionid, username: SESSION_.username, firstname: pr_firstname, lastname: pr_lastname,
                            email: pr_email, phone: pr_phone, description: pr_desc, country: pr_flags,
                            title: pr_title, rating: pr_rating }

             profileid.style.visibility = 'hidden';

             socket.emit("updateprofile", profile);
             
         } 

         /* Tournament Defaults */
         tourneytypeoptionid.value_ = 3;
         tourneyvariantoptionid.value_ = 0;
         tourneytimeroptionid.value_ = 6;
         tourneyincoptionid.value_ =  1;
         tourneyforfeitoptionid.value_ = 8;
         tourneyrecoptionid.value_ = 1;

         tourneysaveid.onclick = function() { // saveTournament
           var today = UTCtoday();
           try {
                const pr_tourney = document.getElementById('pr_tourney').value;
                if (pr_tourney == '') throw { code: 1 };
                const pr_type    = tourneytypeoptionid.value_;
                const pr_dur     = document.getElementById('pr_tourney_dur').value;
                const pr_pl      = document.getElementById('pr_tourney_pl').value;
                var   pr_variant = tourneyvariantoptionid.value_;
                const pr_timer   = tourneytimer[ tourneytimeroptionid.value_ - 1].initial; 
                const pr_inc     = tourneyinc[ tourneyincoptionid.value_ - 1].initial;
                const pr_rated   = document.getElementById('pr_tourney_rated').checked;
                const pr_titled  = document.getElementById('pr_tourney_titled').checked;
                var   pr_date    = tourneydateoptionid.value_;
                const pr_timehr  = tourneyhr[ tourneytimehroptionid.value_ - 1].initial;
                const pr_timemin = tourneymin[ tourneytimeminoptionid.value_ - 1].initial;
                const pr_forfeit = tourneyforfeit[ tourneyforfeitoptionid.value_  - 1].initial;
                const pr_rec     = tourneyrecoptionid.value_;
                const pr_desc    = document.getElementById('pr_tourney_desc').value;

                if (pr_tourney.length < 10) throw { code: 2 };

                if (isNaN(pr_dur) || pr_dur == '') throw { code: 3 };
                if (parseInt(pr_dur) < 10 || parseInt(pr_dur) > 360 ) throw { code: 4 };

                if (isNaN(pr_pl) || pr_pl == '') throw { code: 5 };
                if (parseInt(pr_pl) < 4 || parseInt(pr_pl) > 100 ) throw { code: 6 };

                if (tourneyvariantoptionid.value_ == null) throw { code: 13 };

log(pr_forfeit);
log(pr_timer * 60 * 0.50);
                if (pr_forfeit > pr_timer * 60 * 0.50) throw { code: 15 };

                if (pr_desc == '') throw { code: 11 };
                if (pr_desc.length < 20) throw { code: 12 };

                
                const UTCdate = function(dt, hr, min) { return (new Date(new Date(dt.y, dt.m - 1, dt.d, hr, min).toUTCString().replace(/ GMT/,'')) / 1); };
                const minimum_5min = 5 * 60 * 1000; /* 5 minutes minimum start time */
                pr_date = UTCdate(pr_date, pr_timehr, pr_timemin);

                // if start date is less than 5 minutes from today, throw error
                if (pr_date - today <= minimum_5min ) throw { code: 14 };

                const tourney = { sessionid: SESSION_.sessionid, username: SESSION_.username, 
                     name: pr_tourney,  type: pr_type, duration: pr_dur, players: pr_pl, variant: pr_variant, 
                     timer: pr_timer, increment: pr_inc, rated: pr_rated, titled: pr_titled,
                     start_date: pr_date, start_hr: pr_timehr, start_min: pr_timemin, forfeit_policy: pr_forfeit, recurrence: pr_rec,
                     description: pr_desc, status: 0, simul: false }

                tourneyid.style.visibility = 'hidden';
                geartoolsid.style.visibility = 'hidden';
                socket.emit("savetournament", tourney);
            } catch(err) {
                const code = (err.code != null) ? err.code : 0;
                if (code == 1) { notice("Please enter Tournament Name ..."); return };
                if (code == 2) { notice("Length of Tournament Name too short ..."); return };
                if (code == 3) { notice("Duration value between 10 and 360 ..."); return };
                if (code == 4) { notice("Duration value between 10 and 360 ..."); return };
                if (code == 5) { notice("Number of Players  between 4 and 100 ..."); return };
                if (code == 6) { notice("Number of Players between 4 and 100 ..."); return };
                if (code == 11) { notice("Add Description ..."); return };
                if (code == 12) { notice("Description is too short ..."); return };
                if (code == 13) { notice("Please Choose Tournament Variant ..."); return };
                if (code == 14) { notice("Please Choose future date for start date ..."); return };
                if (code == 15) { notice("Forfeit policy should be less than half the Timer time ..."); return };
                if (tourneytypeoptionid.value_ == null) { notice("Please Choose Tournament Type ..."); return };
                if (tourneytimeroptionid.value_ == null) { notice("Please Choose a Timer ..."); return };
                if (tourneyincoptionid.value_ == null) { notice("Please Choose an Increment ..."); return };
                if (tourneydateoptionid.value_ == null) { notice("Please Choose Start Date ..."); return };
                if (tourneytimehroptionid.value_ == null) { notice("Please Choose Start Hour ..."); return };
                if (tourneytimeminoptionid.value_ == null) { notice("Please Choose Start Min ..."); return };
                if (tourneyforfeitoptionid.value_ == null) { notice("Please Choose Forfeit Policy ..."); return };
                log(err);
            }
         }

         pr_free_layout.onchange = function() {
            CONFIG_.layout.free = this.checked;
            if (CONFIG_.layout.free) {
              while (layoutid.lastChild) layoutid.removeChild(layoutid.lastChild);
            } else {
              adjustLayout(true);      // create first
              adjustLayout(false); // now re-run  to re-layout
            }

         }


         pr_columns.onchange = function() {
            if (!CONFIG_.layout.free)  {
              const col  = CONFIG_.layout.coor.col;
              const row  = CONFIG_.layout.coor.row;
              const blen = BOARDS_.length;
              const pcol  = pr_columns.value;
              if (pcol * row == 0 || pcol * row > 12 || pcol == 0 || pcol * row < blen) {
                  pr_columns.value = CONFIG_.layout.coor.col;
                  pr_rows.value = CONFIG_.layout.coor.row;
                  return;
              }
              CONFIG_.layout.coor.col = pcol;
              adjustLayout(false);
            }
         }

         pr_rows.onchange = function() {
            if (!CONFIG_.layout.free)  {
              const col  = CONFIG_.layout.coor.col;
              const row  = CONFIG_.layout.coor.row;
              const blen = BOARDS_.length;
              const prow = pr_rows.value;
              if (col * prow == 0 || col * prow > 12 || prow == 0 || col * prow < blen) {
                  pr_columns.value = CONFIG_.layout.coor.col;
                  pr_rows.value = CONFIG_.layout.coor.row;
                  return;
              }
              CONFIG_.layout.coor.row = prow;
              adjustLayout(false);
            }
         }

        adjustLayout();

        const playid = document.getElementById('mplayid');
        const watchid = document.getElementById('mwatchid');
        const learnid = document.getElementById('mlearnid');
        const puzzleid = document.getElementById('mpuzzleid');
        const connectid = document.getElementById('mconnectid');

        closeApps();

        const topbtn = [ playid, watchid, learnid, puzzleid, connectid ];
        const topexec = [ playGame, watchGame, learnGame, puzzleGame, connectToMembers ];
        for (var p in topbtn) {
           const button = topbtn[p];
           button.onclick = topexec[p];
           mouseEvent(button, '#afafaf');
        }
          
    }

    initial_settings();

    function closeApps() {
        const windows = [schedtourneyid, watchgamesid, evaluateid, forumsid ];
        for (var p in windows) {
          const window = windows[p];
          window.style.visibility = 'hidden';
        }
        closeGameSettings();
    }

    function closeGames() {
          var div = document.getElementById('showtourid');
          if (div != null) div.remove();
    }

    function playType() {
       const icons = [ '&#x23F3;', '&#x1F41F;', '-', '&#x26FA;', '&#x1F30B;', '&#x2713;', '&#x1F388;', '&#x1F980;' ];
       const funcs = [ null, null, null, null, null, null, null, null ];
       const titles = [ 'Standard', 'Chess960', '', 'Crazy House', 'King of the Hill', 'Three Checks', 'Atomic', 'Horde' ];
       const div = useMenu(icons, funcs, titles);
       div.id = 'variantid';
       div.style = 'top: 35px; left: 200px; width: 130px; height: 220px; visibility: hidden; z-index: 55005';
       chessdiv.appendChild(div);
    }

    playType();

    function playGame(e) {
log("play game  ...");
      if(!e.detail || e.detail == 1) {
        e.preventDefault();
        closeApps();
        notice("Play Game.");
        showGameSettings(null, simul = true);
      }
      return true;
    }

    function nextRound(e) {
log("next round ...");
      return true;
    }

    function watchSimul(e) {
log("watch game ...");
       closeApps();
       blanket.style.visibility = 'visible';
       const req = new XMLHttpRequest();
       req.onreadystatechange = function() {
         if (this.readyState == 4 && this.status == 200) {
            var response = JSON.parse(req.responseText);
            var simuls = response.simul;
            var list = [];
            for (var p in simuls) {
               const simul = simuls[p];
               const min = possible_timer[simul.settings.gamemin];
               const inc = possible_inc[simul.settings.gameinc];
               var variant = recvariants[simul.settings.variant - 1];
               variant = variant.replace(/\_/g,'');
            
               var today = daylocal(simul.start_date);
               const game = { name: 'Simul ' + variant + ' Game', duration: 30, joined: simul.joined, total: simul.total, complete: simul.complete,
			variant: simul.settings.variant, simul: true, rated: simul.settings.israted, titled: simul.settings.istitled, gameover: simul.gameover,
			start_date: today, timer: min, inc: inc, type: playType(min), hosted: simul.host, gametoken: simul.gametoken, started: simul.started }
               list.push(game);
            }
            log(list);
            listTournaments(schedpanel3a, list);
            blanket.style.visibility = 'visible';
            schedtourneyid.style.visibility = 'visible';  
         }
       };

       req.open('POST', 'http://localhost:3000/simul', true);
       req.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
       const data = JSON.stringify({ sessionid: SESSION_.sessionid, username: SESSION_.username });
       req.send(data);

       return true;
    }

    function watchTourney(e) {
log("watch game ...");
       closeApps();
       blanket.style.visibility = 'visible';
       const req = new XMLHttpRequest();
       req.onreadystatechange = function() {
         if (this.readyState == 4 && this.status == 200) {
            var resp = JSON.parse(req.responseText);
            if (resp.code == 0) {
                const tourneys = resp.tourneys;
                var list = [];
                for (var p in tourneys) {
                    var tourney = tourneys[p];
                    const min = possible_timer[tourney.timer];
                    const inc = possible_inc[tourney.increment];
                    const rtype = tourneytypes[tourney.tournament_type].item;
                    var today = LOCALdate(tourney.start_date); 
                    var enddate = (tourney.end_date != null) ? LOCALdate(tourney.end_date) : null; 
                    const game = { name: tourney.tournament_name, tournament_type: rtype,  hosted: tourney.hosted,
                                   rated: tourney.rated, titled: tourney.titled, simul: false, gameover: tourney.gameover,
                                   duration: tourney.duration, joined: tourney.joinedplayers, total: tourney.number_players, complete: false,
				   variant: tourney.variant + 1, start_date: today, end_date: enddate, endsin: 0, timer: tourney.timer, inc: tourney.increment, 
                                   type: tourney.type,  gametoken: tourney.tournament_id, player_status: tourney.player_status }
                    list.push(game);
                    
                }
                listTournaments(schedpanel2a, list);
                blanket.style.visibility = 'visible';
                schedtourneyid.style.visibility = 'visible';  
            }
         }
       };

       req.open('POST', 'http://localhost:3000/tourneys', true);
       req.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
       const data = JSON.stringify({ sessionid: SESSION_.sessionid, username: SESSION_.username });
       req.send(data);

       return true;
    }

    function watchGame(e) {
       notice("Watch Game.");
       watchSimul(e);
       watchTourney(e);
    }

    function learnGame() {
log("learn game ...");
      closeApps();
      evaluateid.style.visibility = 'visible';  
      return true;
    }

    function puzzleGame() {
log("puzzle game ...");
      closeApps();
      forumsid.style.visibility = 'visible';  
      return true;
    }

    function connectToMembers() {
log("connect / forums ...");
      closeApps();
      forumsid.style.visibility = 'visible';  
      return true;
    }

    function showRating(rating, variant, timer_type) {
      for (var p in rating) {
         var rate = rating[p];
         if (rate.variant == variant && rate.timer_type == timer_type) { 
            if (CONFIG_.ratesystem == 'rmoo') {
              return rate.rmoo;
            } else
            if (CONFIG_.ratesystem == 'elo') {
              return rate.elo;
            } else
            if (CONFIG_.ratesystem == 'glicko2' || CONFIG_.ratesystem == 'glicko') {
              return rate.glicko;
            }
         }
      }
      return null;
    }

    function showPlayer(e) {
    }

     function evaluateScore1() {
        var ponder_ = (typeof(PONDER_) == "undefined") ? "" : " " + PONDER_;
        var move_ = ENGINEMOVE_ + ponder_;
log("best of moves ...");
log(move_);
        var analyze = 50, score = 0, found = 0, load_ = null;
        if (ANALYZE_.length)
        for (var p in ANALYZE_) {
          const l_ = ANALYZE_[p];
          found = l_.moves.lastIndexOf(move_);
          if (found == 0) {
            if (l_.srate > score ) {
              load_ = l_;
              score = load_.wscore // load_.srate
            }
          }
        }
        return score == 0 ? 0.50 : score;
     }

     function scaleScore(min, max, val) {
         return (val - min) / (max - min); //  * 100
     }

     function swingEval(game, step, side, swing_, move_) {
        var SCORES_ = game.enginescore_.SCORES_;
        var analysis = '';
        var min = -1, max = 1;  tmin = 1, tmax = 6;
        var best = null, great = null, good = null;
        var score = (swing_ - min) / (max - min) * tmax + tmin; /* scale down */
        if (step > 0) {
          best  = SCORES_[step - 1].a.moves.split(' ')[0] == move_;
          great = SCORES_[step - 1].b.moves.split(' ')[0] == move_;
          good  = SCORES_[step - 1].c.moves.split(' ')[0] == move_;
        }
        if (good == null && great == null && best == null && score >= 5.5)  analysis = 'Brilliant'; else
        if ((best != null && best) || score >= 5.0 && score < 5.5 )  analysis = 'Best';  else
        if ((great != null && great) || score >= 4.0 && score < 5.0 )  analysis = 'Great';  else
        if ((good != null && good) || score >= 3.7 && score < 4.0 )  analysis = 'Good'; else
        if (score >= 3.5 && score < 3.7 )  analysis = 'Inaccurate'; else
        if (score >= 2.5 && score < 3.5 )  analysis = 'Mistake'; else
        if (score < 2.5 )  analysis = 'Blunder'; 

        var tcol_ = document.getElementById(game.id + '_' + side + "dot" + step);
        if (side == 'w') {
            var td_ = game.enginescore_.wanalysis_[analysis];
            if (td_ != null) td_.innerHTML = parseInt(td_.innerHTML) + 1;  
            var td_ = game.enginescore_.wanalysis_['Accuracy'];
            if (td_ != null) 
            if (analysis == 'Brilliant' || analysis == 'Best' || analysis == 'Great' || analysis == 'Good') { 
                game.enginescore_.white_accuracy++;
                td_.innerHTML = Number((game.enginescore_.white_accuracy / game.enginescore_.total_moves * 100)).toFixed(1) + ' %';
            }
        } else
        if (side == 'b') {
            var td_ = game.enginescore_.banalysis_[analysis];
            if (td_ != null) td_.innerHTML = parseInt(td_.innerHTML) + 1;
            var td_ = game.enginescore_.banalysis_['Accuracy'];
            if (td_ != null) 
            if (analysis == 'Brilliant' || analysis == 'Best' || analysis == 'Great' || analysis == 'Good') { 
                game.enginescore_.black_accuracy++;
                td_.innerHTML = Number((game.enginescore_.black_accuracy / game.enginescore_.total_moves * 100)).toFixed(1) + ' %';
            }
        }


        if (analysis == 'Blunder') {
            tcol_.style.color = '#E14F32';
        } else 
        if (analysis == 'Mistake') {
            tcol_.style.color = '#E76E0D';
        } else
        if (analysis == 'Inaccurate') {
            tcol_.style.color = '#E1A132';
        } else
        if (analysis == 'Great') {
           tcol_.style.color = '#93D068'; 
        } else
        if (analysis == 'Best') {
           tcol_.style.color = '#3AB313';
        } else
        if (analysis == 'Brilliant') {
           tcol_.style.color = '#42ABF0';
        }
        return analysis;
     }

     var before_win = 0, after_win = 0, accuracy = 0, win_ = 50;
     var wcpq = 0, bcpq = 0, xcp = 0;

     function captureBestScores(side) {
        var BESTSCORES_ = { a: null, b: null, c: null };
        if (ANALYZE_.length)
        for (var p in ANALYZE_) {
            const l_ = ANALYZE_[p];
            var outcome = {};
            outcome.cp = l_.cp / 100;
            outcome.mt = l_.mt;
            outcome.score = l_.score;
            outcome.wprob = l_.wprob;
            outcome.lprob = l_.lprob;
            outcome.moves = l_.moves;
            if (side == 'w') { // convert evaluation where positive is advantage for white.
                  var tmp = outcome.lprob;
                  outcome.cp = -outcome.cp;
                  outcome.score = -outcome.score;
                  if (outcome.mt != null) outcome.mt = -outcome.mt;
                  outcome.lprob = outcome.wprob;
                  outcome.wprob = tmp;
            }
            if (p == 0) BESTSCORES_.a = outcome;
            if (p == 1) BESTSCORES_.b = outcome;
            if (p == 2) BESTSCORES_.c = outcome;
        }
        return BESTSCORES_;
     }

     function evaluateScore(game, move_, side, step) {
        var SCORES_ = game.enginescore_.SCORES_;
        var ponder_ = (typeof(PONDER_) == "undefined") ? "" : " " + PONDER_;
        var enginemove_ = ENGINEMOVE_; // + ponder_;
        var swing = 0;
        var outcome = {};
        var analysis = 'Good', out_ = [], outcome_ = ( step == 0 ) ? null : SCORES_[ step  - 1  ].a;

        SCORES_[step] = captureBestScores(side);
        outcome = SCORES_[step].a;
        if (outcome_ != null) {
             if (side == 'w') {
                if (outcome.mt != null) {
                  swing = outcome.mt; 
                } else {
                  swing = (outcome.score - outcome_.score);
                }
             } else 
             if (side == 'b') {
                if (outcome.mt != null) {
                   swing = -outcome.mt;
                } else {
                   swing = -(outcome.score - outcome_.score);
                }
             }
        }

        SCORES_[step].a.swing = swing;
        SCORES_[step].a.analysis = analysis = swingEval(game,  step, side, swing, move_);

        var score = SCORES_[step].a.cp;
        var td_ = document.getElementById(game.id + '_' + side + "score" + step);
        if (SCORES_[step].a.mt != null) {
            var mt = parseInt(SCORES_[step].a.mt);
            score = (mt > 0) ? 'M' + mt : '-M' + Math.abs(mt);
        } else {
            score = (score >= 0) ? '+' + score.toFixed(2) : score.toFixed(2);
        }
        td_.innerHTML = score;

        if (analysis == 'Brilliant' || analysis == 'Mistake' || analysis == 'Blunder') {
            td_.style.color = '#dadada';
        }
     }

     function displayScore(bestmoves, score) {
         var cp = bestmoves.cp;
         var cp_ = (cp >= 0) ? '+' + cp : cp + '';
         var mt = bestmoves.mt, mt_ = null;
         cp_ = (cp.toString().match(/\./) == null ) ? cp_ + '.' : cp_;
         cp_ =  cp_.padEnd(5,'0');
         if (mt != null)  mt_ = (mt > 0) ? 'M' + mt : '-M' + Math.abs(mt);
         score.firstChild.innerHTML = (mt != null) ? mt_ : cp_;
         score.nextSibling.firstChild.innerHTML = bestmoves.moves;
     }

     async function evaluateMoveScore(game, fen, side) {
       if (acquiremovedepth > 40) {
          clearInterval(analysistimer);
          analysistimer = null;
          acquiremovedepth = 20;
log("completed ...");
          ENGINE_NEXT_RESPONSE_ = null;
          ENGINE_STATE_REQ_ = true;
          ENGINEMOVE_ = null;
          POSTED_MOVE_ = false;
       }
       if (!POSTED_MOVE_) {
          ANALYZE_ = [];
          POSTED_MOVE_ = true;
          post("ucinewgame");
          post("position fen " + fen, game.id);
          await post("go movetime 1000 depth " + acquiremovedepth);
          acquiremovedepth += 5;
       } else
       if (ENGINE_NEXT_RESPONSE_ == true && ENGINEMOVE_ != null) {
           var scores = game.chmoves_.getElementsByClassName("bestscoretd");
           ENGINE_NEXT_RESPONSE_ = null;
           ENGINE_STATE_REQ_ = true;
           POSTED_MOVE_ = false;
           var SCORES_ = captureBestScores(side);  
           var cnt = 0;
           for (var n in scores) {
              var score = scores[n];
              if (score.nodeType == 1) {
                cnt++;
                score.vAlign = 'top';
                var s = p - 1;
                if (cnt == 1) {
                   displayScore(SCORES_.a, score);
                } else
                if (cnt == 2) {
                   displayScore(SCORES_.b, score);
                } else
                if (cnt == 3) {
                   displayScore(SCORES_.c, score);
                }
              }
           }
           ENGINEMOVE_ = null;
        }
     }

     var analysistimer = null, acquiremovedepth = 20;
     async function acquireMoveScore(game, fen, side) {
        ENGINE_NEXT_RESPONSE_ = null;
        ENGINE_STATE_REQ_ = true;
        ENGINEMOVE_ = null;
        POSTED_MOVE_ = false;
        ANALYZE_ = [];
log("start ...");
        acquiremovedepth = 20;
        analysistimer  = setInterval(evaluateMoveScore, 100, game, fen, side);
     }

     var movetimer = null, step_cnt = 0;
     var POSTED_MOVE_ = false;
     async function acquireEngineScore(game, fens, moves) {
       var len = fens.length - 1; 
       var SCORES_ = game.enginescore_.SCORES_;
       if (step_cnt == len ) {
           clearInterval(movetimer);
           step_cnt = 0;
       } else
       if (!POSTED_MOVE_) {
           var fen = fens[step_cnt + 1].fen;
           var turn = fens[step_cnt + 1].turn;
           var move_ = turn.src + turn.dst;
           var step = Math.floor( step_cnt / 2);
           POSTED_MOVE_ = true;
           ANALYZE_ = [];
           if (step_cnt == 0) post("ucinewgame");
           post("position fen " + fen, game.id);
           await post("go movetime 50 depth 16");
           await game.notice('Analyzing Game ... ' + Math.round(step_cnt / len * 100, 2) + '%' );
           SCORES_[step_cnt] = { a: { moves: move_ } , b: null, c: null };
       } else
       if (ENGINE_NEXT_RESPONSE_ == true && ENGINEMOVE_ != null) {
           var side = fens[step_cnt].side;
           var move_ = SCORES_[step_cnt].a.moves;
           ENGINE_NEXT_RESPONSE_ = null;
           ENGINE_STATE_REQ_ = true;
           POSTED_MOVE_ = false;
           evaluateScore(game, move_, side, step_cnt);
           ENGINEMOVE_ = null;
           step_cnt ++;
       }
     }

     async function checkState(game, fens, moves) {
       step_cnt = 0;
       ENGINE_NEXT_RESPONSE_ = null;
       ENGINE_STATE_REQ_ = true;
       POSTED_MOVE = false;
     
       setEngine();
       await pause(1000); 
       game.notice('Analyzing Game ... 0%');
       game.enginescore_.total_moves = Math.floor(fens.length / 2);
       movetimer  = setInterval(acquireEngineScore, 100, game, fens, moves);
     }


    function parseMoves(this_, moves_) {
         const parsed_ = parser.parse(moves_);
         const pmoves = parsed_[0];
         var moves = moves_.split(' ');

         var RS_ = null;
         if (parsed_[1] != "1-0" && parsed_[1] != "0-1" && parsed_[1] != "1/2-1/2") {
             pmoves.push([parsed_[1],['']]);
         } else {
             RS_ = parsed_[1];
         }

         this_.GAME_STATE.sidetomove_ = WHITE;
         this_.GAME_STATE.movecount_ = 0;
         for (var m in pmoves) {
            const move = pmoves[m][0];
            const wmove = move[2][0];
            const wprom = move[2][1].replace(/[=()]/g,'');
            const wchk = move[2][2];
            const wcmt = move[2][3];
            this_.recordMove(wmove, wprom, wchk, wcmt);
            this_.GAME_STATE.sidetomove_ = (this_.GAME_STATE.sidetomove_ == WHITE) ? BLACK : WHITE;
            if (typeof(move[4]) == "object") {
              const bmove = move[4][0];
              const bprom = move[4][1].replace(/[=()]/g,'');
              const bchk = move[4][2];
              const bcmt = move[4][3];
              this_.recordMove(bmove, bprom, bchk, bcmt);
              this_.GAME_STATE.sidetomove_ = (this_.GAME_STATE.sidetomove_ == WHITE) ? BLACK : WHITE;
            } else {
               RS_ = (RS_ != null) ? RS_ : move[4];
               break;
            }
            this_.GAME_STATE.movecount_ ++;
         }
         this_.recordScore(RS_);
         this_.GAME_STATE.sidetomove_ = WHITE;
         this_.GAME_STATE.movecount_ = 0;
    }

     function beautifyMove(move) {
           return move.replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                       replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                       replace(/R/g,'&#9814;').replace(/P/g,'&#9817;');
     }

/*
     function enableGameControl(this_) {
        var chessctl = this_.chesscontrol_; // movecontrol_;
        const notes = chessctl.getElementsByClassName("chessgame")[0];
        this.Notes_ = notes;

        const movebtns = chessctl.getElementsByClassName("chessplaybtn");
        for (var p in movebtns) {
           const btn = movebtns[p];
           if (btn.nodeType == 1) btn.game_ = this_;
        }
    }
*/

    function showGame(game) {
           var e = { preventDefault: function() {} };
           var variant  = variants[game.variant].item;
           var gametype = gameType(game.timer);
           var fen = (game.fen != '') ? game.fen : wINITFEN_;

log("variant in show game ...");
log(variant);
           
           clearBoards();
           closeApps();
           closeGames();

           const board = newBoard(e, hide = true, width = 480, height = 480, variant, fen);
           board.maxSize(e, board);

           board.hdr_player_.innerHTML = game.busername;
           board.ftr_player_.innerHTML = game.wusername;
           if (game.btitle != null) board.hdr_title_.innerHTML = titles[game.btitle - 1].initial;
           if (game.wtitle != null) board.ftr_title_.innerHTML = titles[game.wtitle - 1].initial;

           var wrating = showRating(game.wrating, game.variant, game.game_type);
           var brating = showRating(game.brating, game.variant, game.game_type);
           if (brating != null) board.hdr_elo_.innerHTML = "(" + brating + ")";
           if (wrating != null) board.ftr_elo_.innerHTML = "(" + wrating + ")";

           // parse Moves
           var moves = game.moves.replace(/[0-9]+\./g,'').split(' ');
           parseMoves(board, game.moves);
           var trow = null, tcol = null, lastmove = 0, cnt = 0, move_ = null;
           var chessmoves = document.getElementById(board.id + '_chessmoves');
           var chessmovesid = chessmoves.getElementsByClassName('chessmovesid')[0];
           if (chessmovesid != null) {
              for (var p in board.Moves_) {
                var step = board.Moves_[p];
                lastmove = 1;
                if (p % 2 == 0 && step.side == 'lt') {
                   cnt ++;
                   trow = document.createElement('tr'); 
                   trow.id = board.id + "_chessmoves_" + cnt;
                   tcol = document.createElement('td'); 
                   tcol.innerHTML = cnt; 
                   tcol.className = 'chmovetdstep';
                   trow.appendChild(tcol);
                   trow.vAlign = "top";
                   if (cnt % 2) trow.style.backgroundColor = "#24262A";

                   tcol = document.createElement('td'); tcol.style.color = '#84868A';
                   tcol.id = board.id + "_wscore" + p;
                   tcol.innerHTML = '+0.00';
                   trow.appendChild(tcol);  /* score */
                   tcol = document.createElement('td');  tcol.style.color = '#84868A';
                   tcol.id = board.id + "_wdot" + p;
                   tcol.innerHTML = ' &#9679;';
                   trow.appendChild(tcol);  /* analysis */
                }

                move_ = step.move.replace(/^[0-9]+\./,'');
                tcol = document.createElement('td'); 
                tcol.id = board.id + "_step" + p;
                tcol.innerHTML =  beautifyMove(move_ + ((step.promote !=null) ? '=' + step.promote : '') + 
				"<span style='color: #DA5E5E'>" + step.check + "</span>");
                tcol.className = 'chmovetdtitle';
                tcol.onclick = function() { jumpToLocation(this, this.step_); keyPress(false); };
                tcol.style.cursor = 'pointer';
                mouseEvent(tcol, '#D6B26B', '#35F42E');
                tcol.game_ = board; tcol.step_ = (parseInt(p) + 1);
                trow.appendChild(tcol);

                if (p % 2  && step.side == 'dt') {
                   lastmove = 2;
                   tcol = document.createElement('td');  tcol.style.color = '#84868A';
                   tcol.id = board.id + "_bdot" + p;
                   tcol.innerHTML = ' &#9679;';
                   trow.appendChild(tcol); /* score */
                   tcol = document.createElement('td'); tcol.style.color = '#84868A';
                   tcol.id = board.id + "_bscore" + p;
                   tcol.innerHTML = '+0.00';
                   trow.appendChild(tcol);  /* analysis */
                   tcol.className = 'chmovetdscore';
                   chessmovesid.appendChild(trow); 
                }
              }
              if (lastmove == 1) chessmovesid.appendChild(trow);
              var fens_ = generateFENS(board); // requires board.Moves_
              fens_.unshift({ fen: wINITFEN_, turn: null, restype: null, side: 'w' });

log("fens ...");
log(fens_);
              board.quiesce_system(board, false);
              board.PGNDB_ = { 0: fens_ }; // save it into game id 0 (for multi game settings )
              // enableGameControl(board);
              parseMoves(board, game.moves);
              board.clearBoard(board);
              board.setFENonBoard(wINITFEN_, board);

              board.GAME_STATE.playcurrent_ = 0; // current move
              board.GAME_STATE.gamecurrent_ = 0; // current game (in a multi-game setting)

              checkState(board, fens_, moves);
log(game.moves);
log(board.Moves_);
log(moves);
              chess_reset.play();
              
           }
    
           // board.notice("Ready to analyze ...");
    }

    function fetchGame(e) {
       var tourney = this.tourney_;
       var pair      = this.tourney_.pair;
log("tourney");
log(tourney);
       socket.emit("fetchgame", {sessionid: SESSION_.sessionid, username: SESSION_.username,  tourney: tourney});
    }

    function showTournament(tourney) {
log("show me tournament");
log(tourney);
        var trow = null, thdr = null, tcol = null;
        var tourneytype = tourneytypes[tourney.tournament_type - 1].item;
        var currentround = (parseInt(tourney.status) != 3) ?  " ( Round " + (parseInt(tourney.currentround) + 1) + " )" : "";
        var variant = recvariants[tourney.variant];
        var rsystem = '';

log("variant ...");
log(variant);

        var div = document.getElementById('showtourid');
        if (div != null) { div.remove(); }

        clearBoards();
        closeApps();
  //      blanket.style.visibility = 'visible';

        if (CONFIG_.ratesystem == 'rmoo') {
             rsystem = '(O)';
        } else
        if (CONFIG_.ratesystem == 'elo') {
             rsystem = '(E)';
        } else
        if (CONFIG_.ratesystem == 'glicko2' || CONFIG_.ratesystem == 'glicko') {
             rsystem = '(G2)';
        }


        div = document.createElement('div');
        var div1 = document.createElement('div');
        var div2 = document.createElement('div');
        div.style="position: absolute;  width: 1200px; height: 800px; top: 100px; left: 100px; border: 0px solid #4a4a4a; font-family: helvetica";
        div1.style="position: absolute; width: 800px; height: 800px; top: 0px; left: 0px; border: 0px solid #4a4a4a";
        div2.style="position: absolute; width: 400px; height: 800px; top: 20px; left: 800px; border: 0px solid #4a4a4a; margin-left: 20px";
        div.appendChild(div1);
        div.appendChild(div2);

        div.id = 'showtourid';

        chessdiv.appendChild(div);

        var table1 = document.createElement('table');
        var tbody = document.createElement('tbody');
        table1.appendChild(tbody);
        table1.style = "color: #D6B26B; width:100%";

        var rndspan1 = document.createElement('span');  rndspan1.innerHTML = tourneytype;
        var rndspan2 = document.createElement('span');  rndspan2.innerHTML = currentround;
        rndspan2.style.color = '#DA5E5E';

        trow = document.createElement('tr');
        tbody.appendChild(trow);
        thdr = document.createElement('th');
        thdr.innerHTML = tourney.tournament_name + " ( " + variant + " )";
        thdr.colSpan = 4;
        trow.appendChild(thdr);
        
        trow = document.createElement('tr');
        tbody.appendChild(trow);
        thdr = document.createElement('th');
        thdr.appendChild(rndspan1); 
        thdr.appendChild(rndspan2); 
        thdr.colSpan = 4;
        trow.appendChild(thdr);

        trow = document.createElement('tr');
        tbody.appendChild(trow);
        thdr = document.createElement('th');
        thdr.className = 'tourneyth';
        thdr.align = 'left';
        thdr.innerHTML = "Round";
        trow.appendChild(thdr);
        thdr = document.createElement('th');
        thdr.className = 'tourneyth';
        thdr.align = 'left';
        thdr.innerHTML = "White";
        trow.appendChild(thdr);
        // white rating 
        thdr = document.createElement('th');
        trow.appendChild(thdr);

        thdr = document.createElement('th');
        thdr.className = 'tourneyth';
        thdr.align = 'left';
        thdr.innerHTML = "Black";
        trow.appendChild(thdr);
        // black rating 
        thdr = document.createElement('th');
        trow.appendChild(thdr);

        thdr = document.createElement('th');
        thdr.align = 'left';
        thdr.className = 'tourneyth';
        thdr.innerHTML = "Result";
        trow.appendChild(thdr);

        var round = null, chgcol = true, tspan = null, usr = null, forft = null, rcolor;
        for (var p in tourney.pairing) {
           var pair = tourney.pairing[p];
           var wforfeited = (pair.wforfeit != null) ? " - away" : "";
           var bforfeited = (pair.bforfeit != null) ? " - away" : "";
           var wrating = showRating(tourney.ratings[pair.wusername], tourney.variant + 1, gameType(tourney.timer));
           var brating = showRating(tourney.ratings[pair.busername], tourney.variant + 1, gameType(tourney.timer));
           trow = document.createElement('tr');
           rcolor = (p % 2) ? "#303030" : "#24262A";
           trow.style.backgroundColor = rcolor;
           trow.style.cursor = 'pointer';
           mouseBgEvent(trow, rcolor);
           trow.onclick = fetchGame;
           trow.tourney_ = { gametoken: tourney.tournament_id, pair: pair };
           tbody.appendChild(trow);
           if (round != pair.round) {
               var thisround = (parseInt(pair.round) + 1);
               var thiscurround = (parseInt(tourney.currentround) + 1);
               tcol = document.createElement('td');
               tcol.className = 'tourneytd';
               tcol.style.backgroundColor = "#24262A";
               tcol.innerHTML = "Round " + thisround;
               tcol.rowSpan = 2;  
               tcol.vAlign = 'top';
               trow.appendChild(tcol);
               if (thisround == thiscurround && tourney.status != 3) tcol.style.color = "#DA5E5E";
               chgcol = (chgcol) ? false : true;
           } 
           tcol = document.createElement('td');
           tcol.className = 'tourneytd tourneyus';
           tspan = document.createElement('span'); 
           usr   = document.createElement('span'); 
           forft = document.createElement('span'); 
           tspan.innerHTML = (pair.wtitle != null) ? titles[pair.wtitle - 1].initial + ' ' : '';
           tspan.style.color = '#DA5E5E';
           usr.innerHTML = pair.wusername;
           forft.innerHTML = wforfeited;
           forft.style.color = '#ababab';
           tcol.appendChild(tspan);
           tcol.appendChild(usr);
           tcol.appendChild(forft);
           trow.appendChild(tcol);

           tcol = document.createElement('td');
           tcol.className = 'tourneytd tourneyus';
           tcol.style.color = '#D6B26B';
           tcol.innerHTML = wrating;
           trow.appendChild(tcol);

           tcol = document.createElement('td');
           tcol.className = 'tourneytd tourneyus';
           tspan = document.createElement('span');
           usr   = document.createElement('span');
           forft = document.createElement('span');
           tspan.innerHTML = (pair.btitle != null) ? titles[pair.btitle - 1].initial + ' ' : '';
           tspan.style.color = '#DA5E5E';
           usr.innerHTML = pair.busername;
           forft.innerHTML = bforfeited;
           forft.style.color = '#ababab';
           tcol.appendChild(tspan);
           tcol.appendChild(usr);
           tcol.appendChild(forft);
           trow.appendChild(tcol);

           tcol = document.createElement('td');
           tcol.className = 'tourneytd tourneyus';
           tcol.style.color = '#D6B26B';
           tcol.innerHTML = brating;
           trow.appendChild(tcol);

           tcol = document.createElement('td');
           tcol.className = 'tourneytd tourneyrs';
           tcol.innerHTML = pair.result; 
           trow.appendChild(tcol);
           round = pair.round;
        }

        div1.appendChild(table1);

        // leaderboard

        var table2 = document.createElement('table');
        var tbody = document.createElement('tbody');
        table2.appendChild(tbody);

        table2.style = "color: #D6B26B; width:100%";

        trow = document.createElement('tr');
        tbody.appendChild(trow);
        thdr = document.createElement('th');
        thdr.innerHTML = "Standing";
        thdr.colSpan = 4;
        trow.appendChild(thdr);

        trow = document.createElement('tr');
        tbody.appendChild(trow);
        thdr = document.createElement('th');
        thdr.className = 'tourneyth';
        thdr.align = 'left';
        thdr.innerHTML = "Players";
        trow.appendChild(thdr);

        thdr = document.createElement('th');
        trow.appendChild(thdr);

        thdr = document.createElement('th');
        thdr.className = 'tourneyth';
        thdr.align = 'left';
        thdr.innerHTML = "Points";
        trow.appendChild(thdr);

        var users = [];
        for (var p in tourney.pairing) {
           var pair = tourney.pairing[p];
           var wrating = showRating(tourney.ratings[pair.wusername], tourney.variant + 1, gameType(tourney.timer));
           var brating = showRating(tourney.ratings[pair.busername], tourney.variant + 1, gameType(tourney.timer));
           if (users[pair.wusername] == null) users[pair.wusername] = { username: pair.wusername, score: 0, title: pair.wtitle, rating: wrating };
           if (users[pair.busername] == null) users[pair.busername] = { username: pair.busername, score: 0, title: pair.btitle, rating: brating };
           if (pair.result == '1-0') users[pair.wusername].score++;
           if (pair.result == '0-1') users[pair.busername].score++;
           if (pair.result == '1/2-1/2') { 
               users[pair.wusername].score += 0.50;
               users[pair.busername].score += 0.50;
           }
        }

        var users_ = [];
        for (var p in users) {
            users_.push(users[p]);
        }

        var func = function(a,b) { 
              if (a.score > b.score) return -1;
              if (a.score < b.score) return 1;
              if (a.rating >= b.rating) return -1;
              return 1;
           };
        users = users_.sort(func);
        for (var p in users) {
           var user = users[p];
           trow = document.createElement('tr');
           trow.onclick = showPlayer;
           trow.tourney_ = { gametoken: tourney.tournament_id, pair: pair };
           mouseBgEvent(trow, '#24262A');
           tbody.appendChild(trow);
           tcol = document.createElement('td');
           tcol.className = 'tourneytd tourneyus';
           tspan = document.createElement('span');
           usr   = document.createElement('span');
           tspan.innerHTML = (user.title != null) ? titles[user.title - 1].initial + ' ' : '';
           tspan.style.color = '#DA5E5E';
           usr.innerHTML = user.username;
           tcol.appendChild(tspan);
           tcol.appendChild(usr);
           trow.appendChild(tcol);

           tcol = document.createElement('td');
           tcol.className = 'tourneytd tourneyus';
           tcol.style.color = '#D6B26B';
           tcol.innerHTML = user.rating;
           trow.appendChild(tcol);

           tcol = document.createElement('td');
           tcol.className = 'tourneytd tourneyus';
           tcol.innerHTML = user.score;
           
           trow.appendChild(tcol);
        }

        div2.appendChild(table2);
        
    }

    function joinTournament(e, gametoken, variant, simul, waitlist ) {
      var fen = wINITFEN_;
      const pvariant = (variant == null) ? STANDARD : variants[variant - 1].item;
      if (pvariant == CHESS960) { fen = randomFENchess960(); };
      if (pvariant == HORDE) { fen = wINITFENHORDE_; };
      if (simul) {
         const otherids = clearBoards();
         const game = newBoard(e, hide = true, width = 480, height = 480, pvariant,  fen);
         game.maxSize(e, game); 
         socket.emit("joinsimul", { sessionid: SESSION_.sessionid, username: SESSION_.username, utype: SESSION_.utype,
				    gametoken: gametoken, gameid: game.id, othergames: otherids });
         closeApps();
         blanket.style.visibility = 'hidden';
      } else {
         if (SESSION_.utype == REGISTERED) {
            var status = (waitlist) ? 2 : 1;  /* 1 - joined/active, 2 - waitlist, etc ... (see chess_schema.txt) */
            socket.emit("jointourney", { sessionid: SESSION_.sessionid, username: SESSION_.username, utype: SESSION_.utype,
				         gametoken: gametoken, status: status, today: UTCtoday() });
         } else {
            notice("Please sign up to join tournaments!");
         }
      }
      return true;
    }

    function leaveTournament(e, gametoken, variant, simul, status) {
      var fen = wINITFEN_;
      const pvariant = (variant == null) ? STANDARD : variants[variant - 1].item;
      if (pvariant == CHESS960) { fen = randomFENchess960(); };
      if (pvariant == HORDE) { fen = wINITFENHORDE_; };
      if (simul) {
         socket.emit("leavesimul", { sessionid: SESSION_.sessionid, username: SESSION_.username, utype: SESSION_.utype,
                                     gametoken: gametoken, gameid: game.id, othergames: otherids });
         closeApps();
         blanket.style.visibility = 'hidden';
      } else {
         if (SESSION_.utype == REGISTERED) {
            var status = (status) ? 2 : 1;  /* 1 - active, 2 - waitlist, etc ... (see chess_schema.txt) */
            socket.emit("leavetourney", { sessionid: SESSION_.sessionid, username: SESSION_.username, utype: SESSION_.utype,
                                          gametoken: gametoken, status: status });
         } else {
            notice("Please sign up to join tournaments!");
         }
      }
      return true;
    }

    function cancelTournament(gametoken, simul) {
log("canceling tournament ...");
log(gametoken);
      if (simul) {
         socket.emit("cancelsimul", { sessionid: SESSION_.sessionid, username: SESSION_.username, utype: SESSION_.utype,
                                 gametoken: gametoken });
      } else {
         socket.emit("canceltourney", { sessionid: SESSION_.sessionid, username: SESSION_.username, utype: SESSION_.utype,
                                 gametoken: gametoken });
      }
      closeApps();
      blanket.style.visibility = 'hidden';
      return true;
    }

    function watchTournament(gametoken, simul, variant) {
log("watch tournament ...");
log(gametoken);
      if (simul) {
         socket.emit("watchsimul", { sessionid: SESSION_.sessionid, username: SESSION_.username, utype: SESSION_.utype,
                                 gametoken: gametoken, variant: variant });
      } else {
         socket.emit("watchtourney", { sessionid: SESSION_.sessionid, username: SESSION_.username, utype: SESSION_.utype,
                                 gametoken: gametoken, variant: variant });
      }
      closeApps();
      closeGameSettings();
      // blanket.style.visibility = 'hidden';
      return true;
    }

    function watchGames(name) {
log("watching games ...");
      return true;
    }

    function mouseEvent(this_, color, ocolor = null, dcolor = null ) {
       this_.onmousedown = function() { this.style.color = (dcolor != null) ? dcolor : '#ffffff'; }
       this_.onmouseup   = function() { this.style.color = color; }
       this_.onmouseover = function() { this.style.color = (ocolor != null) ? ocolor : '#dadada'; }
       this_.onmouseout  = function() { this.style.color = color; }
       return true;
    }

    function mouseBgEvent(this_, color, dcolor = null) {
       this_.onmousedown = function() { this.style.backgroundColor = '#35642E';  }
       this_.onmouseup   = function() { this.style.backgroundColor = color;  }
       this_.onmouseover = function() { this.style.backgroundColor = (dcolor != null) ? dcolor : '#5a5a5a'; }
       this_.onmouseout  = function() { this.style.backgroundColor = color;  }
       return true;
    }

    function listRanks(name, listdiv, list, top_) {
       var top = top_;

       const span1a = document.createElement('span');
       const span2a = document.createElement('span');
       const span3a = document.createElement('span');

       span1a.style = "position: absolute; display: block; left:5px; width: 100%; float: left";
       span2a.style = "display: inline-block; color: #E1AC76;";
       span3a.style = "display: inline-block; color: #008080; cursor: pointer";
       span2a.innerHTML = name + '&nbsp;';
       span3a.innerHTML = '(<u>watch games</u>)';
       span1a.appendChild(span2a); span1a.appendChild(span3a);         
       span1a.style.top = top + 'px';
       span3a.onclick = function() { watchGames(this.gametype_); };
       span3a.gametype_ = name;

       mouseEvent(span3a, '#008080');

       listdiv.appendChild(span1a);

       top += 5;
       var rank = 0;
       for (var p in list) {
         top += 18;
         rank ++;
         const player = list[p];
         const span0 = document.createElement('span');
         const span1 = document.createElement('span');
         const span2 = document.createElement('span');
         const span3 = document.createElement('span');
         span0.style = "position: absolute; display: block; left:5px; width: 300px; float: left";
         span1.style = "display: inline-block; width: 25px; color: #70A5BF; text-align: right";
         span2.style = "display: inline-block; width: 168px; color: #46977c; ";
         span3.style = "display: inline-block; color: #C8C588";
         const txt4 = document.createTextNode(player.name.slice(0,15));
         if (rank == 1) { span1.style.color = span2.style.color = span3.style.color = '#DA5E5E'; }
         span0.style.top = top + 'px';
         span0.appendChild(span1); span0.appendChild(span2); span0.appendChild(span3);
         span1.innerHTML = '#' + rank + '&nbsp;';
         if (typeof(player.title) != "undefined" && player.title != '') {
             const span4 = document.createElement('span');
             span4.style = "display: inline-block; color: #DA5E5E";
             span4.innerHTML = player.title + '&nbsp;'; 
             span2.appendChild(span4);
         }
         span2.appendChild(txt4);
         span3.innerHTML = player.rating;
         listdiv.appendChild(span0);

         mouseEvent(span2, '#14815C');

         if (rank > 50) break;
       }
       return top;
    }

    function playLabelType(time) {
       var txt = 'Standard';
       if (time < 3) txt = 'Bullet'; else
       if (time < 10) txt = 'Blitz'; else
       if (time < 15) txt = 'Rapid'; else
       if (time <= 60) txt = 'Classical'; 
       return txt;
    }

    function daymsg(start_date, duration) { // duration in minutes
       var msg = '';
       var today = UTCtoday();
       var infuture = UTCdate(new Date(start_date))/1;
       var ndays = 24 * 60 * 60 * 1000;
       var nhrs = 60 * 60 * 1000;
       var nmins = 60 * 1000;
       var nsecs = 1000;
       var days = Math.floor((infuture - today) / ndays);
       var weeks = Math.floor(days / 7);
       var extra_days = (infuture - today) % ndays;
       var hrs = Math.floor(extra_days / nhrs);
       var extra_hrs = extra_days % nhrs;
       var mins = Math.floor(extra_hrs / nmins);
       var extra_mins = extra_hrs % nmins;
       var secs  = Math.ceil(extra_mins / nsecs);
       var dmins = duration * 60 * 1000;
       var end_date = LOCALdate(infuture + dmins);
       var endsin = Math.ceil(((infuture + dmins) - today) / nmins);
       var stillrunning = (infuture <= today) && (today <= (infuture + dmins));

       // weeks = Math.abs(weeks); days = Math.abs(days); hrs = Math.abs(hrs); mins = Math.abs(mins);
       if (weeks > 0) { msg = weeks + (weeks > 1 ? ' weeks, ': ' week, ') +
                                days + (days > 1 ? ' days' : ' day'); } else
       if (days > 0) {  msg = days + (days > 1 ? ' days, ' : ' day, ') + 
                             hrs + (hrs > 1 ? ' hours' : ' hour'); } else
       if (hrs > 0) {   msg = hrs + (hrs > 1 ? ' hours, ' : ' hour, ') + 
                             mins + (mins > 1 ? ' mins' : ' mins' ); } else
       if (mins > 0) {
            msg = mins + (mins > 1 ? ' mins, ' : ' min, ') + secs + (secs > 1 ? ' secs' : ' sec');
       } else {
            msg = secs + (secs > 1 ? ' secs' : ' sec');
       }
       return { stillrunning: stillrunning, ago: (extra_mins < 0), dates: { weeks: weeks, days: days, hrs: hrs, mins: mins, secs: secs },
                end_date: end_date, startsin: endsin - duration, endsin: endsin,  msg : msg };
    }

    function daylocal(tdate) {
        return new Date(tdate).toLocaleString('en-us',
             { weekday:"short", year:"numeric", month:"short", day:"numeric",
             hour: "numeric", minute: "numeric"});
    }

    function detailTourney(div, label, value, top = 0, left = 17, colorl = '#46977C', colorv = '#ababab', pointer = null ) {
         const span = document.createElement('span');
         const txt = document.createTextNode(label);    
         span.appendChild(txt);
         span.style  = 'position: absolute; display: inline-block; text-align: nowrap';
         span.style.top   = top + 'px';
         span.style.left  = left + 'px';
         span.style.color = colorl;
         const spanv  = document.createElement('span'); 
         spanv.innerHTML = value;
         spanv.style.color = colorv;
         if (pointer != null) { spanv.style.cursor = 'pointer'; }
         span.appendChild(spanv);
         div.appendChild(span);
         return { span: span, spanv: spanv };
    }

    function listTournaments(listdiv, list) {
       var top = 5;
       while (listdiv.lastChild) listdiv.removeChild(listdiv.lastChild);
       for (var p in list) {
         const tourney = list[p];
         const div1 = document.createElement('div');
         div1.style = 'position: absolute; left: 5px; height: 80px; width: 300px;';
         div1.style.top = top + 'px';

         var variant = recvariants[tourney.variant - 1];
         variant = variant.replace(/\_/g,'');

         const title = null;
         const dt1 = detailTourney(div1, tourney.name, null, 0, 2, '#E1AC76', '#008080', 'pointer');
         const dt2 = detailTourney(div1, 'Type: ', (tourney.simul) ? 'Simul' : tourney.tournament_type, 18); 
         const dt3 = detailTourney(div1, 'Rated: ', (tourney.rated) ? 'Yes' : 'No', 36); 
         const dt4 = detailTourney(div1, 'Titled: ', (tourney.titled) ? 'Yes' : 'No', 52); 
         const dt5 = detailTourney(div1, 'Variant: ', variant, 70); 
         const dt6 = detailTourney(div1, 'Duration: ', tourney.duration + ' minutes', 88); 
         const dt7 = detailTourney(div1, 'Players Joined: ', tourney.joined + ' out of ' + tourney.total, 106); 
         const dt8 = detailTourney(div1, playLabelType(tourney.timer) + ': ', tourney.timer + ' min, ' + tourney.inc + ' sec', 122); 

         if (tourney.title != null) { title = "<span style='color: #DA5E5E'>" + tourney.title + '</span>'; }

         const dt9 = detailTourney(div1, 'Hosted By: ', title + (tourney.hosted != null) ? tourney.hosted.slice(0,20) : 'system', 140); 
         const dt10 = detailTourney(div1, 'Start Date: ', tourney.start_date, 158); 

         var dt11 = null;
         var datemsg = daymsg(tourney.start_date, tourney.duration);
         if (datemsg.ago) {
              if (tourney.end_date != null) {
                 dt11 = detailTourney(div1, 'Ended Since: ', tourney.end_date, 177); 
              } else
              if (datemsg.stillrunning && datemsg.endsin > 0) {
                     dt11 = detailTourney(div1, 'Ongoing - Ends in: ', datemsg.endsin + ' min(s)',  177, 17, '#DA5E5E'); 
              } else {
                 dt11 = detailTourney(div1, 'Ended Since: ', datemsg.end_date, 177); 
              }
         } else { 
               dt11 = detailTourney(div1, 'Starts in: ', datemsg.msg,  177, 17, '#DA5E5E'); 
         }

         const span = dt1.spanv;
         if (tourney.gameover || tourney.started) {
log("this is where we get 1 ..." + tourney.name);
log(tourney.gamover);
log(tourney.started);
                 span.innerHTML = ' (<u>watch</u>)';
                 span.style.color = '#46977c';
                 span.onclick = function() { watchTournament(this.tourneyid_, this.simul_, this.variant_); };
                 span.tourneyid_ = tourney.gametoken;
                 span.variant_   = tourney.variant;
                 span.simul_   = tourney.simul;
         } else
         if (SESSION_.username == tourney.hosted) {
              if (!datemsg.ago) {
                 span.innerHTML = ' (<u>cancel</u>)';
                 span.style.color = '#46977c';
                 span.onclick = function() { cancelTournament(this.tourneyid_, this.simul_); };
                 span.tourneyid_ = tourney.gametoken;
                 span.variant_   = tourney.variant;
                 span.simul_   = tourney.simul;
              } else {
log("this is where we get 2 ...");
                 span.innerHTML = ' (<u>watch</u>)';
                 span.style.color = '#46977c';
                 span.onclick = function() { watchTournament(this.tourneyid_, this.simul_, this.variant_); };
                 span.tourneyid_ = tourney.gametoken;
                 span.variant_   = tourney.variant;
                 span.simul_   = tourney.simul;
              }
         } else
         if (datemsg.ago) {
             if (datemsg.stillrunning && tourney.player_status == 1) { // registered player
                 span.innerHTML = ' (<u>rejoin game</u>)';
                 span.style.color = '#46977c';
                 span.onclick = function() { rejoinTournament(this.tourneyid_, this.simul_); };
                 span.tourneyid_ = tourney.gametoken;
                 span.variant_   = tourney.variant;
                 span.simul_   = tourney.simul;
             } else {
log("this is where we get 3 ...");
                 span.innerHTML = ' (<u>watch</u>)';
                 span.style.color = '#46977c';
                 span.onclick = function() { watchTournament(this.tourneyid_, this.simul_, this.variant_); };
                 span.tourneyid_ = tourney.gametoken;
                 span.variant_   = tourney.variant;
                 span.simul_   = tourney.simul;
             }
         } else {
                 if (datemsg.dates.weeks > 0 || datemsg.dates.days > 0) {
	            span.innerHTML = ' (<u>register today</u>)';
                 } else {
	            span.innerHTML = ' (<u>join now</u>)';
                 }
                 if (tourney.player_status == 1) {
	            span.innerHTML = ' (<u>leave tournament</u>)';
                 }
                 var waitlist = (parseInt(tourney.joined) == parseInt(tourney.total));
                 if (tourney.player_status == 1) {
                     span.onclick = function(e) { leaveTournament(e, this.tourneyid_, this.variant_, this.simul_, this.status_); };
                 } else {
                     span.onclick = function(e) { joinTournament(e, this.tourneyid_, this.variant_, this.simul_, this.status_); };
                 }
                 span.tourneyid_ = tourney.gametoken;
                 span.variant_   = tourney.variant;
                 span.simul_     = tourney.simul;
                 span.status_    = waitlist;
         }
         mouseEvent(span, '#008080');

         listdiv.appendChild(div1);
         top += 210;
       }
       return listdiv;
    }

    function loadTournaments() {
         var top = 5;
         listTournaments(schedpanel1a, ladderlist);
         listTournaments(schedpanel2a, timerlist);
         listTournaments(schedpanel3a, simullist);
         listRanks('Bullet Rank', schedpanel1b, ladderranklist, 5);
         listRanks('Blitz Rank', schedpanel2b, rapidranklist, 5);
         listRanks('Rapid Rank', schedpanel3b, simulranklist, 5);
         listRanks('Classical Rank', schedpanel4b, simulranklist, 5);
    }

    const ladderranklist = [ { name: 'master_hermit', rating: 1800 }, 
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'wwwwwwwwwwwwwww', rating: 1502, title: 'IM' },
                       { name: 'spidermanadfasfasfasdf', rating: 1502 },
                       { name: 'spidermanasdf', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spidermandf', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'spiderman', rating: 1502 },
                       { name: 'superman', rating: 2134, title: 'GM' }
                     ];
    const titledranklist = bulletdranklist = blitzranklist = rapidranklist = simulranklist = ladderranklist;

    const ladderlist = [ 
                   { name: "Ray's Simultaneous Game", duration: 30, joined: 25, total: 50, startsin: 0, endsin: 15, timer: 0, inc: 0, type: 'ladder' },
                   { name: "Ray's Simultaneous Game", duration: 30, joined: 25, total: 50, startsin: 15, endsin: 0, timer: 5, inc: 0, type: 'bullet' },
                   { name: "Ray's Simultaneous Game", duration: 30, joined: 25, total: 50, startsin: 15, endsin: 0, timer: 6, inc: 0, type: 'bullet' },
                   { name: "Ray's Simultaneous Game", duration: 30, joined: 25, total: 50, startsin: 0, endsin: 15, timer: 6, inc: 0, type: 'bullet' },
                   { name: "Ray's Simultaneous Game", duration: 30, joined: 25, total: 50, startsin: 15, endsin: 0, timer: 6, inc: 0, type: 'bullet' },
                   { name: "Some Bullet Game", duration: 30, joined: 25, total: 50, startsin: 15, endsin: 0, timer: 6, inc: 0, type: 'bullet' },
                   { name: "Ray's Simultaneous Game 1", duration: 30, joined: 25, total: 50, startsin: 15, endsin: 0, timer: 6, inc: 0, 
                         type: 'simul', hosted: 'master_hermit', title: 'GM' }
                 ];
    const timerlist = simullist = ladderlist; 
    
    function loadGames(type, games) {
      var top = 5;
      for (var p in games) {
          var game = games[p];
          const span0 = document.createElement('span');
          const spana = document.createElement('span');
          const spanb = document.createElement('span');
          const spanc = document.createElement('span');
          const span1 = document.createElement('span');
          const span2 = document.createElement('span');
          const span3 = document.createElement('span');
          const span4 = document.createElement('span');
          const span5 = document.createElement('span');
          const span6 = document.createElement('span');
          span1.innerHTML = game.wtitle + '&nbsp;'; span2.innerHTML = game.white.slice(0,22); span3.innerHTML = game.wrating;
          span4.innerHTML = game.btitle + '&nbsp;'; span5.innerHTML = game.black.slice(0,22); span6.innerHTML = game.brating;
          spanb.appendChild(span1); spanb.appendChild(span2); spanb.appendChild(span3);
          spanc.appendChild(span4); spanc.appendChild(span5); spanc.appendChild(span6);
          span0.appendChild(spana); span0.appendChild(spanb); span0.appendChild(spanc);
          watchgamepanel1a.appendChild(span0);

          span0.style = "position: absolute; display: block; left:5px; height: 75px; width: 290"

          spana.style = "position: absolute; display: block; top: 5px; left:5px; width: 280; float: left; background-color: #404040; color: #ababab";
          spana1 = document.createElement('span'); spana1.innerHTML = 'Bullet: 1 min, 2 sec ';
          spana2 = document.createElement('span'); spana2.innerHTML = '(<u>watch game</u>)';
          spana.appendChild(spana1); spana.appendChild(spana2);
          spana2.style= 'color: #008080; cursor: pointer'; 
          
          mouseEvent(spana2, '#008080');

          spanb.style = "position: absolute; display: block; top: 25px; left:5px; width: 280; float: left";
          span1.style = "display: inline-block; width: 25px; color: #DA5E5E; text-align: right";
          span2.style = "display: inline-block; width: 220; color: #46977c; ";
          span3.style = "display: inline-block; color: #C8C588";

          spanc.style = "position: absolute; display: block; top: 45px; left:5px; width: 280px; float: left";
          span4.style = "display: inline-block; width: 25px; color: #DA5E5E; text-align: right";
          span5.style = "display: inline-block; width: 220px; color: #46977c; ";
          span6.style = "display: inline-block; color: #C8C588";
          span0.style.top = top + 'px'
          span0.style.backgroundColor = (p % 2) ? '#2B2C2D' : '#242424';
          top += 75;
      }

      var game1 = new Game('game0001', watchgamepanel2a, top=-25, left=0, width=302, height=302, color=DEFAULTCOLOR_, control=_CONTROLOFF_);
      var game2 = new Game('game0002', watchgamepanel3a, top=-25, left=0, width=302, height=302, color=DEFAULTCOLOR_, control=_CONTROLOFF_);
      var game3 = new Game('game0003', watchgamepanel4a, top=-15, left=45, width=520, height=520, color=DEFAULTCOLOR_, control=_CONTROLOFF_);
      
    }

    function loadEval(type, games) {
      var game1 = new Game('game0001', evalpanel1b, top=-25, left=0, width=840, height=840, color=DEFAULTCOLOR_, control=_CONTROLOFF_);
    }


    const bulletgames = [
                {white: 'superman', black: 'wwwwwwwwwwwwwwwwwwwwwwwwwwwww', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 },
                {white: 'superman', black: 'spiderman', wtitle: 'GM', btitle: 'IM', wrating: 1500, brating: 1600 }
            ];


    function adjustSquare(this_, twidth, theight) {

       const hHeight = chessheader.clientHeight;
       const fHeight = chessfooter.clientHeight;
       const ccontr  = getCSS(".chesscontainer");
       const tpad    = getCSS(".chessbox");
       const bdr_    = parseInt(ccontr.style.borderWidth);
       const pdT_    = parseInt(tpad.style.paddingTop);
       const pdB_    = parseInt(tpad.style.paddingBottom);
       const pdL_    = parseInt(tpad.style.paddingLeft);
       const pdR_    = parseInt(tpad.style.paddingRight);

       var width  = (twidth > theight) ? theight : twidth; 
       var height = (twidth > theight) ? theight : twidth; 

       this_.tbox.style.width = width + 'px';
       this_.tbox.style.height = height + 'px';

       const vwidth  = width + pdL_ + pdR_;
       const vheight = height + hHeight + fHeight + pdB_ + pdT_;
       var res_ctrl_ = this_.resizeContainer_;
       this_.container_.initWidth = vwidth;
       this_.container_.initHeight = vheight;
       res_ctrl_.style.visibility = 'visible';
       res_ctrl_.style.width =  vwidth + 'px';
       res_ctrl_.style.height = vheight  + 'px';

       document.setsquaregame_ = this_;
       this_.resizeBoard(null, false );
       this_.showPGN({ detail: 1, preventDefault: function() {}} , 1);
       this_.postScore();
       delete document.setsquaregame_;
    }

    function adjustAllLayout(this_) {
       if (!CONFIG_.layout.free)  {
           const container_ = this_.container_; 
           const tbox = this_.tbox; 
           CONFIG_.layout.coor.width = parseInt(tbox.style.width);
           CONFIG_.layout.coor.height = parseInt(tbox.style.height);
           adjustLayout(false);
       }
    }

    function adjustLayout(create = true) {
         const free    = CONFIG_.layout.free;
         const col     = CONFIG_.layout.coor.col;
         const row     = CONFIG_.layout.coor.row;
         const blen    = BOARDS_.length;
         var clen      = layoutid.children.length;
         const hHeight = chessheader.clientHeight;
         const fHeight = chessfooter.clientHeight;
         const ccontr  = getCSS(".chesscontainer");
         const tpad    = getCSS(".chessbox");
         const bdr_    = parseInt(ccontr.style.borderWidth);
         const pdT_    = parseInt(tpad.style.paddingTop);
         const pdB_    = parseInt(tpad.style.paddingBottom);
         const pdL_    = parseInt(tpad.style.paddingLeft);
         const pdR_    = parseInt(tpad.style.paddingRight);

         const twidth  = CONFIG_.layout.coor.width;  
         const theight = CONFIG_.layout.coor.height;
         const vwidth  = CONFIG_.layout.coor.width + pdL_ + pdR_ + 2 * bdr_;
         const vheight = CONFIG_.layout.coor.height + 2 * bdr_ + hHeight + fHeight + pdB_ + pdT_;
         const addview = function(w, h) {
               const view = document.createElement('div');
               view.className = 'view';
               view.style.width = w + 'px';
               view.style.height = h + 'px';
               layoutid.appendChild(view);
               return view;
         }

         if (!free) {
log("got here for layout ...");
               var view = null;
               var p = 0;
               var child = layoutid.firstChild;
               layoutid.style.width = ((vwidth +  2 * 25) * col + 25) + 'px'; // 25px view margins
               if (create) {
                  var i = 0;
                  for (var r=1; r<= row; r++) {
                      for (var c=1; c<= col; c++) {
                          view = addview(vwidth, vheight);
                          view.cnt_ = i;
                          i++;
                      }
                  }
               }  else {
                  // see if we need to add views ...
                  if (col * row > clen) {
                      const n = col * row;
                      while (n > clen) {
                          view = addview(vwidth, vheight);
                          clen = layoutid.children.length;
                      } 
                  } else
                  if (col * row < clen) {
                     if (blen < clen) 
                     while (col * row < clen && blen < clen) {
                         var child = layoutid.lastChild;
                         if (child.nodeType == 1) {
                            layoutid.removeChild(child); 
                         }
                         clen = layoutid.children.length; 
                     }
                  }
                  // set width/height first of layout
                  var i = 0;
                  for (var p in layoutid.children) {
                       const child = layoutid.children[p];
                       if (child.nodeType != 1) continue;
                       const board = BOARDS_[i];
                       child.style.width = vwidth + 'px';
                       child.style.height = vheight + 'px';
                       if (board != null) {
                          const contr = board.container_;
                          adjustSquare(board, twidth, theight);
                       }
                       i++;
                  } 
                  var i = 0;
                  // use layout template to correctly position the boards
                  for (var p in layoutid.children) {
                       const child = layoutid.children[p];
                       if (child.nodeType != 1) continue;
                       const top  = child.parentNode.offsetTop + child.offsetTop - hHeight;
                       const left = child.parentNode.offsetLeft + child.offsetLeft;
                       const board = BOARDS_[i];
                       if (board != null) {
                         const contr = board.container_;
                         contr.style.top  = top + 'px';
                         contr.style.left = left + 'px';
                       }
                       i++;
                  }
               }
         }
    }

    function message(this_, msg, err = true, stick = false) {
        var msgwin = this_.tbox.waiting_;
        var msgid = this_.tbox.waitid_;
        int_message = 0;
        msgwin.style.visibility = 'visible';
        msgid.innerHTML = msg; 
        if (err) throw "Error.";
    }

    function closeMessage(this_) {
      hideErrors();
      blanket.style.visibility = 'hidden';
      this_.style.visibility = 'hidden';
      keyPress(false);
    }

    function pageSize() {
        var w = window.innerWidth;
        var h = window.innerHeight;

        if (!w) {
             w = document.documentElement.clientWidth;
             h = document.documentElement.clientHeight;
             if (!w) {
                 w = document.body.clientWidth;
                 h = document.body.clientHeight;
             }
        }
        return {width: w, height: h};
    }

    // popups
    function mousehover(e) { e.preventDefault(); this.style.backgroundColor = "#A6C39E"; return true; }
    function mousehout(e) { e.preventDefault(); this.style.backgroundColor = this.bcolor_; return true; }
    function mousehdown(e) { e.preventDefault(); this.style.backgroundColor = "#8f8f8f"; return true; }
    function mousehup(e) { e.preventDefault(); this.style.backgroundColor = "#A6C39E"; return true; }

    function leavePopup(e) {
       if (this.className.match('popupdiv')) {
         this.style.visibility = 'hidden';
       }
       return true;
    }

    function addPopupSpan(this_, func, width, item) {
        var s = document.createElement('span');
        s.className = 'popspan';
        s.style.height = '25px';
        s.style.width = width ;
        s.style.color = '#4A4A4A';
        s.style.padding = '10px 0px 0px 10px';
        s.style.textAlign='middle';
        s.addEventListener("mouseover", mousehover, true);
        s.addEventListener("mouseout", mousehout, true);
        s.addEventListener("mousedown", mousehdown, true);
        s.addEventListener("mouseup", mousehup, true);
        s.onclick = func;
        s.game_ = this_;
        if (item.nm != null) {
            s.innerHTML = item.lab; ;
            s.value_ = item.nm;
        } else {
            s.innerHTML = item;
            s.value_ = item ;
        }
        return s;
    }

    function createPopup(id, this_, top, left, width, height, list = null, func = null) {
      if (list != null) {
        var d1 = document.createElement('div');
        var d2 = document.createElement('div');
        var d3 = document.createElement('div');
        var dark = '#D7E6D3', light = '#E6F1E3';
        d1.className = "popupdiv";
        d2.className = "popup";
        d3.className = "popup";
        d3.style = "margin: 5px 5px 5px 5px; overflow-y:scroll";
        d1.style.top = top + 'px'; 
        d1.style.left = left + 'px'; 
        d1.style.width = width + 'px'; 
        d1.style.height = height + 'px'; 
        d1.style.zIndex = 15000;
        d1.appendChild(d2);  
        d2.appendChild(d3);  
        this_.container_.appendChild(d1);
        for (p in list) { 
           const item = list[p];
           var s = addPopupSpan(this_, func, width + 'px', item);
           s.style.backgroundColor = (parseInt(p) % 2) ? light : dark;
           s.bcolor_ = (parseInt(p) % 2) ? light : dark;
           d3.appendChild(s);
        }
        d1.id = id;
        d3.id = 'pop_' + id;
        d1.addEventListener('mouseleave', leavePopup, false);
      }
    }


    function padTime(elapsed) {
       var s = ~~(elapsed / 1000); 
       var m = ~~(s / 60);
       var h = ~~(m / 60);
       m = m % 60; 
       s = s % 60 ; 
       var t = ("00" + s).slice(-2); 
       if (h == 0) t = m + ':' + t; else t = ("00" + m).slice(-2) + t; 
       if (h > 0) t = h + ':' + t; 
       return t;
    }

    function chooseBoardColor(this_, pos) {
      var id = 'choosecolorid_' + this_.id;
      const elem = document.getElementById(id);
      const colors = [];
      for (var p in BOARDCOLOR_) { colors.push(p); }
       if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
            return 
       }
      createPopup(id, this_, top = pos.y, left =  pos.x + 6, width = 200, height = 200, colors, this_.changeBoardColor );
    }


    function chooseAnalyze(this_, pos) {
       var id = 'chooseanalyzeid_' + this_.id;
       const elem = document.getElementById(id);
       if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
           return 
       }
       const fens = ["K7/8/3R4/4k3/8/8/8/8 b - - 0 1",
        "3qk3/5p2/8/8/8/8/8/3QK3 w KQkq - 0 1",
        "rnbqk1nr/ppp2ppp/8/4b3/2p5/2N1P3/PP3PPP/N1BQKBNR w KQkq - 0 1",
        "8/8/8/1B6/8/1k6/8/1K6 b - - 0 1",
        "8/R7/6kp/4b1p1/8/8/5PK1/8 w - - 0 1",
        "2kr4/ppp5/8/6p1/3Pp1q1/2B5/PP6/R3RK2 b - - 0 1",
        "2kr4/ppp5/8/6p1/3Pp1q1/2B5/PP6/R1K2R2 b - - 0 1",
        "1q4r1/p3pk1P/2p1bp2/2Bp3p/N1P1n3/1P1P1N2/P2Q1P2/2R3K1 w - - 0 1",
        "r1bqkbnr/ppp2ppp/2np4/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 0 1",
  	"8/8/4K3/4R3/8/4Pk2/7Q/8 w - - 0 1",
  	"8/8/8/1k7/8/1b7/8/4K2R b KQkq - 0 1",
  	"5n2/6P2/8/8/5K2/7k/8/8 w - - 0 1",
  	"5N2/6p2/8/8/5k2/8/8/7K b - - 0 1",
  	"rn2kb1r/ppp1qppp/4bn2/3p4/3P4/1PP2N2/P3BPPP/RNBQ1RK1 w Kq - 0 1",
  	"r1bqkb1r/pp2pp2/2np1n1p/2p3p1/4P3/P2P1N2/1PP1BPPP/RNBQ1RK1 w Kq - 0 1",
  	"r1b1k2r/pp3p2/2np1q2/8/1P1bP1pp/P2Q4/4BPPP/1RB2RK1 w kq - 0 1",
  	"r2qkb1r/pp2nppp/3p4/2pNN1B1/2BnP3/3P4/PPP2PPP/R2bK2R w KQkq - 0 1",
  	"8/8/7K/8/5k2/8/6p2/8 b - - 0 1",
  	"RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rnbkqbnr w KQkq - 0 1",
  	"RNBKQBNR/PPPPPPPP/8/8/8/8/pppppppp/rPbkqbnr w KQkq - 0 1",
  	"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQKq - 0 1",
  	"rnbqkb1r/ppp1pppp/3p1n2/8/4P3/5N2/PPPPBPPP/RNBQK2R b KQKq - 0 1",
  	"4n3/5P2/8/8/K7/7k/8/8 w - - 0 1",
  	"8/8/8/8/k7/7K/4p3/8 b - - 0 1",
  	"1nb5/8/8/8/3K4/k7/8/8 w - - 0 1",
  	"k7/8/2K5/8/8/8/8/8 w - - 0 1",
  	"4k3/8/8/8/8/8/8/4K3 w - - 0 1",
  	"1nb5/8/8/2k6/8/4K3/8/8 w - - 0 1"];
        createPopup(id, this_, top = pos.y, left =  pos.x + 6, width = 600, height = 200, fens, this_.analyzePosition );
    }

    function chooseDatabase(this_,pos) {
      var id = 'choosedatabaseid_' + this_.id;
      const elem = document.getElementById(id);
      if (elem) { 
            elem.style.visibility = 'visible'; 
            elem.style.top = pos.y; elem.style.left = pos.x;
           return 
      }
       const dbs = [
        { nm: "broken", lab: "broken.pgn" },
        { nm: "broken1", lab: "broken1.pgn" },
        { nm: "broken2", lab: "broken2.pgn" },
        { nm: "broken3", lab: "broken3.pgn" },
        { nm: "broken4", lab: "broken4.pgn" },
        { nm: "broken5", lab: "broken5.pgn" },
        { nm: "demo2", lab: "demo2.pgn" },
        { nm: "demo4", lab: "demo4.pgn" },
        { nm: "demo5", lab: "demo5.pgn" },
        { nm: "demo10", lab: "demo10.pgn" },
        { nm: "demo11", lab: "demo11.pgn" },
        { nm: "mygames", lab: "mygames.pgn" },
        { nm: "alek", lab: "Alek" },
        { nm: "AlekhineExchange", lab: "Alekhine Exchange" },
        { nm: "Alekhine2Nc3-d5", lab: "Alekhine (2.Nc3 d5)" },
        { nm: "BenkoGambit", lab: "Benko Gambit" },
        { nm: "CatalanClosed", lab: "Catalan Closed" },
        { nm: "CatalanOpen", lab: "Catalan Open" },
        { nm: "FrenchAdvance", lab: "French Advance" },
        { nm: "FrenchExachange", lab: "French Exchange" },
        { nm: "FrenchRubinstein", lab: "French Rubinstein" },
        { nm: "FrTarrasch3c5", lab: "French Tarrasch (3.c5)" },
        { nm: "FrTarrasch3Nf6", lab: "French Tarrasch (3.Nf6)" },
        { nm: "FrTarraschOther3", lab: "French Tarrasch (3.Other)" },
        { nm: "FrWinawerMain", lab: "French Winawer (Main)" },
        { nm: "GiuocoPiano", lab: "Giuoco Piano" },
        { nm: "KIDClassical", lab: "King's Indian (Classic)" },
        { nm: "KIDFianchetto", lab: "King's Indian (Fianchetto)" },
        { nm: "KIDSaemisch", lab: "King's Indian (Saemisch)" },
        { nm: "KIDPetrosian", lab: "King's Indian (Petrosian)" },
        { nm: "QID4a3", lab: "Queen's Indian (4.a3)" },
        { nm: "QID4e3", lab: "Queen's Indian (4.e3)" },
        { nm: "QID4g3-Ba6", lab: "Queen's Indian (4.g3 Ba6)" },
        { nm: "QID4Nc3", lab: "Queen's Indian (4.Nc3)" },
        { nm: "RuyLopezBerlin", lab: "Ruy Lopez (Berlin)" },
        { nm: "RuyLopezBreyer", lab: "Ruy Lopez (Breyer)" },
        { nm: "RuyLopezChigorin", lab: "Ruy Lopez (Chigorin)" },
        { nm: "RuyLopezMarshall", lab: "Ruy Lopez (Marshall)" },
        { nm: "RuyLopezAntiMarshall", lab: "Ruy Lopez (AntiMarshall)" },
        { nm: "PetroffMain", lab: "Petroff Main" },
        { nm: "PetroffOther3", lab: "Petroff Other 3." },
        { nm: "Scotch4Bc5", lab: "Scotch (4.Bc5)" },
        { nm: "Scotch4Nf6", lab: "Scotch (4.Nf6)" },
        { nm: "SicilianAlapin2Nf6", lab: "Sicilian Alapin (2.Nf6)" },
        { nm: "SicilianAlapin2d5", lab: "Sicilian Alapin (2.d5)" },
        { nm: "SicilianLowenthal", lab: "Sicilian Lowenthal" },
        { nm: "SicilianNajdorf6f3", lab: "Sicilian Najdorf (f6 f3)" },
        { nm: "SicilianNajdorf6f4", lab: "Sicilian Najdorf (f6 f4)" },
        { nm: "SicilianNajdorf6Bg5", lab: "Sicilian Najdorf (f6 Bg5)" },
        { nm: "SicilianNajdorf6Be3", lab: "Sicilian Najdorf (f6 Be3)" },
        { nm: "SicilianNajdorf6Be2", lab: "Sicilian Najdorf (f6 Be2)" },
        { nm: "SicilianNajdorf6Bc4", lab: "Sicilian Najdorf (f6 Bc4)" },
        { nm: "SicilianRossolimo", lab: "Sicilian Rossolimo" },
        { nm: "SicilianScheveningen", lab: "Sicilian Scheveningen" },
        { nm: "SicilianSveshnikov", lab: "Sicilian Sveshnikov" },
        { nm: "SicilianTaimanov5Nb5", lab: "Sicilian Talmanov (5.Nb5)" },
        { nm: "SicilianTaimanovMain", lab: "Sicilian Talmanov (Main)" } ];
         createPopup(id, this_, top = pos.y, left = pos.x + 6, width = 240, height = 200, dbs, this_.changeDatabase );
    }

    function collapseTools(tool) {
      var this_ = tool.game_;
      if (this_ != null && this_.control_ != null) {
          const vis = this_.control_.style.visibility;
          this_.control_.style.visibility = (vis == 'visible') ? 'hidden' : 'visible';
      }
    }

    // Reverse Board
    var reverse_ =  { a:"h", b:"g", c:"f", d:"e", e:"d", f:"c", g:"b", h:"a",
                      1:8, 2:7, 3:6, 4:5, 5:4, 6:3, 7:2, 8:1 }
    function reverseLoc(location, reversed = true) {  /** Generic **/
        if (reversed) {
           return reverse_[location[0]] + reverse_[location[1]];
        } else {
           return location
        }
    }


    function illegal_move(msg) { throw {msg: msg, cause: "illegal move"}; }

    const SOURCE_HIST_ = []
    function emptySource() { 
          while (SOURCE_HIST_.length) SOURCE_HIST_.pop(); 
          source_.style.visibility = 'hidden';
          destination_.style.visibility = 'hidden';
     }

    var SIDETOMOVE_ = WHITE, MOVECOUNT_ = 0;
    var sidetoid = document.getElementById("sidetomoveid");

    function searchGame() {
        return ecoGame_.join(' ');
    }

    
    function addFEN(fen) {
       const analyzeid = document.getElementById('pop_chooseanalyzeid_');
       var found_ = false;
       var next = analyzeid.firstChild, fen_, width = null, func = null;
       while (next) {
         fen_ = next.innerHTML;
         width = next.style.width;
         func = next.onclick;
         if (fen == fen_) { found_  = true; break }
         next = next.nextSibling;
       }
       if (!found_) {
          var s = addPopupSpan(func, width, fen);
          analyzeid.appendChild(s);
      }
    }

    function checkPositionLegality(this_, fen) {
       if (fen == null) fen =  generateFEN('w', enpassant = "-") 
       var fens_ = fen.split(' ');
       var initfen_ = fens_[0];
       var nside_ = fens_[1];
       var binitfen_ = bINITFEN_.split(' ')[0];
       var winitfen_ = wINITFEN_.split(' ')[0];
       var fen_ = initfen_.split('/');
       var cntP = initfen_.match(/[Pp]/g)
       var cntK = initfen_.match(/[K]/g)
       var cntk = initfen_.match(/[k]/g)
       var Kk  = initfen_.match(/Kk|kK/g)
       var un_ = initfen_.match(/[ACDEFGHIJLMOSTUVWXZY\.\!\#\$\%\^\&\*\(\)\_\-\+\=\[\{\]\}\;\'\:\"\<\>\>\<\?\\\~\`09]/ig)
       var my8thrank = fen_[0]; my1strank = fen_[7];
       var castl = fens_[2];
       if (fens_[2] == null) { message(this_, "Incorrect Notation."); return } 
       castl = castl.match(/^(KQkq|Qkq|KQk|Kkq|KQq|KQ|Kk|Kq|Qk|Qq|kq|Q|q|K|k|-)$/g);
       if (fen_.length != 8) message(this_, "invalid number of ranks");
       if (nside_ != 'w' && nside_ != 'b') message(this_, "Incorrect side option. Use (w or b).");
       if (castl == null) message(this_, "Invalid Castling options");
       if (un_ != null && un_.length > 0) message(this_, "Invalid Notation. Unknown characters found!");
       if (Kk != null && Kk.length > 0) message(this_, "Kings cannot be close to each other!");
       if (cntK != null && cntK.length != 1) message(this_, cntK.length + " White Kings not allowed!");
       if (cntk != null && cntk.length != 1) message(this_, cntk.length + " Black Kings not allowed!");
       if (cntK == null || cntk == null) message(this_, "Missing king.");
       if (cntP != null && cntP.length > 16) message(this_,  cntP.length + " Pawns not allowed!");
       if ((my8thrank != null && my8thrank.match(/[Pp]/)) || 
           (my1strank != null && my1strank.match(/[Pp]/)) )
             message(this_, "Cannot have Pawns in the 1st and 8th ranks!");
       if (initfen_ == binitfen_) {
           if (nside_ == 'b') {
             message(this_, "Black cannot start the game first!");
           } else {
             return 1; 
           }
        }
       return null; 
    }

    function generateFENS(this_) {
       var fens_ = [];
       for (var p in this_.Moves_) {
            const move = this_.Moves_[p];
            const turn = this_.simpleMove(this_, move, null);
            const restype = this_.captureMove(turn, HUMAN, NOTMANUAL, false, false, true);
            const side = this_.GAME_STATE.sidetomove_ == WHITE ? 'w' : 'b';
            const fen = generateFEN(this_, side);
            const rmove_ = { fen: fen, turn: turn, side: side, restype: restype }
            fens_.push(rmove_);
       }
       return fens_;
    }
        
    function generateFEN(this_, whichside) {
      var Board = this_.ChessBoard.Board;
      var enpassant = this_.isEnpassant();
      var piece = null;
      var fen = "", spc = 0, cmp = "";
      var castling = [0,0,0,0,0,0], cst = "";
      for (var v=8; v>=1; v--) {
         spc = 0;
         for (p in horiz) {
            piece = Board[horiz[p] + v].piece;
            if (piece != null) {
                cmp =  (piece.color_.match(/dt$/)) ? piece.role_.toLowerCase() : piece.role_;
                fen = fen + ((spc > 0) ? (spc + cmp) : cmp);
                spc = 0;
                // check for castling availability
                if (cmp == 'K' && piece.location_ == 'e1' && piece.oldlocation_ == null) castling[0] =  1;
                if (cmp == 'k' && piece.location_ == 'e8' && piece.oldlocation_ == null) castling[1] =  1;
                if (cmp == 'R' && piece.location_ == 'h1' && piece.oldlocation_ == null) castling[2] =  1;
                if (cmp == 'R' && piece.location_ == 'a1' && piece.oldlocation_ == null) castling[3] =  1;
                if (cmp == 'r' && piece.location_ == 'h8' && piece.oldlocation_ == null) castling[4] =  1;
                if (cmp == 'r' && piece.location_ == 'a8' && piece.oldlocation_ == null) castling[5] =  1;
            } else { spc ++; }
         }
         fen = fen + ((spc > 0) ? spc : "");
         if (v > 1) fen = fen + "/";
       } 
       if (castling[0] == 1 && castling[2] == 1) cst = cst + "K";
       if (castling[0] == 1 && castling[3] == 1) cst = cst + "Q";
       if (castling[1] == 1 && castling[4] == 1) cst = cst + "k";
       if (castling[1] == 1 && castling[5] == 1) cst = cst + "q";
       if (cst == "") cst = "-";
       fen = fen + " " + whichside + " " + cst + " " + enpassant + " " + "50 50";
       return fen;
    }

    function post(msg, id )      { ENGINE_.postid = id; ENGINE_.postMessage(msg); }

    var ENGINE_ = null, ANALYZE_ = [];
    var ENGINE_UCI_RESPONSE_ = null, ENGINE_READY_RESPONSE_ = null, ENGINE_NEW_RESPONSE_ = null, ENGINE_NEXT_RESPONSE_ = null;
    var ENGINE_STATE_REQ_ = false;
    async function loadStockfish() {
       ENGINE_ = await new Worker('/wasm/stockfish.js');
       ENGINE_.posted = {}; 
       ENGINE_.id     = "stockfish15";
       ENGINE_.onmessage = function(event) {
             var engine_ = ENGINE_.ENGINEMOVE_;
             var load = event.data ? event.data : event;
             if (typeof(load.match) == "undefined") return;
             if (load.match(/^uciok$/)) {
                ENGINE_UCI_RESPONSE_ = 'uciok'; 
                return true;
             } 
             if (load.match(/^readyok$/)) {
                ENGINE_READY_RESPONSE_ = 'readyok'; 
                return true;
             }
             if (ANALYZE_.length == 0) {
                ENGINE_WINS_ = 0;
                ENGINE_LOSES_ = 0;
             }

             if (load.includes("info depth 0 score cp 0")) {
                 _POSSIBLE_STALE_MATE_ = true;  
                 log("possible stale mate ...");
             } else
             if (load.match(/^info depth/)) {
                var sdata = load.split(' ');
                if (ANALYZE_.length > 20) return;
                var mate = sdata[8];
                var xcp   = parseInt(sdata[9]);
                var draw = Math.floor(parseInt(sdata[12]) / 2);
                var win = ( parseInt(sdata[11])) / 1000;
                var draw = (parseInt(sdata[12])) / 1000;
                var loss = (parseInt(sdata[13])) / 1000;
                var wprob = (parseInt(sdata[11]) + parseInt(sdata[12])/2) / 1000;
                var lprob = (parseInt(sdata[13]) + parseInt(sdata[12])/2) / 1000;
                var score = 2 / (1 + Math.exp(-0.00368208*xcp)) - 1; // formula from Landon Lehman blog site.
                var srate = 1 / (1 + Math.exp(-0.004*xcp)); // formula from Landon Lehman blog site.
                var sratewq =  111.714640912 * Math.tan(1.5620688421 * wprob);
                var sratelq =  111.714640912 * Math.tan(1.5620688421 * lprob); 
                var pv = load.lastIndexOf("pv");
                if (mate == "mate") { mate = xcp; xcp = null } else { mate = null };
                if (!isNaN(srate))  {
                        ANALYZE_.push({ mt: mate, score: score, wprob: wprob, lprob: lprob, cp: xcp,
                                        sratewq: sratewq, sratelq: sratelq, srate: srate,
                                        win: win, draw: draw, loss: loss, mt: mate, moves: load.slice(pv+3) } );
                }
             } else
             if (load.includes("mate 0")) {
                 _POSSIBLE_CHECK_MATE_ = true;  
                 log("possible check mate ...");
             } else
             if (load.includes("mate 1 ")) {
                 _CHECK_MATE_ = true;  
                 log("check mate ...");
             } else
             if (load.includes('bestmove')) {
                var sdata = load.split(' ');
                ENGINEMOVE_ = sdata[1];
                PONDER_ = sdata[3];
                if (ENGINE_STATE_REQ_) {
                  ENGINE_NEXT_RESPONSE_ = true;
                  ENGINE_STATE_REQ_ = false;
                  return true;
                }
                if (ENGINEMOVE_ == "(none)" && _POSSIBLE_CHECK_MATE_ == true) {
                  _CHECK_MATE_ = true;
                  _NO_POSSIBLE_MOVES_ = true;
                  log("mate ...");
                } else
                if (ENGINEMOVE_ == "(none)" && _POSSIBLE_STALE_MATE_ == true) {
                  _STALE_MATE_ = true;
                  log("stalemate ...");
                } else
                if (typeof(PONDER_) == "undefined") { 
                  // _NO_POSSIBLE_MOVES_ = true;
		  log(_CHECK_MATE_);
                  log("(possible mate ...)");
                } 
             } 
             return true;
       };
  
    }

    var BOOK_ = null;
    function searchECO() {
       var randmove = 0, book_ = "";
       var game_ = searchGame();
       const ecoran_ = [];
       BOOK_ = null;
       for (p in ECO_) {
          var eco = ECO_[p][2];
          if (typeof(eco) != "undefined") {
            if (eco.match(game_)) {
               ecoran_.push(ECO_[p]);
            } 
          }
       }
       randmove = Math.floor(Math.random() * ecoran_.length)
       if (ecoran_.length > 0 ) {
         var idx = (SIDETOMOVE_ == WHITE) ? (MOVECOUNT_ * 2): (MOVECOUNT_ * 2 + 1) , 
             move_ = null;
         BOOK_ = ecoran_[randmove]
         ecoid.innerHTML = BOOK_[0] 
         openingid.innerHTML = BOOK_[1] 
         variationid.innerHTML = BOOK_[2].replace(/N/g, '&#9816;').replace(/Q/g,'&#9813;').
                  replace(/B/g,'&#9815;').replace(/K/g,'&#9812;').
                  replace(/R/g,'&#9814;').replace(/P/g, ''); 
         move_ = BOOK_[2].split(' ')[idx]
         if (typeof(move_) != "undefined") { 
           move_ = move_.replace(/^[0-9]+\./g, "");
         } else BOOK_ = null; 
         if (BOOK_ != null && BOOK_[2].lastIndexOf("(") >=0 ) BOOK_ = null;
         return move_;
       }
       return null;
    }

    var ANALYZERATE_ = 50;
    function setRate() {
        var height = (!REVERSE) ? ANALYZERATE_ : 100 - ANALYZERATE_;
        chessrate.style.height = height + "%";
        chessside0.style.backgroundColor = (!REVERSE) ? "#FFFFFF" : "#404040";
        chessrate.style.backgroundColor = (!REVERSE) ? "#404040" : "#FFFFFF";
    }


    function updateMate()  {
      const chk = document.getElementById(LASTMOVE_);
      if (chk != null) {
        const cnt_ = LASTMOVE_.split('_')[1];
        const move_ = LASTMOVE_.split('_')[2];
        chk.innerHTML = (_CHECK_MATE_ || _NO_POSSIBLE_MOVES_) ? '#' : (_CHECK1_KING_ ? '+' : '');
        for (p in ecoGame_) {
           const eco_ = ecoGame_[p];
           if (eco_ == cnt_ + '.' + move_ + '+') {
                ecoGame_[p] = cnt_ + '.' + move_ + '#';
           } else
           if (eco_ == move_ + '+') {
                ecoGame_[p] = move_ + '#';
            }
        }
      }
    }

    const bcapture = document.getElementById("bcapture");
    const wcapture = document.getElementById("wcapture");
    const wicon_ = { Q:'&#9813;', R:'&#9814;', B:'&#9815;', N:'&#9816;', P:'&#9817;' }
    const bicon_ = { Q:'&#9819;', R:'&#9820;', B:'&#9821;', N:'&#9822;', P:'&#9823;' }
    function sortBenchedPieces() {
log("deal with this later ...");
return;
        const white_ = { Q: 0, R: 0, B: 0, N: 0, P: 0 };
        const black_ = { Q: 0, R: 0, B: 0, N: 0, P: 0 };
        if (BOARDSIZE_ < 480) {
          bcapture.innerHTML = '';
          wcapture.innerHTML = '';
          return
        }
        for (p in Benched) {
           const piece = Benched[p];
           if (piece.color_.match(/lt$/)) {
             white_[piece.role] ++ ;
           } else {
             black_[piece.role_] ++ ;
           }
        }
        const pieces_ = ['Q','R','B','N','P'];
        var wpcs_ = '', bpcs_ = '';
        for (h in pieces_) {
           const pcs = pieces_[h];
           const wpiece = white_[pcs]; bpiece = black_[pcs];
           if (wpiece > 0) for (var i=1; i<=wpiece; i++) wpcs_ = wpcs_ + wicon_[pcs];
           if (bpiece > 0) for (var i=1; i<=bpiece; i++) bpcs_ = bpcs_ + bicon_[pcs];
        }
        bcapture.innerHTML = wpcs_; 
        wcapture.innerHTML = bpcs_; 
    }


    function scrollOffset(e, clientXY = true) {
          e = e || window.event;
           edoc = (e.target && e.target.ownerDocument) || document;
           doc = edoc.documentElement;
           body = edoc.body;

           x = (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
               (doc && doc.clientLeft || body && body.clientLeft || 0);
           y = (doc && doc.scrollTop  || body && body.scrollTop  || 0) -
               (doc && doc.clientTop  || body && body.clientTop  || 0 );
           if (clientXY) {
              x += e.clientX;
              y += e.clientY;
           }
          return { x: x, y: y }
    }

    function identifySource(Board, piece_) {
       var src_ = '', srch_ = '', srcv_ = '';
       for (var p in Board) {
         const piece = Board[p].piece;
         if (src_.length == 2) break; // we got the full source
         if (piece != null && piece.role_ == piece_.role_) {
             if (piece_ !== piece) {
               if (piece_.color_ == piece.color_) {
                  const ro_ = piece_.role_, oh_ = (piece_.oldlocation_ != null) ? piece_.oldlocation_[0] : null, 
                                            ov_ = (piece_.oldlocation_ != null) ? piece_.oldlocation_[1] : null, 
                       nh_ = piece_.location_[0], nv_ = piece_.location_[1];
                  const ro = piece.role_, oh = (piece.oldlocation_ != null) ? piece.oldlocation_[0] : null, 
                                          ov = (piece.oldlocation_ != null) ? piece.oldlocation_[1] : null, 
                        nh = piece.location_[0], nv = piece.location_[1];
             
                  for (y in ['R', 'Q']) {
                    const mro = ['R', 'Q'][y];
                    if (ro_ == mro) {
                      var blk_ = false;
                      if (nv_ == nv) {
                          const d1 = oh_.charCodeAt(0), d2 = nh.charCodeAt(0);
                          const mi = (d1 < d2) ? d1 : d2, mx = (d1 < d2) ? d2 : d1
                          for (var i = mi;  i <= mx; i++) { 
                               const hv = String.fromCharCode(i) + nv_;
                               if (Board[hv].piece != null && Board[hv].role_ != mro ) { blk_ = true; break }
                          }
                      } else // end if ov_ == ov
                      if (nh_ == nh) {
                          const mi = (ov_ < nv) ? ov_ : nv, mx = (ov_ < nv) ? nv : ov_ 
                          for (var i = mi;  i <= mx; i++) {
                               const hv = nh_ + i;
                               if (Board[hv].piece != null && Board[hv].role_ != mro ) { blk_ = true; break }
                          }
                      } 
                      if (!blk_ && (nv_ == nv || nh_ == nh)) { 
                            if (src_.length == 0) {
                               if (oh_ != nh) src_ = oh_; else src_ = ov_;
                            } else
                            if (src_.length == 1) {
                                   if (src_ == oh_) src_ = src_ + ov_;
                                   if (src_ == ov_) src_ = oh_ + src_ ;
                            }
                      }
                    } // end ro == 'R'
                  } // end for mro

                  for (y in ['B', 'Q']) {
                    const mro = ['B', 'Q'][y];
                    if (ro_ == mro) {
                      var blk_ = false;
                      const d1 = nh.charCodeAt(0), d2 = nh_.charCodeAt(0), diff_h = Math.abs(d1 - d2), diff_v = Math.abs(nv - nv_);
                      if (diff_h == diff_v) {
                         const mi = (d1 < d2) ? d1 : d2, mx = (d1 < d2) ? d2 : d1
                         for (var i=1; i<=diff_h; i++) {
                             const hv = String.fromCharCode(mi + i) + (parseInt(nv) < parseInt(nv_) ? (parseInt(nv) + i) : (parseInt(nv) - i));
                             if (Board[hv].piece != null && Board[hv].role_ != mro ) { blk_ = true; break }
                         }
                         if (!blk_) {
                            if (src_.length == 0) {
                               if (oh_ != nh) src_ = oh_; else src_ = ov_;
                            } else
                            if (src_.length == 1) {
                                   if (src_ == nh) src_ = src_ + ov_;
                                   if (src_ == nv) src_ = oh_ + src_ ;
                            }
                         } 
                      }
                    } // end ro == 'B'
                  } // end for mro

                  if (ro_ == 'N') {
                      const d1 = nh.charCodeAt(0), d2 = nh_.charCodeAt(0), diff_h = Math.abs(d1 - d2), diff_v = Math.abs(nv - nv_);
                      if ((diff_h == 1 && diff_v == 2) || (diff_h == 2 && diff_v == 1)) { 
                        if (src_.length == 0) {
                               if (oh_ != nh) src_ = oh_; else src_ = ov_;
                        } else
                        if (src_.length == 1) {
                               if (src_ == nh) src_ = src_ + ov_;
                               if (src_ == nv) src_ = oh_ + src_ ;
                        }
                      }
                  }


                } // end if piece.color
              } // end if piece != piece
          } // end if piece null
       } // end for
       return src_;
    }

    function getImgSrc(tag) {
      if (RMOO_PIECES_ == 'rmoo' ) {
        const piece_path = "/images/rmoo_";
        return piece_path + tag + ".svg";
      } else 
      if (RMOO_PIECES_ == 'default' ) {
        const piece_path = "/images/Chess_";
        return piece_path + tag + "45.svg";
      } 
    }

    function targetking(oloc_, color, ocolor, lk, dk) {
       const bullseye = true;
       // the mover (color) and threats from others (ocolor)
       if (color == 'lt' && ocolor == 'dt') { 
          for (var p in lk) {
            if (oloc_ == lk[p]) return bullseye; 
          }
       } else
       if (color == 'dt' && ocolor == 'lt') {
          for (var p in dk) {
            if (oloc_ == dk[p]) return bullseye; 
          }
       }
       return false;
    }

    function bishopThreat(Board, this_, pc, lk, dk) {  // pc is the Bishop
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       var hl = horiz.slice(0, oh - 1).sort(func);
       var hr = horiz.slice(oh, horiz.length);
       const color = this_.color.slice(1);
       const ocolor = pc.color.slice(1);

       var up = ov, down = ov, upblk = false, dnblk = false;
       for (var p in hl) {
          up ++; down --;
          if (up <= 8 && !upblk) {
             const loc_ = (hl[p] + up);
             const bullseye = targetking(loc_, color, ocolor, lk, dk); 
             if (bullseye) return true;
             if (Board[loc_].piece != null) upblk = true; 
          }
          if (down >= 1 && !dnblk) { 
             const loc_ = (hl[p] + down);
             const bullseye = targetking(loc_, color, ocolor, lk, dk); 
             if (bullseye) return true;
             if (Board[loc_].piece != null) dnblk = true; 
          }
           
       }
       var up = ov, down = ov, upblk = false, dnblk = false;
       for (var p in hr) {
          up ++; down --;
          if (up <= 8 && !upblk) {
             const loc_ = (hr[p] + up);
             const bullseye = targetking(loc_, color, ocolor, lk, dk); 
             if (bullseye) return true;
             if (Board[loc_].piece != null) upblk = true; 
          }
          if (down >= 1 && !dnblk) {
             const loc_ = (hr[p] + down);
             const bullseye = targetking(loc_, color, ocolor, lk, dk); 
             if (bullseye) return true;
             if (Board[loc_].piece != null) dnblk = true; 
          }
       }

       return false;
    }

    function rookThreat(Board, this_, pc, lk, dk) { // pc is the Rook
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       var hl = horiz.slice(0, oh - 1).sort(func);
       var hr = horiz.slice(oh, horiz.length);
       var vl = vertical.slice(0, ov - 1).sort(func);
       var vr = vertical.slice(ov, horiz.length);
       const color = this_.color.slice(1);
       const ocolor = pc.color.slice(1);

       var blk = false;
       for (var p in hl) {
          if (!blk)  {
             const loc_ = (hl[p] + ov);
             const bullseye = targetking(loc_, color, ocolor, lk, dk);
             if (bullseye) return true;
             if (Board[loc_].piece != null) blk = true;
          }
       } 
       var blk = false;
       for (var p in hr) {
          if (!blk)  {
             const loc_ = (hr[p] + ov);
             const bullseye = targetking(loc_, color, ocolor, lk, dk);
             if (bullseye) return true;
             if (Board[loc_].piece != null) blk = true;
          }
       } 
       var blk = false;
       var vh = pc.location_[0];
       for (var p in vl) {
          if (!blk)  {
             const loc_ = (vh + vl[p]);
             const bullseye = targetking(loc_, color, ocolor, lk, dk);
             if (bullseye) return true;
             if (Board[loc_].piece != null) blk = true;
          }
       }
       var blk = false;
       var vh = pc.location_[0];
       for (var p in vr) {
          if (!blk)  {
             const loc_ = (vh + vr[p]);
             const bullseye = targetking(loc_, color, ocolor, lk, dk);
             if (bullseye) return true;
             if (Board[loc_].piece != null) blk = true;
          }
       }
       return false;
    }

    function queenThreat(Board, this_, pc, lk, dk) { // pc is the Queen
        const bthreat = bishopThreat(Board, this_, pc, lk, dk);
        const rthreat = rookThreat(Board, this_, pc, lk, dk);
        return bthreat || rthreat;
    }

    function knightThreat(Board, this_, pc, lk, dk) { // pc is the Knight
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       const color = this_.color.slice(1);
       const ocolor = pc.color.slice(1);
       var h = 0, v = 0;

       const hpath = [];
       h = (oh - 1);  v = (ov + 2);
       if (h >= 1 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov + 2);
       if (h <= 8 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh - 1);  v = (ov - 2);
       if (h >= 1 && v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov - 2);
       if (h <= 8 && v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh - 2);  v = (ov + 1);
       if (h >= 1 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh + 2);  v = (ov + 1);
       if (h <= 8 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh - 2);  v = (ov - 1);
       if (h >= 1 && v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 2);  v = (ov - 1);
       if (h <= 8 && v >= 1) hpath.push(horiz[h - 1] + v);

       for (var p in hpath) {
         const loc_ = hpath[p];
         const bullseye = targetking(loc_, color, ocolor, lk, dk);
         if (bullseye) return true;
       }
       return false;
    }

    function kingThreat(Board, this_, pc, lk, dk) {  // pc is the King
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       const color = this_.color.slice(1);
       const ocolor = pc.color.slice(1);
       var h = 0, v = 0;

       const hpath = [];
       h = (oh - 1);  v = (ov + 1);
       if (h >= 1 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh + 0);  v = (ov + 1);
       if (v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov + 1);
       if (h <= 8 && v <= 8) hpath.push(horiz[h - 1] + v);

       h = (oh - 1);  v = (ov);
       if (h >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov);
       if (h <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh - 1);  v = (ov - 1);

       if (h >= 1 && v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 0);  v = (ov - 1);
       if (v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov - 1);
       if (h <= 8 && v >= 1) hpath.push(horiz[h - 1] + v);

       for (var p in hpath) {
         const loc_ = hpath[p];
         const bullseye = targetking(loc_, color, ocolor, lk, dk);
         if (bullseye) return true;
       }
       return false;
    }

    function pawnThreat(Board, this_, pc, lk, dk) { // pc is the Pawn
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       const color = this_.color.slice(1);
       const ocolor = pc.color.slice(1);
       var h = 0, v = 0;

       const hpath = [];
       if (ocolor == 'lt') {
         h = (oh - 1);  v = (ov + 1);
         if (h >= 1 && v <= 8) hpath.push(horiz[h - 1] + v);
         h = (oh + 1);  v = (ov + 1);
         if (h <= 8 && v <= 8) hpath.push(horiz[h - 1] + v);
       } else
       if (ocolor == 'dt') {
         h = (oh - 1);  v = (ov - 1);
         if (h >= 1 && v >= 1) hpath.push(horiz[h - 1] + v);
         h = (oh + 1);  v = (ov - 1);
         if (h <= 8 && v >= 1) hpath.push(horiz[h - 1] + v);
       }

       for (var p in hpath) {
         const loc_ = hpath[p];
         const bullseye = targetking(loc_, color, ocolor, lk, dk);
         if (bullseye) return true;
       }
       return false;
    }


    function  evaluate_king_threat(game, this_, RES) {
          var Board = game.ChessBoard.Board;
          var KL = null, KD = null;
          const lking = [], dking = [];
          const color = this_.color.slice(1);
          for (var p in Board) {
               const pc = Board[p].piece;
               if (pc != null) {
                  if (pc.role == 'K') {
                     if (pc.color_ == 'klt') {
                         KL = pc;
                     } else
                     if (pc.color_ == 'kdt') {
                         KD = pc;
                     }
                  }
               }
          }
          if (game.GAME_STATE.variant == HORDE || game.GAME_STATE.variant == ATOMIC) {
              if (KL == null) return false;
              if (KD == null) return false;
          }
          const nlloc_ = KL.location_, olloc_ = KL.oldlocation_;
          const ndloc_ = KD.location_, odloc_ = KD.oldlocation_;
          if (RES == CASTLELONG || RES == CASTLESHORT) {  // this already considers chess960
              const nlh = nlloc_[0].charCodeAt(0);  const olh = (olloc_ != null) ? olloc_[0].charCodeAt(0) : nlh; 
              const ndh = ndloc_[0].charCodeAt(0);  const odh = (odloc_ != null) ? odloc_[0].charCodeAt(0) : ndh; 
              const nlv = nlloc_[1], olv = (olloc_ != null) ? olloc_[1] : nlv;
              const ndv = ndloc_[1], odv = (odloc_ != null) ? odloc_[1] : ndv;
              const diff_nlh = Math.abs(nlh - olh); const diff_ndh = Math.abs(ndh - odh); 
              const diff_nlv = Math.abs(nlv - olv); const diff_ndv = Math.abs(ndv - odv); 

              if (diff_nlv == 0 && diff_nlh > 0 && this_.color == 'klt') {
                 if (olh < nlh) {
                    for (var i=0; i<=diff_nlh; i++) {
                       const oh_ = horiz[(olh - 97) + i];
                       lking.push(oh_ + nlv);
                    }
                 } else
                 if (olh > nlh) {
                    for (var i=0; i<=diff_nlh; i++) {
                       const oh_ = horiz[(olh - 97) - i];
                       lking.push(oh_ + nlv);
                    }
                 }
              }
              if (diff_ndv == 0 && diff_ndh > 0 && this_.color == 'kdt') {
                 if (odh < ndh) {
                    for (var i=0; i<=diff_ndh; i++) {
                       const oh_ = horiz[(odh - 97) + i];
                       dking.push(oh_ + ndv);
                    } 
                 } else
                 if (odh > ndh) {
                    for (var i=0; i<=diff_ndh; i++) {
                       const oh_ = horiz[(odh - 97) - i];
                       dking.push(oh_ + ndv);
                    } 
                 }
              }
          } 
          if (lking.length == 0) lking.push(nlloc_); 
          if (dking.length == 0) dking.push(ndloc_);

          var threat = false;
          for (var p in Board) {
             const piece = Board[p].piece;
             var bthreat = rthreat = qthreat = nthreat = pthreat = kthreat = false;
             if (piece != null) {   
               if (piece.role == 'B') bthreat = bishopThreat(Board, this_, piece, lking, dking); else
               if (piece.role == 'R') rthreat = rookThreat(Board, this_, piece, lking, dking); else
               if (piece.role == 'Q') qthreat = queenThreat(Board, this_, piece, lking, dking); else
               if (piece.role == 'N') nthreat = knightThreat(Board, this_, piece, lking, dking); else
               if (piece.role == 'P') pthreat = pawnThreat(Board, this_, piece, lking, dking); else
               if (piece.role == 'K') kthreat = kingThreat(Board, this_, piece, lking, dking); 
             }
             threat = threat || bthreat || rthreat || qthreat || nthreat || pthreat || kthreat;
             if (threat) break; /* one threat is good enough */
          }

    // log("Is there a king threat (including castling through / including chess960)?");
    // log(threat);
    return threat;
    }

    function proxyMove(game, pc, loc_, enpassant, castle) {
        const Board = game.ChessBoard.Board;
        const piece = Board[loc_].piece; 
        const isempty = function(x) { return x == null || !(Object.keys(x) || x).length };
        if (castle != null && castle) { // chess960 is already considered
           var king  = pc.pc;
           var rooks = pc.rooks;
           const oloc_ = king.location_;
 
           var piece_dst = { king_dst: null, rook_left_dst: null, rook_right_dst: null }
           piece_dst.king_dst = Board[loc_].piece;  
            

           if (rooks.l_dst) { piece_dst.rook_left_dst  = Board[rooks.l_dst].piece; }
           if (rooks.r_dst) { piece_dst.rook_right_dst  = Board[rooks.r_dst].piece; }

           king.location_ = loc_;
           king.oldlocation_ = oloc_;
           Board[loc_].proxypieces = piece_dst;
           Board[loc_].piece = king;
           if (loc_ != oloc_) Board[oloc_].piece = null; 
           
           if (rooks.l_dst && (loc_ == 'c1' || loc_ == 'c8')) {
                var rook = null;
                if (rooks.l_src != loc_) {
                   rook = Board[rooks.l_src].piece; // if rook is not destination of king
                   rook.location_ = rooks.l_dst;
                   rook.oldlocation_ = rooks.l_src;
                   Board[rooks.l_dst].piece = rook;
                   Board[rooks.l_src].piece = null;
                } else { // we cannot nullify the destination of king.
                   rook = piece_dst.king_dst; // otherwise, get the swapped out rook
                   rook.location_ = rooks.l_dst;
                   rook.oldlocation_ = rooks.l_src;
                   Board[rooks.l_dst].piece = rook; 
                }
           }

           if (rooks.r_dst && (loc_ == 'g1' || loc_ == 'g8')) {
                var rook = null;
                if (rooks.r_src != loc_) {
                   rook = Board[rooks.r_src].piece; // if rook is not destination of king
                   rook.location_ = rooks.r_dst;
                   rook.oldlocation_ = rooks.r_src;
                   Board[rooks.r_dst].piece = rook;
                   Board[rooks.r_src].piece = null;
                } else { // we cannot nullify the destination of king.
                   rook = piece_dst.king_dst; // otherwise, get the swapped out rook
                   rook.location_ = rooks.r_dst;
                   rook.oldlocation_ = rooks.r_src;
                   Board[rooks.r_dst].piece = rook;
                }
           }
        } else
        if (piece == null) { // then we can proxy move ...
           const oloc_ = pc.location_;
           Board[loc_].proxyloc = oloc_; // serves as a pointer
           Board[loc_].piece = pc;
           Board[oloc_].piece = null;
           pc.location_ = loc_;

           if (!isempty(enpassant)) {
              const enp_loc_ = enpassant[loc_];
              if (enp_loc_ != null)  {
                 // make sure it's a pawn.
                 if (Board[enp_loc_].piece != null && Board[enp_loc_].piece.role == 'P') {
                   Board[enp_loc_].enproxy = Board[enp_loc_].piece;
                   Board[enp_loc_].piece = null;
                 }
              }
           }
        } else {  // square is occupied.
           const oloc_ = pc.location_;
           // can we still proxy move by eating it?
           if (pc.color.slice(1) == piece.color.slice(1)) return false; // we cannot eat our own, therefore we are blocked.
           // otherwise, we can eat opponent's piece whether protected or not.
           if (piece.role_ == 'K') return false; // one cannot eat a king.

           // this code segment will give last chance for the opponent to explode our king
           // in the case he is in a checkmate situation.
           if (game.GAME_STATE.variant == ATOMIC) { 
              try {
                explodePieces(game, loc_, true);
              } catch(e) { 
                return false;
              } 
           }
           Board[loc_].proxyloc = oloc_; // serves as a pointer to location
           Board[loc_].proxypiece = Board[loc_].piece; /// serves as pointer to piece
           Board[loc_].piece = pc;
           Board[oloc_].piece = null;
           pc.location_ = loc_;
        }
        return true;
    }

    function unproxyMove(game, pc, loc_, enpassant, castle) {
        const Board = game.ChessBoard.Board;
        const piece = Board[loc_].piece;
        const isempty = function(x) { return x == null || !(Object.keys(x) || x).length };
        if (castle != null && castle) {
           var king = pc.pc;
           var rooks = pc.rooks;
           var proxypieces = Board[loc_].proxypieces;

           if (rooks.l_dst && (loc_ == 'c1' || loc_ == 'c8')) { // left rook
              var rpiece = Board[rooks.l_dst].piece;
              var oloc_ = rpiece.oldlocation_;
              Board[oloc_].piece = rpiece;
              rpiece.location_ = oloc_;
              rpiece.oldlocation_ = null;
              if (proxypieces != null && proxypieces.rook_left_dst != null) 
                   Board[rooks.l_dst].piece = proxypieces.rook_left_dst; else
                   Board[rooks.l_dst].piece = null;
           }

           if (rooks.r_dst && (loc_ == 'g1' || loc_ == 'g8')) { // right rook
              var rpiece = Board[rooks.r_dst].piece;
              var oloc_ = rpiece.oldlocation_;
              Board[oloc_].piece = rpiece;
              rpiece.location_ = oloc_;
              rpiece.oldlocation_ = null;
              if (proxypieces != null && proxypieces.rook_right_dst != null) 
                   Board[rooks.r_dst].piece = proxypieces.rook_right_dst; else
                   Board[rooks.r_dst].piece = null;
           }

           // king
           var oloc_  = king.oldlocation_;
           king.location_ = king.oldlocation_;
           king.oldlocation_ = null;
           Board[oloc_].piece = king;
           if (proxypieces.king_dst != null) { 
                var kpiece = proxypieces.king_dst;
                if (rooks.l_src != loc_ && rooks.r_src != loc_) Board[loc_].piece = kpiece;
           } else
                Board[loc_].piece = null;
     
           delete Board[loc_].proxypieces;

        } else {
           if (piece != null) { // then we can proxy move ...
               const oloc_ = Board[loc_].proxyloc; // serves as a pointer
               Board[oloc_].piece = pc;
               Board[loc_].piece = (Board[loc_].proxypiece != null) ? Board[loc_].proxypiece : null;
               pc.location_ = oloc_;
               delete Board[loc_].proxyloc;
               if (typeof(Board[loc_].proxypiece) != 'undefined') delete Board[loc_].proxypiece;

               if (!isempty(enpassant)) {
                  const enp_loc_ = enpassant[loc_];
                  if (enp_loc_ != null)  {
                     if (typeof(Board[enp_loc_].enproxy) != "undefined") {
                       Board[enp_loc_].piece = Board[enp_loc_].enproxy;
                       delete Board[enp_loc_].enproxy;
                     }
                  }
               }
           }
        }
    }

    function isMobile(game, pc, loc_, enpassant = null, castle = null) { // can we move the piece to loc_ while protecting our king?
        var proxied = false, bullseye = false;
        proxied = proxyMove(game, pc, loc_, enpassant, castle);
        if (proxied) { 
            if (castle) {
               var CASTLE = null;
               const king = pc.pc;
               if (loc_ == 'c1' || loc_ == 'c8') CASTLE = CASTLELONG;
               if (loc_ == 'g1' || loc_ == 'g8') CASTLE = CASTLESHORT;
               bullseye = evaluate_king_threat(game, king, CASTLE);
            } else
            bullseye = evaluate_king_threat(game, pc, CASTLE);
            unproxyMove(game, pc, loc_, enpassant, castle);
        }
        return bullseye;
    }

    function uniquePath(value, index, self) {
        return self.indexOf(value) === index;
    }

    function bishopMobility(game, pc, RES) {
       var Board = game.ChessBoard.Board;
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       var hl = horiz.slice(0, oh - 1).sort(func);
       var hr = horiz.slice(oh, horiz.length);
       const color = pc.color.slice(1);

       var moves = [];
       var up = ov, down = ov;
       for (var p in hl) { // upper-left path
          up ++; 
          if (up <= 8) {
             const loc_ = (hl[p] + up);
             const piece = Board[loc_].piece;
             if (piece != null && color == piece.color.slice(1)) break; // blocked
             const mobile = isMobile(game, pc, loc_);
             if (!mobile) moves.push(loc_);
             if (piece != null) break;
          }
       }
       for (var p in hl) { // lower-left path
          down --;
          if (down >= 1) {
             const loc_ = (hl[p] + down);
             const piece = Board[loc_].piece;
             if (piece != null && color == piece.color.slice(1)) break; // blocked
             const mobile = isMobile(game, pc, loc_);
             if (!mobile) moves.push(loc_);
             if (piece != null) break;
          }
       }
       var up = ov, down = ov;
       for (var p in hr) { // upper-right path
          up ++; 
          if (up <= 8) {
             const loc_ = (hr[p] + up);
             const piece = Board[loc_].piece;
             if (piece != null && color == piece.color.slice(1)) break; // blocked
             const mobile = isMobile(game, pc, loc_);
             if (!mobile) moves.push(loc_);
             if (piece != null) break;
          }
       }
       for (var p in hr) { // lower-right path
          down --;
          if (down >= 1) {
             const loc_ = (hr[p] + down);
             const piece = Board[loc_].piece;
             if (piece != null && color == piece.color.slice(1)) break; // blocked
             const mobile = isMobile(game, pc, loc_);
             if (!mobile) moves.push(loc_);
             if (piece != null) break;
          }
       }
       log("mobility count ...");
       log(moves);
       return moves;
    }

    function rookMobility(game, pc, RES) { 
       var Board = game.ChessBoard.Board;
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       var hl = horiz.slice(0, oh - 1).sort(func);
       var hr = horiz.slice(oh, horiz.length);
       var vl = vertical.slice(0, ov - 1).sort(func);
       var vr = vertical.slice(ov, horiz.length);
       const color = pc.color.slice(1);

       var moves = [];
       for (var p in hl) {
           const loc_ = (hl[p] + ov);
           const piece = Board[loc_].piece;
           if (piece != null && color == piece.color.slice(1)) break; // blocked
           const mobile = isMobile(game, pc, loc_);
           if (!mobile) moves.push(loc_);
           if (piece != null) break;
       }
       for (var p in hr) {
           const loc_ = (hr[p] + ov);
           const piece = Board[loc_].piece;
           if (piece != null && color == piece.color.slice(1)) break; // blocked
           const mobile = isMobile(game, pc, loc_);
           if (!mobile) moves.push(loc_);
           if (piece != null) break;
       }
       var vh = pc.location_[0];
       for (var p in vl) {
           const loc_ = (vh + vl[p]);
           const piece = Board[loc_].piece;
           if (piece != null && color == piece.color.slice(1)) break; // blocked
           const mobile = isMobile(game, pc, loc_);
           if (!mobile) moves.push(loc_);
           if (piece != null) break;
       }
       var vh = pc.location_[0];
       for (var p in vr) {
           const loc_ = (vh + vr[p]);
           const piece = Board[loc_].piece;
           if (piece != null && color == piece.color.slice(1)) break; // blocked
           const mobile = isMobile(game, pc, loc_);
           if (!mobile) moves.push(loc_);
           if (piece != null) break;
       }
       log("mobility count ...");
       log(moves);
       return moves;
    }

    function queenMobility(Board, pc, RES) { 
        const b1 = bishopMobility(Board, pc);
        const b2 = rookMobility(Board, pc);
        return [].concat(b1, b2);
    }

    function knightMobility(game, pc, RES) {
       var Board = game.ChessBoard.Board;
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       const color = pc.color.slice(1);
       var h = 0, v = 0;

       const hpath = [], moves = [];
       h = (oh - 1);  v = (ov + 2);
       if (h >= 1 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov + 2);
       if (h <= 8 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh - 1);  v = (ov - 2);
       if (h >= 1 && v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov - 2);
       if (h <= 8 && v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh - 2);  v = (ov + 1);
       if (h >= 1 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh + 2);  v = (ov + 1);
       if (h <= 8 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh - 2);  v = (ov - 1);
       if (h >= 1 && v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 2);  v = (ov - 1);
       if (h <= 8 && v >= 1) hpath.push(horiz[h - 1] + v);

       for (var p in hpath) {
         const loc_ = hpath[p];
         const piece = Board[loc_].piece;
         if (piece != null && color == piece.color.slice(1)) continue; // blocked
         const mobile = isMobile(game, pc, loc_);
         if (!mobile) moves.push(loc_);
       }
       log("mobility count ...");
       log(moves);
       return moves;
    }

    function kingMobility(game, pc, RES) {
       const Board = game.ChessBoard.Board;
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       const color = pc.color.slice(1);
       var h = 0, v = 0;

       // test one square moves
       const hpath = [], moves = [];
       h = (oh - 1);  v = (ov + 1);
       if (h >= 1 && v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh + 0);  v = (ov + 1);
       if (v <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov + 1);
       if (h <= 8 && v <= 8) hpath.push(horiz[h - 1] + v);

       h = (oh - 1);  v = (ov);
       if (h >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov);
       if (h <= 8) hpath.push(horiz[h - 1] + v);
       h = (oh - 1);  v = (ov - 1);

       if (h >= 1 && v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 0);  v = (ov - 1);
       if (v >= 1) hpath.push(horiz[h - 1] + v);
       h = (oh + 1);  v = (ov - 1);
       if (h <= 8 && v >= 1) hpath.push(horiz[h - 1] + v);


       for (var p in hpath) {
         const loc_ = hpath[p];
         const piece = Board[loc_].piece;
         if (game.GAME_STATE.variant == ATOMIC) {
            if (piece != null) continue; // king cannot capture, therefore, skip any piece that blocks.
         } 
         if (piece != null && color == piece.color.slice(1)) continue; // blocked
         const mobile = isMobile(game, pc, loc_);
         if (!mobile) moves.push(loc_);
       }
       log("mobility count ...");
       log(moves);
       return moves;
    }

    function pawnMobility(game, pc, RES) {
       const Board = game.ChessBoard.Board;
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       const color = pc.color.slice(1);
       var h = 0, v = 0;
       const hpath = [], moves = [], enpassant = {};
       if (color == 'lt') {

         h = (oh);  v = (ov + 1);
         if (v <= 8) { 
             const loc_ = horiz[h - 1] + v;
             const piece = Board[loc_].piece;
             if (piece == null) hpath.push(horiz[h - 1] + v);
         }

         h = (oh);  v = (ov + 2);
         if (v <= 8 && pc.oldlocation_ == null && parseInt(pc.location_[1]) == 2 ) {
             const loc_ = horiz[h - 1] + v;
             const piece = Board[loc_].piece;
             if (piece == null) hpath.push(horiz[h - 1] + v); // initial move to advance two tiles
         }

         h = (oh - 1);  v = (ov + 1);
         if (h >= 1 && v <= 8) {
              const piece = Board[horiz[h-1] + v].piece;
              if (piece != null && piece.color.slice(1) != color) hpath.push(horiz[h - 1] + v);
         }

         h = (oh + 1);  v = (ov + 1);
         if (h <= 8 && v <= 8) {
              const piece = Board[horiz[h-1] + v].piece;
              if (piece != null && piece.color.slice(1) != color) hpath.push(horiz[h - 1] + v);
         }

         // handle enpassant
         h = (oh - 1);  v = (ov);
         if (h >= 1) {
              const piece = Board[horiz[h-1] + v].piece;
              if (piece != null && piece.color.slice(1) != color) {
                 if (piece.oldlocation_ != null && piece.oldlocation_[1] - 0 == 7 && piece.location_[1] == 5) {
                     if (piece.location_ == game.GAME_STATE.lastpiece_.location_) {
                         hpath.push(horiz[h - 1] + 6);
                         enpassant[horiz[h - 1] + 6] = piece.location_;
                     }
                 }
              }
         }
         // handle enpassant
         h = (oh + 1);  v = (ov);
         if (h <= 8) {
              const piece = Board[horiz[h-1] + v].piece;
              if (piece != null && piece.color.slice(1) != color) {
                 if (piece.oldlocation_ != null && piece.oldlocation_[1] - 0 == 7 && piece.location_[1] == 5) {
                     if (piece.location_ == game.GAME_STATE.lastpiece_.location_) {
                         hpath.push(horiz[h - 1] + 6);
                         enpassant[horiz[h - 1] + 6] = piece.location_;
                     }
                 }
              }
         }
       } else
       if (color == 'dt') {
         h = (oh);  v = (ov - 1);
         if (v >= 1) {
             const loc_ = horiz[h - 1] + v;
             const piece = Board[loc_].piece;
             if (piece == null) hpath.push(horiz[h - 1] + v);
         }

         h = (oh);  v = (ov - 2);
         if (v <= 8 && pc.oldlocation_ == null && parseInt(pc.location_[1]) == 7 ) {
             const loc_ = horiz[h - 1] + v;
             const piece = Board[loc_].piece;
             if (piece == null) hpath.push(horiz[h - 1] + v); // initial move to advance two tiles
         }

         h = (oh - 1);  v = (ov - 1);
         if (h >= 1 && v >= 1) {
              const piece = Board[horiz[h-1] + v].piece;
              if (piece != null && piece.color.slice(1) != color) hpath.push(horiz[h - 1] + v);
         }

         h = (oh + 1);  v = (ov - 1);
         if (h <= 8 && v >= 1) {
              const piece = Board[horiz[h-1] + v].piece;
              if (piece != null && piece.color.slice(1) != color) hpath.push(horiz[h - 1] + v);
         }
         // handle enpassant
         h = (oh - 1);  v = (ov);
         if (h >= 1) {
              const piece = Board[horiz[h-1] + v].piece;
              if (piece != null && piece.color.slice(1) != color) {
                 if (piece.oldlocation_ != null && piece.oldlocation_[1] - 0 == 2 && piece.location_[1] == 4) {
                     if (piece.location_ == game.GAME_STATE.lastpiece_.location_) {
                        hpath.push(horiz[h - 1] + 3);
                        enpassant[horiz[h - 1] + 3] = piece.location_;
                     }
                 }
              }
         }
         // handle enpassant
         h = (oh + 1);  v = (ov);
         if (h <= 8) {
              const piece = Board[horiz[h-1] + v].piece;
              if (piece != null && piece.color.slice(1) != color) {
                 if (piece.oldlocation_ != null && piece.oldlocation_[1] - 0 == 2 && piece.location_[1] == 4) {
                     if (piece.location_ == game.GAME_STATE.lastpiece_.location_) {
                         hpath.push(horiz[h - 1] + 3);
                         enpassant[horiz[h - 1] + 3] = piece.location_;
                     }
                 }
              }
         }
       }

       var hpath_ = hpath.filter(uniquePath);
       for (var p in hpath_) {
         const loc_ = hpath_[p];
         const piece = Board[loc_].piece;
         if (piece != null && color == piece.color.slice(1)) continue; // blocked
         const mobile = isMobile(game, pc, loc_, enpassant);
         if (!mobile) moves.push(loc_);
       }

       log("mobility count ...");
       log(moves);
       return moves;
    }


    function kingCastleMobility(game, pc, RES) {
log("ready for king castle mobility ... ------------------------------------->>>>>");
       const Board = game.ChessBoard.Board;
       var func = function(a,b) { return (a < b) ? 1 : -1 };
       var oh = pc.location_[0].charCodeAt(0) - 96;
       var ov = parseInt(pc.location_[1]);
       const color = pc.color.slice(1);
       var h = 0, v = 0;

      // test one square moves
       const hpath = [], moves = [];

       // test castling (this also considers chess960 castling below)
       var chess960 = (game.GAME_STATE.variant == CHESS960);

       // first, find the rooks
       const rl = [], rr = [];
       var r_left_src = null, r_left_dst = null, r_right_src = null, r_right_dst = null, CASTLE = null;
       if (pc.oldlocation == null) { // king has not moved.
           for (var p in Board) {
              const piece = Board[p].piece;
              if (piece != null && piece.role == 'R') {
                 const roh_ = piece.location_[0];
                 const rh_  = roh_.charCodeAt(0) - 96;
                 const rv_  = piece.location_[1] - 0;
                 if (piece.oldlocation_ != null) continue; // rook has moved
                 if (rh_ < oh && rv_ == ov) {  // left side rook
                    if (piece.color == 'rlt' && ov == 1) {
                        rl.push(roh_ + rv_);
                    } else
                    if (piece.color == 'rdt' && ov == 8) {
                        rl.push(roh_ + rv_);
                    }
                 } else  
                 if (rh_ > oh && rv_ == ov) {  // right side rook
                   if (piece.color == 'rlt' && ov == 1) {
                        rr.push(roh_ + rv_);
                   } else
                   if (piece.color == 'rdt' && ov == 8) {
                        rr.push(roh_ + rv_);
                   }
                 }
              }
           }

           // second, find rook path
           const blocked_r = function(Board, color, loc_, chess960 = false) {
              const piece = Board[loc_].piece;
              if (piece != null) {
                 if (chess960) {
                    if (piece.color.slice(1) != color) return true;
                    if (piece.role != 'K') return true;
                 } else return true;
              }
              return false; 
           }

           const blocked_k = function(Board, color, loc_, chess960 = false) {
              const piece = Board[loc_].piece;
              if (piece != null) {
                 if (chess960) {
                    if (piece.color.slice(1) != color) return true;
                    if (piece.role != 'R') return true;
                 } else return true;
              }
              return false; 
           }

           if (chess960) {
              // left rook's path
              var loc_ = null, blocked = false;
              for (var p in rl) {
                 const r_ = rl[p];
                 const rh_  = r_[0].charCodeAt(0) - 96;
                 const rv_  = r_[1] - 0;
                 if (rh_ < 4) {
                    for (var i=rh_  + 1; i <= 4; i++) {
                       loc_ = String.fromCharCode(i + 96) + rv_;
                       if (blocked_r(Board, color, loc_, true)) { blocked = true; break; }
                    }  
                 } else {
                    for (var i=rh_ - 1; i >= 4; i--) {
                       loc_ = String.fromCharCode(i + 96) + rv_;
                       if (blocked_r(Board, color, loc_, true)) { blocked = true; break; }
                    }
                 }
                 if (!blocked && loc_ ==  ((color ==  'lt') ? 'd1' : 'd8')) { r_left_src = r_; r_left_dst = loc_; break }
              }
              // right rook's path
              loc_ = null; blocked = false;
              for (var p in rr) {
                 const r_ = rr[p];
                 const rh_  = r_[0].charCodeAt(0) - 96;
                 const rv_  = r_[1] - 0;
                 if (rh_ > 6) {
                     for (var i=rh_ - 1; i >= 6; i--) {
                       loc_ = String.fromCharCode(i + 96) + rv_;
                       if (blocked_r(Board, color, loc_, true)) { blocked = true; break; }
                     }
                 } else {
                     for (var i=rh_ + 1; i <= 6; i++) {
                       loc_ = String.fromCharCode(i + 96) + rv_;
                       if (blocked_r(Board, color, loc_, true)) { blocked = true; break; }
                     }
                 }
                 if (!blocked && loc_ ==  ((color ==  'lt') ? 'f1' : 'f8')) {  r_right_src = r_; r_right_dst = loc_; break }
              }
              // king's path to long castle
              loc_ = null; blocked = false;
              if (r_left_src != null && r_left_dst != null) {
                 if (pc.location_ == 'c1' || pc.location_ == 'c8') { // in chess960, if king in final dst, move rook for castle
                    hpath.push(pc.location_);
                    CASTLE = true;
                 } else {
                    const diff_k = Math.abs(oh - 3);   
                    var h_ = oh, loc_ = null;
                    for (var i = 1; i <= diff_k; i++) {
                       if (oh < 3) { h_++; } else if (oh > 3) { h_--; } 
                       loc_ = String.fromCharCode(h_ + 96) + ov;
                       if (blocked_k(Board, color, loc_, true)) { blocked = true; break; }
                    }
                    if (!blocked && loc_ ==  ((color ==  'lt') ? 'c1' : 'c8')) { 
                        hpath.push(loc_);
                        CASTLE = true;
                     }
                 } 
              } 

              // king's path to short castle
              loc_ = null; blocked = false;
              if (r_right_src != null && r_right_dst != null) {
                 if (pc.location_ == 'g1' || pc.location_ == 'g8') { // in chess960, if king in final dst, move rook for castle
log("found it here 1 ...");
                    hpath.push(pc.location_);
                    CASTLE = true;
                 } else {
                    const diff_k = Math.abs(oh - 7);
                    var h_ = oh, loc_ = null;
                    for (var i = 1; i <= diff_k; i++) {
                       if (oh < 7) { h_++; } else if (oh > 7) { h_--; }
                       loc_ = String.fromCharCode(h_ + 96) + ov;
                       if (blocked_k(Board, color, loc_, true)) { blocked = true; break; }
                    }
                    if (!blocked && loc_ ==  ((color ==  'lt') ? 'g1' : 'g8')) {
log("found it here 2 ...");
                       hpath.push(loc_);
                       CASTLE = true;
                    }  
                 }
              }
           } else 
           if (pc.location_ == 'e1' || pc.location_ == 'e8') { // standard

              // left rook's path
              var blocked = false;
              for (var p in rl) {
                 const r_ = rl[p];
                 if (rl == 'a1' || rl == 'a8') {
                    const rh_  = r_[0].charCodeAt(0) - 96;
                    const rv_  = r_[1] - 0;
                    var loc_;
                    for (var i= 2; i <= 4; i++) {
                       loc_ = String.fromCharCode(i + 96) + rv_;
                       if (blocked_r(Board, color, loc_)) { blocked = true; break; }
                    }
                    if (!blocked && loc_ ==  ((color ==  'lt') ? 'd1' : 'd8')) { r_left_src = r_; r_left_dst = loc_; break }
                 }
              }
              // right rook's path
              blocked = false;
              for (var p in rr) {
                 const r_ = rr[p];
                 if (r_ == 'h1' || r_ == 'h8') {
                    const rh_  = r_[0].charCodeAt(0) - 96;
                    const rv_  = r_[1] - 0;
                    var loc_;
                    for (var i= 7; i >= 6; i--) {
                       loc_ = String.fromCharCode(i + 96) + rv_;
                       if (blocked_r(Board, color, loc_)) { blocked = true; break; }
                    }
                    if (!blocked && loc_ ==  ((color ==  'lt') ? 'f1' : 'f8')) { r_right_src = r_; r_right_dst = loc_; break }
                 }
              }

              // king's path to long castle
              loc_ = null; blocked = false;
              if (r_left_src != null && r_left_dst != null) {
                 for (var i=4; i>=3; i--) {
                    loc_ = String.fromCharCode(i + 96) + ov;
                    if (blocked_k(Board, color, loc_)) { blocked = true; break; }
                 }
                 if (!blocked && loc_ ==  ((color ==  'lt') ? 'c1' : 'c8')) {
                    hpath.push(loc_);
                    CASTLE = true;
                 }
              }

              // king's path to short castle
              loc_ = null; blocked = false;
              if (r_right_src != null && r_right_dst != null) {
                 for (var i=6; i<=7; i++) {
                    loc_ = String.fromCharCode(i + 96) + ov;
                    if (blocked_k(Board, color, loc_)) { blocked = true; break; }
                 }
                 if (!blocked && loc_ ==  ((color ==  'lt') ? 'g1' : 'g8')) {
                    hpath.push(loc_);
                    CASTLE = true;
                 }
              }
           }
       }
       const rooks = { l_src: r_left_src, l_dst: r_left_dst, r_src: r_right_src, r_dst: r_right_dst };
log("paths ...");
log(hpath);
       for (var p in hpath) {
         const loc_ = hpath[p];
         const piece = Board[loc_].piece;
         if (chess960) {
            if (piece != null && color == piece.color.slice(1))
            if (piece.role_ != 'R' && piece.role_ != 'K') continue; // blocked
         } else 
         if (piece != null && color == piece.color.slice(1)) continue; // blocked
         const mobile = isMobile(game, {pc: pc, rooks: rooks}, loc_, false, CASTLE);
         if (!mobile) moves.push(loc_);
       }
       log("mobility count ...");
       log(moves);
       return moves;
    }

    function pieceMobility(game, piece, RES) {
        const Board = game.ChessBoard.Board;
log("piece mobility ...");
log(piece);
        var moves = [], ptype = piece.role;
        if (ptype == 'B') moves = bishopMobility(game, piece, RES); else
        if (ptype == 'R') moves = rookMobility(game, piece, RES); else
        if (ptype == 'Q') moves = queenMobility(game, piece, RES); else
        if (ptype == 'N') moves = knightMobility(game, piece, RES); else
        if (ptype == 'P') moves = pawnMobility(game, piece, RES); else
        if (ptype == 'K') {
             moves = kingMobility(game, piece, RES); 
             const cmoves = kingCastleMobility(game, piece, RES); 
             moves = [].concat(moves,cmoves);
        }
log("ok mobility :");
log(moves);
        return moves;
    }

    function assertMobility(game, this_, RES) {
       const Board = game.ChessBoard.Board;
       const variant = game.GAME_STATE.variant;
       const lastpiece_ = this_;
       var color = lastpiece_.color.slice(1); 
      
       // evaluate if our opponent is under check
       // choose king piece as basis
       var opponent_threat = false;
       var opp_color = (color == 'lt') ? 'dt' : 'lt'; 
       for (var p in Board) {
          const piece = Board[p].piece;
          if (piece != null) {
              if (piece.role_ == 'K' && opp_color == piece.color.slice(1)) {
                    opponent_threat = evaluate_king_threat(game, piece, GOODMOVE);
                    break;
              }
          }
       } 

       // Now check mobility and pieces
       const pcount = function(role, prole, color, pcolor) {
           return (role == prole && color == pcolor) ? 1 : 0;
       }
       const LT = { Q: 0, R: 0, N: 0, B: 0, P: 0 }, DT = { Q: 0, R: 0, N: 0, B: 0, P: 0 };
       var moves = [], KD = false, KL = false;
       for (var p in Board) {
          const piece = Board[p].piece;
          if (piece != null) {
             const pcolor = piece.color.slice(1);
             if (piece.role_ == 'K') {
                  if (piece.color_ == 'klt') KL = true;
                  if (piece.color_ == 'kdt') KD = true;
             }
             if (color != pcolor) { // check mobility for the other color.
                log(piece.role);
                log(piece.color);
                const pmoves = pieceMobility(game, piece, RES);
                moves = [].concat(moves, pmoves);
log(piece);
log(pmoves);
             }
             LT.Q += pcount(piece.role, 'Q', pcolor, 'lt'); LT.R += pcount(piece.role, 'R', pcolor, 'lt');
             LT.N += pcount(piece.role, 'N', pcolor, 'lt'); LT.B += pcount(piece.role, 'B', pcolor, 'lt');
             LT.P += pcount(piece.role, 'P', pcolor, 'lt');
             DT.Q += pcount(piece.role, 'Q', pcolor, 'dt'); DT.R += pcount(piece.role, 'R', pcolor, 'dt');
             DT.N += pcount(piece.role, 'N', pcolor, 'dt'); DT.B += pcount(piece.role, 'B', pcolor, 'dt');
             DT.P += pcount(piece.role, 'P', pcolor, 'dt');
          }
       }
log("total mobility: ");
log(moves.length);
log(moves);
log("the opponent is under check ? ...");
log(opponent_threat);

       game.GAME_STATE.gameover_ = 0;
       const opponent = (color == 'lt') ? BLACK: WHITE;

       if (moves.length == 0) {  // zero mobility - nothing to move.
           if (opponent_threat) {
                game.GAME_STATE.checkmate_ = true;
                game.GAME_STATE.stalemate_ = false;
                game.GAME_STATE.gameover_ = GAMEOVER.CHECKMATE;
                game.GAME_STATE.checkmateside_ = game.GAME_STATE.gameoverside_ = opponent;
           } else {
                if (variant == ATOMIC) {
                  if (KL == false || KD == false) { // one of the king exploded, which one is already taken care during capture
                     game.GAME_STATE.gameover_ = GAMEOVER.ATOMIC;
                     game.GAME_STATE.gameoverside_ = opponent;
                  }
                } else
                if (variant == HORDE) {
                   game.GAME_STATE.checkmate_ = false;
                   game.GAME_STATE.stalemate_ = false;
                   game.GAME_STATE.gameover_ = GAMEOVER.HORDE;
                   game.GAME_STATE.stalemateside_ = game.GAME_STATE.gameoverside_ = opponent;
                } else {
                   game.GAME_STATE.checkmate_ = false;
                   game.GAME_STATE.stalemate_ = true;
                   game.GAME_STATE.gameover_ = GAMEOVER.STALEMATE;
                   game.GAME_STATE.stalemateside_ = game.GAME_STATE.gameoverside_ = opponent;
                }
           }
       } else {
           const our_threat = evaluate_king_threat(game, this_, RES); // lastpiece moved
           if (our_threat) { illegal_move( "Move is endangering its own king!"); }

           if (variant == KINGOFTHEHILL) { // whoever gets to the center squares wins the game.
               if (this_.role_ == 'K') {
                  var loc_ = this_.location_;
                  if (loc_ == 'd4' || loc_ == 'd5' || loc_ == 'e4' || loc_ == 'e5') {
                      game.GAME_STATE.gameover_ = GAMEOVER.KINGOFTHEHILL;
                      game.GAME_STATE.gameoverside_ = opponent;
                  }
              }
           } else
           if (variant == THREECHECKS) { // three checks are enough to win.
               if (opponent_threat) assertThreeChecks(game, opp_color, opponent);
           } else
           if (variant == ATOMIC) {
               if (KL == false || KD == false) { // one of the king exploded, which one is already taken care during capture
                  game.GAME_STATE.gameover_ = GAMEOVER.ATOMIC;
                  game.GAME_STATE.gameoverside_ = opponent;
               }
           } else
           if (opponent_threat) {
              game.GAME_STATE.checkking_ = true;
              game.GAME_STATE.checkkingside_ = opponent;
           }
       }

       if (!game.GAME_STATE.gameover_) {
           var draw_ = true;
           if ( LT.P > 0 || LT.P > 0) draw_ = false; else
           if (!( LT.R == 0 && LT.Q == 0 && DT.R == 0 && DT.Q == 0 && LT.P == 0 && DT.P == 0)) draw_ = false;
           if (LT.B == 2 || DT.B == 2) draw_ = false;
           if (LT.N > 0 && LT.B > 0) draw_ = false;
           if (DT.N > 0 && DT.B > 0) draw_ = false;
           game.GAME_STATE.drawinsufficient_ = draw_;
           game.GAME_STATE.gameover_ = (draw_) ? GAMEOVER.INSUFFICIENT : 0;
       }

    }

    function assertThreeChecks(game, opp_color, opponent) {
        const tbox = game.tbox;        
        const Undo = game.Undo_;
        const threechecks = tbox.threechecks_;
        const threes = threechecks.getElementsByTagName('span');
        var tid = null, score = 0;
        if (opp_color == 'lt') {
           score = ++game.GAME_STATE.wchecks;
        } else {
           score = ++game.GAME_STATE.bchecks;
        }
        tid = 'pcaptureid_k' + opp_color + score;
        for (var p in threes) {
           const three = threes[p];
           if (three.nodeType == 1) {
               if (tid == three.id) {
                   three.style.visibility = 'visible';
                   var undo = Undo[Undo.length - 1];
                   undo.threespan = three;
                   if (score == 3) {
                      game.GAME_STATE.gameover_ = GAMEOVER.THREECHECKS;
                      game.GAME_STATE.gameoverside_ = opponent;
                   }
               }
           }
        }
    }

    function take_piece(Board, location, color, code) {
        if (Board[location].piece != null ) { // Check if something to eat!
                 var piece_ = Board[location].piece;
                 if (piece_.color_.match(color)) {
                     if (piece_.role == 'K') {
                       illegal_move("Cannot eat king!");
                     } else
                     return EATPIECE;
                 }
         }
         illegal_move("Illegal move " + code + "!");
    }

    function assertMove(game, pclass, location, promote) {
         const Board = game.ChessBoard.Board;
         const LASTPIECE_ = game.GAME_STATE.lastpiece_;
         const this_ = pclass;
         const locations = { oh: this_.location_[0], ov: parseInt(this_.location_[1]),
                             nh: location[0],       nv: parseInt(location[1]) }
         // assert Promotion
         if (promote != null || promote != null) {
             if (this_.role.match(/[QKRNB]/g)) illegal_move("Illegal promotion ..."); 
             if (this_.color=='plt' && locations.nv != 8) illegal_move("Illegal promotion (11) ...");
             if (this_.color=='pdt' && locations.nv != 1) illegal_move("Illegal promotion (12) ...");
         } 
         if (this_.role_ == "K") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);

            // after determining rook, we get the final destinations
            var ov = (this_.color == 'klt') ? 1 : 8;

            // assert Castling
            // Search for the rooks' location and get the distance
            var CASTLE = null;
            var r1 = null, r2 = null, r1h = null, r2h = null;
            var r1d = 'd'.charCodeAt(0), r2d = 'f'.charCodeAt(0);
            for (var i=0; i<8; i++) {
                var oh = horiz[i]; 
                if (this_.color == 'klt') {
                    var rk = Board[oh + '1'].piece;
                    if (rk == null) continue;
                    if (rk.role == 'R' && rk.color == 'rlt') {
                        var rh = rk.location_[0].charCodeAt(0);
                        if (rh < this_oh) { r1 = rk; r1h = rh; } // left side of king
                        if (rh > this_oh) { r2 = rk; r2h = rh; } // right side of king
                    }   
                } else
                if (this_.color == 'kdt') {
                    var rk = Board[oh + '8'].piece;
                    if (rk == null) continue;
                    if (rk.role == 'R' && rk.color == 'rdt') {
                        var rh = rk.location_[0].charCodeAt(0);
                        if (rh < this_oh) { r1 = rk; r1h = rh; } // left side of king
                        if (rh > this_oh) { r2 = rk; r2h = rh; } // right side of king
                    }   
                }
            }


            const diff_rh1 = Math.abs(r1h - r1d); 
            const diff_rh2 = Math.abs(r2h - r2d); 

            // Get the king's distance
            var k1d = 'c'.charCodeAt(0), k2d = 'g'.charCodeAt(0);
            const diff_kh1 = Math.abs(this_oh - k1d); 
            const diff_kh2 = Math.abs(this_oh - k2d); 
            
            var chess960 = (game.GAME_STATE.variant == CHESS960);
            var loc_ = locations.nh + locations.nv;
log("which variation???");
log(chess960);
            if (chess960) {
                // King needs to land to a rook's location from ui perspective
                var pc = Board[loc_].piece;
log("one 1 ...");
                if (pc != null && pc.role_ == 'R') {
                     if (r1 != null && pc.location_ == r1.location_) CASTLE = CASTLELONG;
                     if (r2 != null && pc.location_ == r2.location_) CASTLE = CASTLESHORT;
                } else // or to one of the castle destinations by two steps
                if (this_.color == 'klt' && (loc_ == 'c1' || loc_ == 'g1')) {
log("one 2 ...");
                    if (loc_ == 'c1' && diff_kh1 == 2) CASTLE = CASTLELONG; 
                    if (loc_ == 'g1' && diff_kh2 == 2) CASTLE = CASTLESHORT; 
                } else
                if (this_.color == 'kdt' && (loc_ == 'c8' || loc_ == 'g8')) {
log("one 3 ...");
                    if (loc_ == 'c8' && diff_kh1 == 2) CASTLE = CASTLELONG; 
                    if (loc_ == 'g8' && diff_kh2 == 2) CASTLE = CASTLESHORT; 
                }
            } else { 
                // by standard, castle destinations by two steps
                if (this_.color == 'klt' && (loc_ == 'c1' || loc_ == 'g1')) {
log("one 4 ...");
                    if (loc_ == 'c1' && diff_kh1 == 2) CASTLE = CASTLELONG; 
                    if (loc_ == 'g1' && diff_kh2 == 2) CASTLE = CASTLESHORT; 
                } else
                if (this_.color == 'kdt' && (loc_ == 'c8' || loc_ == 'g8')) {
log("one 5 ...");
                    if (loc_ == 'c8' && diff_kh1 == 2) CASTLE = CASTLELONG; 
                    if (loc_ == 'g8' && diff_kh2 == 2) CASTLE = CASTLESHORT; 
                }
            }

            // validate king and rook moves.
            if (this_.oldlocation_ != null) CASTLE = null;
            if (r1 != null && r1.oldlocation_ != null && CASTLE == CASTLELONG)  CASTLE = null;
            if (r2 != null && r2.oldlocation_ != null && CASTLE == CASTLESHORT) CASTLE = null;

            if (CASTLE != null) {

               const diff_kh  = (CASTLE == CASTLELONG) ? diff_kh1 : diff_kh2;
               const this_kh_ = (CASTLE == CASTLELONG) ? k1d : k2d;
               // check obstruction (king's path)
               for (let i=1; i <= diff_kh; i++) {
                  var oh = String.fromCharCode(this_oh);
                  if (this_oh < this_kh_) {
                        oh = String.fromCharCode(this_oh + i);
                  } else
                  if (this_oh > this_kh_) {
                        oh = String.fromCharCode(this_oh - i);
                  } else {
                        illegal_move("Illegal move (961k)!");
                  }
                  var pc = Board[oh + ov];
                  if (pc != null && pc.piece != null) {
                        const pc = Board[oh + ov].piece;
                        if (chess960)
                        if (pc.role_ == 'R' && pc.color.slice(1) == this_.color.slice(1) && pc.oldlocation_ == null) continue;
                        illegal_move("Illegal move (962k)!");
                  }
               }

               const this_roh = (CASTLE == CASTLELONG) ? r1h : r2h;
               const diff_rh  = (CASTLE == CASTLELONG) ? diff_rh1 : diff_rh2;
               const this_rh_ = (CASTLE == CASTLELONG) ? r1d : r2d;

               // check obstruction (rook's path)
               for (let i=1; i <= diff_rh; i++) {
                  var oh = String.fromCharCode(this_roh);
                  if (this_roh < this_rh_) {
                        oh = String.fromCharCode(this_roh + i);
                  } else
                  if (this_roh > this_rh_) {
                        oh = String.fromCharCode(this_roh - i);
                  } else {
                        illegal_move("Illegal move (963k)!");
                  }
                  if (Board[oh + ov].piece != null) {
                        const pc = Board[oh + ov].piece;
                        if (chess960)
                        if (pc.role_ == 'K' && pc.color.slice(1) == this_.color.slice(1)) continue;
                        illegal_move("Illegal move (964k)!");
                  }
                }
                return CASTLE;
            } else { // no castling, just normal king move
                const diff_v = Math.abs(locations.ov - locations.nv);
                const diff_h = Math.abs(this_nh - this_oh);
                if ((diff_v == 0 && diff_h == 1) || (diff_h == 0 && diff_v == 1) || (diff_v == diff_h && diff_v == 1)) {
                   if (game.GAME_STATE.variant == ATOMIC) {
                      if (Board[location].piece != null ) { // king cannot capture.
                          illegal_move("King cannot capture in atomic games.");
                      }
                   }
                   if (Board[location].piece != null ) { // Check if something to eat!
                        if (this_.color_ == "klt") {
                            return take_piece(Board, location, /dt$/, '22');
                        } else
                        if (this_.color_ == "kdt") {
                            return take_piece(Board, location, /lt$/, '21');
                        }
                   } else {
                        return GOODMOVE;
                   }
                 } else { illegal_move("Illegal move (20)!"); }
            }
            return UNMOVE;
         } else // Queen
         if (this_.role_ == "Q") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h > 0) ||
                (diff_h == 0 && diff_v > 0) ||
                (diff_v == diff_h && diff_v != 0)) {

                // check bishop-like obstruction
                if (diff_v == diff_h && diff_v != 0)
                for (let i=1; i < diff_v; i++) {
                  var oh = null, ov = null;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else {
                     oh = String.fromCharCode(this_oh - i);
                  }
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else {
                     ov = locations.ov - i;
                  }
                  if (Board[oh + ov].piece != null) {
                     illegal_move("Illegal move (33)!");
                  }
                }

                // check root-like obstruction
                if ((diff_v == 0 && diff_h > 0) ||
                   (diff_h == 0 && diff_v > 0))
                for (let i=1; i < ( (diff_v < diff_h) ? diff_h : diff_v ); i++) {
                  var oh = String.fromCharCode(this_oh), ov = locations.ov;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else
                  if (this_oh >this_nh) {
                     oh = String.fromCharCode(this_oh - i);
                  } else
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else
                  if (locations.ov > locations.nv) {
                     ov = locations.ov - i;
                  } else {
                     illegal_move("Illegal move (34)!");
                  }
                  if (Board[oh + ov].piece != null) {
                     illegal_move("Illegal move (35)!");
                  }
                }


                if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "qlt") {
                         return take_piece(Board, location, /dt$/, '18');
                      } else
                      if (this_.color_ == "qdt") {
                         return take_piece(Board, location, /lt$/, '19');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (17)!"); }
         } else // Rook
         if (this_.role_ == "R") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if ((diff_v == 0 && diff_h > 0) ||
                (diff_h == 0 && diff_v > 0)) {

                // check rook obstruction
                for (let i=1; i < ( (diff_v < diff_h) ? diff_h : diff_v ); i++) {
                  var oh = String.fromCharCode(this_oh), ov = locations.ov;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else
                  if (this_oh >this_nh) {
                     oh = String.fromCharCode(this_oh - i);
                  } else
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else
                  if (locations.ov > locations.nv) {
                     ov = locations.ov - i;
                  } else {
                     illegal_move("Illegal move (31)!");
                  }
                  if (Board[oh + ov].piece != null) {
                     illegal_move("Illegal move (32)!");
                  }
                }
                if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "rlt") {
                         return take_piece(Board, location, /dt$/, '15');
                      } else
                      if (this_.color_ == "rdt") {
                         return take_piece(Board, location, /lt$/, '16');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (14)!"); }
         } else // Bishop
         if (this_.role_ == "B") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            const aha1 = String.fromCharCode(this_oh);
            const aha2 = String.fromCharCode(this_nh);
            const diff_v = Math.abs(locations.ov - locations.nv);
            const diff_h = Math.abs(this_nh - this_oh);
            if (diff_v == diff_h && diff_v != 0) {
                // check bishop obstruction
                for (let i=1; i < diff_v; i++) {
                  var oh = null, ov = null;
                  if (this_oh < this_nh) {
                     oh = String.fromCharCode(this_oh + i);
                  } else {
                     oh = String.fromCharCode(this_oh - i);
                  }
                  if (locations.ov < locations.nv) {
                     ov = locations.ov + i;
                  } else {
                     ov = locations.ov - i;
                  }
                  if (Board[oh + ov].piece != null) {
                     illegal_move("Illegal move (31)!");
                  }
                }
                if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "blt") {
                         return take_piece(Board, location, /dt$/, '12');
                      } else
                      if (this_.color_ == "bdt") {
                         return take_piece(Board, location, /lt$/, '13');
                      }
                } else {
                       return GOODMOVE;
                }
            }
            else { illegal_move("Illegal move (11)!"); }

         } else // if Knight
         if (this_.role_ == "N") {
            const this_nh = locations.nh.charCodeAt(0);
            const this_oh = locations.oh.charCodeAt(0);
            if (locations.ov + 2 == locations.nv ||
                locations.ov == locations.nv + 2) {
                if (this_nh == this_oh + 1 || this_nh + 1 == this_oh) {
                   if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "nlt") {
                         return take_piece(Board, location, /dt$/, '8');
                      } else
                      if (this_.color_ == "ndt") {
                         return take_piece(Board, location, /lt$/, '9');
                      }
                   } else {
                       return GOODMOVE;
                   }
                } else { return take_piece(Board, location, "na", "5"); }
            } else
            if (this_nh + 2 == this_oh ||
                this_nh == this_oh + 2) {
                if (locations.nv == locations.ov + 1 || locations.nv + 1 == locations.ov) {
                   if (Board[location].piece != null ) { // Check if something to eat!
                      if (this_.color_ == "nlt") {
                         return take_piece(Board, location, /dt$/, '10');
                      } else
                      if (this_.color_ == "ndt") {
                         return take_piece(Board, location, /lt$/, '11');
                      }
                   } else {
                       return GOODMOVE;
                   }
                } else { return take_piece(Board, location, "na", "6"); }
            }
            else { return take_piece(Board, location, "na", "7"); }
         } else // if Pawn
         if (this_.role_ == "P") {
             if (locations.oh == locations.nh) {
               if (this_.color_ == "plt") {
                  if (( locations.ov == 2 && ( locations.nv == 3 || locations.nv == 4 ))) {
                     // check obstruction
                     if (locations.nv == 3 && Board[locations.oh + 3].piece != null) {
                          illegal_move("Illegal move (40)!");
                     } else
                     if (locations.nv == 4 && ( Board[locations.oh + 3].piece != null ||
                                                Board[locations.oh + 4].piece != null )) {
                          illegal_move("Illegal move (41)!");
                     }
                     return GOODMOVE;
                  } else if (locations.ov >= 3 && locations.ov + 1 == locations.nv && locations.nv <= 8) {
                     if ( Board[locations.oh + locations.nv].piece != null) {
                          illegal_move("Illegal move (42)!");
                     }
                     return GOODMOVE;
                  } else {
                     const horde = (game.GAME_STATE.variant == HORDE);
log("moving a pawn ...");
log(horde);
                     if (horde && locations.ov == 1 && locations.nv == 2) return GOODMOVE; // allow move from rank 1
                     illegal_move("Illegal pawn move (42a)!");
                  }
                } else {
                  if (( locations.ov == 7 && ( locations.nv == 6 || locations.nv == 5 ))) {
                     // check obstruction
                     if (locations.nv == 6 && Board[locations.oh + 6].piece != null) {
                          illegal_move("Illegal move (43)!");
                     } else
                     if (locations.nv == 5 && ( Board[locations.oh + 6].piece != null ||
                                                Board[locations.oh + 5].piece != null )) {
                          illegal_move("Illegal move (44)!");
                     }
                     return GOODMOVE;
                  } else if (locations.ov <= 6 && locations.ov - 1 == locations.nv && locations.nv >= 1) {
                     if ( Board[locations.oh + locations.nv].piece != null) {
                          illegal_move("Illegal move (45)!");
                     }
                     return GOODMOVE;
                  } else {
                     const horde = (game.GAME_STATE.variant == HORDE);
log(horde);
                     if (horde && locations.ov == 8 && locations.nv == 7) return GOODMOVE; // allow move from rank 8
                     illegal_move("Illegal pawn move (45a)!");
                  }
                }
             } else { // (locations.oh != locations.nh) -- diagonal means eat
                 const this_nh = locations.nh.charCodeAt(0);
                 const this_oh = locations.oh.charCodeAt(0);
                 const diff_h = Math.abs(this_nh - this_oh);
                 const diff_v = Math.abs(locations.ov - locations.nv);
                 if (diff_h > 1 || diff_v > 1) { illegal_move("Illegl pawn move (47)!"); }
                 if (Board[location].piece != null) { // something to eat?
                   if (this_.color_ == "plt") {
                      if (locations.ov < locations.nv) {
                        return take_piece(Board, location, /dt$/,'48');
                      } else { illegal_move("Illegal move(54)"); }
                    } else {
                      if (locations.ov > locations.nv) {
                         return take_piece(Board, location, /lt$/,'49');
                      } else { illegal_move("Illegal move(55)"); }

                    }
                 } else { // en passant?
                    log("en passant!!!");
                    if (LASTPIECE_ != null) {
                        const that = LASTPIECE_;
                        const that_location = { nh: that.location_[0], nv: parseInt(that.location[1]),
                                                oh: that.oldlocation[0], ov: parseInt(that.oldlocation[1]) }
                        const this_nh = locations.nh.charCodeAt(0);
                        const this_oh = locations.oh.charCodeAt(0);
                        const that_nh = that_location.nh.charCodeAt(0);
                        const that_oh = that_location.oh.charCodeAt(0);
                        const diff_v = Math.abs(that_location.ov - that_location.nv);
                        const diff_h = Math.abs(that_nh - this_nh);
                        if (that_oh != that_nh || that.role != 'P' ||
                            diff_v != 2 || diff_h != 0 || that_location.nv != locations.ov )
                                { illegal_move("Illegal move(53)"); }

                        if (this_.color_ == "plt") {
                            if (locations.ov < locations.nv) {
                                return ENPASSANT;
                            } else { illegal_move("Illegal move(56)"); }
                        } else {
                            if (locations.ov > locations.nv) {
                                return ENPASSANT;
                             } else { illegal_move("Illegal move(57)"); }
                        }
                    } else {
                       illegal_move("Illegal pawn move (52)!");
                    }
                 }
             }
         }
         return UNMOVE;
    }

    function getImage(dv) {
       const img = dv.getElementsByClassName("chessimg")[0];
       return img;
    }

    function restoreBoardPiece(board, src, width, height) {
        try {
           var img = getImage(board.td_);
           if (img == null) {
               img = document.createElement('img');
               img.className = "chessimg";
               img.src = src;
               img.style.width = width + 'px';
               img.style.height = height + 'px';
               board.td_.appendChild(img);
               return img;
           }
        } catch(e) {} // no child to remove
        return null;
    }

    function removeBoardPiece(board) {
        try {
           const img = getImage(board.td_);
           if (img != null) board.td_.removeChild(img);
        } catch(e) {} // no child to remove
    }

    function swapPiece(game, pc1, pc2) {
        var Board = game.ChessBoard.Board;
        var loc1 = pc1.location_, loc2 = pc2.location_;
        var board1 = Board[loc1], board2 = Board[loc2];
        var piece1 = board1.piece, piece2 = board2.piece;
        board1.piece = piece2;
        board2.piece = piece1;
        board1.td_.appendChild(piece2.img_);
        board2.td_.appendChild(piece1.img_);
        piece1.oldlocation_ = loc1;
        piece1.location_    = loc2;
        piece2.oldlocation_ = loc2;
        piece2.location_    = loc1;
    }

    function placePiece(game, loc_, this_) {
        var Board = game.ChessBoard.Board;
        var board = Board[loc_];
        var tbox  = game.tbox;
        var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
        var board_ui = Board[rloc_];
        removeBoardPiece(board_ui);
        board.piece = this_;
        board_ui.td_.appendChild(this_.img_);
    }

    function nullPiece(game, loc_) {
         var Board = game.ChessBoard.Board;
         var board = Board[loc_];
         board.piece = null;
    }

    function emptyCell(game, loc_) {
        var Board = game.ChessBoard.Board;
        var tbox  = game.tbox;
        var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
        var board_ui = Board[rloc_];
        removeBoardPiece(board_ui);
        nullPiece(game, loc_);
    }

    function explodePieces(game, loc_, check_exploding_king = false) {
         var Board = game.ChessBoard.Board;
         var tbox  = game.tbox;
         var piece = Board[loc_].piece;
         var color = piece.color_.slice(1);
         var oh = loc_[0].charCodeAt(0) - 96;
         var ov = parseInt(loc_[1]);
         var h = 0, v = 0;
         var pieces = [], paths = [];

         h = (oh - 1);  v = (ov - 1);  
         if (h >= 1 && v >= 1) paths.push({h: h, v: v});
         h = (oh );  v = (ov - 1);
         if (v >= 1) paths.push({h: h, v: v});
         h = (oh + 1);  v = (ov - 1);
         if (h <= 8 && v >= 1) paths.push({h: h, v: v});
         h = (oh - 1);  v = (ov);
         if (h >= 1) paths.push({h: h, v: v});
         h = (oh + 1);  v = (ov);
         if (h <= 8) paths.push({h: h, v: v});
         h = (oh + 1);  v = (ov + 1);
         if (h <= 8 && v <= 8) paths.push({h: h, v: v});
         h = (oh);  v = (ov + 1);
         if (v <= 8) paths.push({h: h, v: v});
         h = (oh - 1);  v = (ov + 1);
         if (h >= 1 && v <= 8) paths.push({h: h, v: v}); 
         h = (oh);  v = (ov);
         paths.push({h: h, v: v});


         for (var p in paths) {
            const pt = paths[p];
            var ploc_ = horiz[pt.h - 1] + pt.v;
            var epiece = Board[ploc_].piece; 
            if (epiece != null) {
                if (epiece.role_ == 'K' && color == epiece.color.slice(1)) { // cannot explode our own king
                   return illegal_move("cannot explode owns king.");
                }
            }
         }
 
         if (check_exploding_king) return null; // we just need to check exploding king, no explosions required.

         // explode the center first
         var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
         var board_ui = Board[rloc_];
         const img = getImage(board_ui.td_);
         img.expsrc = img.src;
         img.src = ATOMIC_IMG;
         Board[loc_].piece = null;

         for (var p in paths) {
            const pt = paths[p];
            var ploc_ = horiz[pt.h - 1] + pt.v;
            var piece = Board[ploc_].piece; 
            if (piece != null) {
                if (ploc_ == loc_) {
                   pieces.push(piece); // the center
                }
                if (piece.role_ != 'P' && piece.role_ != 'K') {
                   pieces.push(piece);
                   emptyCell(game, ploc_); // only clear the board
                } else
                if (piece.role_ == 'K' && color != piece.color.slice(1)) { // this one is game over.
                   pieces.push(piece);
                   emptyCell(game, ploc_); // only clear the board
                } 
            } 
         }
log("exploded ********************************************************** ...");
log(pieces);
         return pieces;
    }

    function cleanLastExplosion(Board, tbox, Undo) { // for atomic games.
         var undo = Undo[Undo.length - 1];
         if (undo != null) {
         var piece = undo.piece;
     log("clean explosion ..."); 
     log(piece.img_.src);
     log(piece.img_.expsrc);
            if (piece.img_.expsrc != null) {
log("now ready to clean ...");
               var loc_ = piece.location_;
log(loc_);
               var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
log(rloc_);
               var board_ui = Board[rloc_];
               piece.img_.src = piece.img_.expsrc;
log(piece.img_.expsrc);
log(board_ui);
               removeBoardPiece(board_ui);
            }
         }
    }


    function move(game, pclass, what) {
log("moving piece: " + what);
         const Board = game.ChessBoard.Board;
         const Benched = game.ChessBoard.Bench;
         const tbox = game.ChessBoard.tbox;
         const this_ = pclass;
         const promote = what.promote;
         const Undo = game.Undo_;
         const GAME_STATE = game.GAME_STATE;
         var location = what.location;
         var LASTPIECE_ = GAME_STATE.lastpiece_;
         const RES = assertMove(game, pclass, location, promote);
         if (game.GAME_STATE.variant == ATOMIC) {
             cleanLastExplosion(Board, tbox, Undo);
         }
         if (RES == ENPASSANT) {
                  var len = Benched.length;
                  this_.restype_ = RES;
                  Benched.push ( LASTPIECE_ );
                  placePiece(game, location, this_);
                  nullPiece(game, this_.location_);
                  nullPiece(game, LASTPIECE_.location_);
                  var rloc_ = (tbox.reversed_) ? reverseLoc(LASTPIECE_.location_) : LASTPIECE_.location_;
                  var board_ui = Board[rloc_];
                  removeBoardPiece(board_ui);
                  var undo =  { type: RES, color: this_.color_, piece: this_, benched: LASTPIECE_,
                                oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ };
                  Undo.push(undo);
                  if (GAME_STATE.variant == ATOMIC ) {
                      var explodedpieces = null;
                      explodedpieces = explodePieces(game, location);
                      if (explodedpieces != null) undo.explodedpieces = explodedpieces;
                  }
                  sortBenchedPieces();
         } else
         if (RES == EATPIECE) {
                  var len = Benched.length;
                  var pc =  Board[location].piece;
                  this_.restype_ = RES;
                  Benched.push ( pc );
                  if (GAME_STATE.variant == CRAZYHOUSE ) {
                       if (typeof(pc.promoted_to) != "undefined") {
                          var color = pc.color.slice(1);
                          pc.role_ = 'P';  pc.color_ = (color == 'lt') ? 'plt' : 'pdt';  // updates pc being a pointer saved in Bench.
                       }
                  } 
                  if (promote != null && promote != "") { 
                       this_.role_ = promote;
                       this_.color_ =  (this_.color_ == 'plt') ? promote.toLowerCase() + 'lt' : promote.toLowerCase() + 'dt';
                       this_.img_.src = getImgSrc(this_.color_);
		       this_.promoted_to = promote;
                  }
                  placePiece(game, location, this_);
                  nullPiece(game, this_.location_);
                  var undo = { type: RES, color: this_.color_, piece: this_, benched: Benched[Benched.length - 1],
                               oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_, promote: promote };
                  Undo.push(undo);
                  if (GAME_STATE.variant == ATOMIC ) {
                      var explodedpieces = null;
                      explodedpieces = explodePieces(game, location);
                      if (explodedpieces != null) undo.explodedpieces = explodedpieces;
                  } 
                  sortBenchedPieces();
         } else
         if (RES == CASTLELONG) {
                      var goodcastle_ = false;

                      var chess960 = ( game.GAME_STATE.variant == CHESS960 );
                      for (var p in Board) {
                         const Piece = Board[p].piece;
                         if (Piece == null) continue;
                         if (Piece.role_ != 'R' || this_.role_ != 'K') continue;
                         const h1 = Piece.location_[0].charCodeAt(0);
                         const h2 = this_.location_[0].charCodeAt(0); 
                         if (h1 > h2) continue; // make sure we're dealing with Queens's rook
                         
                         if (Piece.oldlocation_ == null && this_.oldlocation_ == null) {
                                              // Rook and King have not moved before
                             if (this_.color_ == "klt") {
                                 if (chess960) {
                                      location = 'c1';
                                      if (Piece.color == "rlt") {
                                         this_.restype_ = RES;
                                         if (this_.location_ == 'd1' && Piece.location_ == 'c1') { //overstepping 
                                            swapPiece(game, Piece, this_);
                                         } else {
                                            Piece.oldlocation_ =  Piece.location_;
                                            Piece.location_ = "d1";
                                            placePiece(game, "d1",  Piece);
                                            nullPiece(game, Piece.oldlocation_);
                                            if (location != this_.location) { // in chess960, castling king can be in same location.
                                               placePiece(game, location, this_);
                                               nullPiece(game, this_.location_);
                                            }
                                         }
                                         Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                         goodcastle_ = true;
                                         break;
                                      }
                                 } else  
                                 if (location == "c1") {
                                   if (Piece.location_ == "a1" && Piece.color == "rlt") {
                                     this_.restype_ = RES;
                                     Piece.oldlocation_ = "a1";
                                     Piece.location_ = "d1";
                                     placePiece(game, location, this_);
                                     nullPiece(game, this_.location_);
                                     placePiece(game, "d1",  Piece);
                                     nullPiece(game, "a1");
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                  oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              } else
                              if (this_.color_ == "kdt") { // dark
                                 if (chess960) {
                                      location = 'c8';
                                      if (Piece.color == "rdt") {
                                         this_.restype_ = RES;
                                         if (this_.location_ == 'd8' && Piece.location_ == 'c8') { // king is overstepping
                                            swapPiece(game, Piece, this_);
                                         } else {
                                            Piece.oldlocation_ =  Piece.location_;
                                            Piece.location_ = "d8";
                                            placePiece(game, "d8",  Piece);
                                            nullPiece(game, Piece.oldlocation_);
                                            if (location != this_.location) { // in chess960, castling king can be in same location.
                                               placePiece(game, location, this_);
                                               nullPiece(game, this_.location_);
                                            }
                                          }
                                          Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                       oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                          goodcastle_ = true;
                                          break;
                                      }
                                 } else
                                 if (location == "c8") {
                                   if (Piece.location_ == "a8" && Piece.color == "rdt") {
                                     this_.restype_ = RES;
                                     Piece.oldlocation_ = "a8";
                                     Piece.location_ = "d8";
                                     placePiece(game, location, this_);
                                     nullPiece(game, this_.location_);
                                     placePiece(game, "d8", Piece);
                                     nullPiece(game, "a8");
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              }
                          }
                       }
                       if (!goodcastle_) illegal_move("Not able to find proper pieces for long castling!");
         } else
         if (RES == CASTLESHORT) {
                      var goodcastle_ = false;

                      var chess960 = ( game.GAME_STATE.variant == CHESS960 );
                      for (var p in Board) {
                         const Piece = Board[p].piece;
                         if (Piece == null) continue;
                         if (Piece.role_ != 'R' || this_.role_ != 'K') continue;
                         const h1 = Piece.location_[0].charCodeAt(0);
                         const h2 = this_.location_[0].charCodeAt(0); 
                         if (h1 < h2) continue; // make sure we're dealing with King's rook
                         if (Piece.oldlocation_ == null && this_.oldlocation_ == null) {
                                              // Rook and King have not moved before
                             if (this_.color_ == "klt") {
                                 if (chess960) {
                                      location = 'g1';
                                      if (Piece.color == "rlt") {
                                        this_.restype_ = RES;
                                         if (this_.location_ == 'f1' && Piece.location_ == 'g1') { //overstepping
                                            swapPiece(game, Piece, this_);
                                         } else {
                                            Piece.oldlocation_ =  Piece.location_;
                                            Piece.location_ = "f1";
                                            placePiece(game, "f1",  Piece);
                                            nullPiece(game, Piece.oldlocation_);
                                            if (location != this_.location) { // in chess960, castling king can be in same location.
                                              placePiece(game, location, this_);
                                              nullPiece(game, this_.location_);
                                            }
                                         }
                                         Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                         goodcastle_ = true;
                                         break;
                                      }
                                 } else
                                 if (location == "g1") {
                                   if (Piece.location_ == "h1" && Piece.color == "rlt") {
                                     this_.restype_ = RES;
                                     Piece.oldlocation_ = "h1";
                                     Piece.location_ = "f1";
                                     placePiece(game, location,  this_);
                                     nullPiece(game, this_.location_);
                                     Board["f1"].piece = Piece;
                                     placePiece(game, "f1", Piece);
                                     nullPiece(game, "h1");
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              } else
                              if (this_.color_ == "kdt") { // dark
                                 if (chess960) {
                                      location = 'g8';
                                      if (Piece.color == "rdt") {
                                         this_.restype_ = RES;
                                         if (this_.location_ == 'f8' && Piece.location_ == 'g8') { //overstepping
                                            swapPiece(game, Piece, this_);
                                         } else {
                                           Piece.oldlocation_ =  Piece.location_;
                                           Piece.location_ = "f8";
                                           placePiece(game, "f8",  Piece);  // the rook moves
                                           nullPiece(game, Piece.oldlocation_); // old location is set to null
                                           if (location != this_.location) { // in chess960, castling king can be in same location.
                                             placePiece(game, location, this_); // the king moves
                                             nullPiece(game, this_.location_);
                                           }
                                         }
                                         Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                         goodcastle_ = true;
                                         break;
                                      }
                                 } else
                                 if (location == "g8") {
                                   if (Piece.location_ == "h8" && Piece.color == "rdt") {
                                     this_.restype_ = RES;
                                     Piece.oldlocation_ = "h8";
                                     Piece.location_ = "f8";
                                     placePiece(game, location, this_);
                                     nullPiece(game, this_.location_);
                                     placePiece(game, "f8", Piece);
                                     nullPiece(game, "h8");
                                     Undo.push( { type: RES, color: this_.color_, piece: this_, rook: Piece,
                                                 oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_ } )
                                     goodcastle_ = true;
                                     break;
                                   }
                                 }
                              }
                          }
                       }
                       if (!goodcastle_) illegal_move("Not able to find proper pieces for short castling!");
         } else
         if (RES == GOODMOVE) {
                  if (promote != null && promote != "") { 
                       this_.role_ = promote;
                       this_.color_ =  (this_.color_ == 'plt') ? promote.toLowerCase() + 'lt' : promote.toLowerCase() + 'dt';
                       this_.img_.src = getImgSrc(this_.color_);
		       this_.promoted_to = promote;
                  }
                  this_.restype_ = RES;
                  placePiece(game, location, this_);
                  nullPiece(game, this_.location_);
                  Undo.push( { type: RES, color: this_.color_, piece: this_, oloc: this_.location_, nloc: location, ooloc: this_.oldlocation_, promote: promote } )
           } else {
                 illegal_move("No result from assertion!");
           }
           this_.oldlocation_ = this_.location_;
           this_.location_ = location;
           game.GAME_STATE.lastpiece_ = this_;
           assertMobility(game, pclass, RES);
           if (game.GAME_STATE.variant == THEMOLE) game.revealMole(pclass); 
           if (game.GAME_STATE.variant == THETRAITOR) game.revealTraitor(pclass); 
           return RES;
    }


    class Game {

       // Initialize
       Undo_  = []
       MoveHint_ = []
       Moves_ = []
       RepeatDraw_ = []
       tbox = null

       PLAYCNT_ = 150 // TIMER_BLITZ_ // 150 for 7 seconds
       PLAYTIME_ = this.PLAYCNT_ * 50

       INIT_STATE =  { sidetomove_: WHITE, movecount_: 0, status_: STATUS.INIT, lastpiece_: null, gametoken_: '', simul: false, tourney: false, 
                       chessgame_: null, lastmove_: null, playstatus_: STATUS.STOPPED, playcurrent_: null, 
                       ptimer_: null,  mousedu_: false, onpromote_: false, promotepiece: null, remoteside_: null, remoteplayer_ : null,
                       checkmate_: false, checkmateside_: null, checkmatemobility_: 0, gamecurrent_: null, fen_: null,
                       stalemate_: false, stalemateside_: null, stalematemobility_: 0, round: null,
                       checkking_: false, checkkingside_: null, gameover_: false, gameoverside_: null,
		       drawinsufficient_ : false, drawaccepted_: false, variant: STANDARD, wchecks: 0, bchecks: 0
                     }

       INIT_TIMER_ = { last_time: 0, watch: '00:00:00', timer: null, int_timer: 0, elapsed: 0 }

       BPLAYER_ = "human"
       WPLAYER_ = "human"
       OURSIDE_ = WHITE

       Piece = class Piece {
           constructor(this_, role, color, location, set_it) {
              this.image(this_, role, color, location, set_it);
           }

           image(this_, role, color, location, set_it = false) {
               const img = document.createElement('img');
               img.id  = role + location;
               img.src = getImgSrc(color);
               img.className = 'chessimg';
               img.style.display = "block";
               img.style.cursor = "pointer";
               img.style.top = '0px';
               img.style.left = '0px';
               img.style.width = this_.cellwidth + 'px';
               img.style.height = this_.cellheight + 'px';
               this.img_ = img;
               this.role_ = role;
               this.color_ = color;
               this.location_ = location;
               this.oldlocation_ = null;
               // this.active_ = 1;
               img.piece = this;
               img.game_ = this_;
               img.addEventListener('mousedown', this_.mouseDownForMove);
               if (set_it) { img.ondblclick = this_.unsetPiece; }
           }

           get role() { return this.role_; }
           get location() { return this.location_; }
           get oldlocation() { return this.oldlocation_; }
           get getpiece() { return this.piece; }
           get color() { return this.color_; }

           set move(what) {
             return move(this.img_.game_, this, what);
           }
       }

       
       constructor(id, parent, top, left, width, height, color, control = _CONTROLON_, variant = STANDARD, fen_ = null ) {
          var fen = wINITFEN_;
          var chess960 = (variant == CHESS960);
          if (chess960) { fen = randomFENchess960() };
          if (variant == HORDE) { fen = wINITFENHORDE_ }; 
          // fen = 'k6r/2P5/6p2/8/8/8/8/K7 w - - 0 1';
          // fen = '1rk3r1/8/8/1P4p1/8/8/8/1RK3R1 w KQkq - 0 1';
          // fen = 'r2k2r1/8/8/1P4p1/8/8/8/2RK2R1 w KQkq - 0 1';
          // fen = 'r2k2r1/8/B7/1P4p1/8/8/8/1R1K2R1 w KQkq - 0 1';
          // fen = "rnbqkbnr/pppppppp/8/1PP2PP1/8/8/8/8 w kq - 0 1";
          // fen = 'b5k1/5ppp/8/8/8/8/5PPP/1R4K1 w - - 0 1';
          // fen = '7k/6B1/7P/8/8/8/8/K7 w - - 0 1';
          // fen = 'k1r5/8/8/8/8/2N3N2/8/2K5 w - - 0 1';
          if (fen_ != null) fen = fen_;
log("got it now fen ");
log(fen_);
log(fen);
          this.id = id;
          this.parent_ = parent;
          this.ChessBoard = this.createBoard(id, parent, top, left, width, height, color, control);
          this.setFENonBoard(fen, this);
          this.GAME_STATE = Object.assign({}, this.INIT_STATE);
          this.GAME_STATE.variant = variant;
          this.createWindow(id, parent, control, variant);
          this.colorBoard(this, color, control);
          this.quiesce_system(this, false);
          this.GAME_STATE.variant = variant;
       }

      createBoard(id, parent, top = 10, left = 10, width = 400, height = 400, color ) {
          const Board = {};
          const tbox = document.createElement('div');
          const tb = document.createElement('table');
          const tbody = document.createElement('tbody');
          tbody.style = "margin: 0px; padding: 0px";
          var cellwidth = width / 8; 
          var cellheight = height / 8;
          this.cellwidth = cellwidth;
          this.cellheight = cellwidth;
          tbox.className = 'chessbox';
          tbox.style.top = top + 'px';
          tbox.style.left = left + 'px';
          tbox.style.width = width + 'px';
          tbox.style.height = height + 'px';
          const tpad = getCSS(".chessbox");
          tbox.style.paddingTop = tpad.style.paddingTop;
          tbox.style.paddingBottom = tpad.style.paddingBottom;
          tbox.style.paddingRight = tpad.style.paddingRight;
          tbox.style.paddingLeft = tpad.style.paddingLeft;

          tb.className = 'chesstable';
          tb.appendChild(tbody);
          tbox.appendChild(tb);
          tbox.reversed_ = false;
          tbox.boardcolor_ = BOARDCOLOR_[color];
          for (var v = 8; v>=1; v--) {
            const tr = document.createElement('tr');
            tr.className = 'chessrow';
            for (var p=0; p<=7; p++) {
               const h = horiz[p];
               const td = document.createElement('td');
               const dv = this.createEmptyCell(this, tbox, v, p);
               if ((p + v) % 2) td.className = 'darksquare'; else td.className = 'lightsquare';
               td.cellspacing = 0; td.cellpadding = 0;
               td.style.width = cellwidth + 'px';
               td.style.height = cellheight + 'px';
               td.id = h + v;
               dv.id = h + v;
               td.appendChild(dv);
               tr.appendChild(td);
               Board[h + v] = { td_ : dv, piece: null};
            }
            tbody.appendChild(tr);
          }
          return { tbox: tbox, Board: Board, Bench: [] };
     }

     createEmptyCell(this_, tbox, v, p) {
          const empty = document.createElement('div');
          const color = tbox.boardcolor_;
          empty.className = "cellcontainer"; 
          empty.style.width = this_.cellwidth + 'px';
          empty.style.height = this_.cellheight + 'px';
          const a = document.createElement('span');
          const b = document.createElement('span');
          a.className = 'rboardno'; 
          b.className = 'bboardno';
          if (p == 7) { a.innerHTML =  v; }; 
          if (v == 1) { b.innerHTML = horiz[p]; };
          empty.appendChild(a);
          empty.appendChild(b);
          empty.anum_ = a;
          empty.bnum_ = b;
          return empty;
     }

     rgba(hex, opacity) {
       const r = parseInt('0x' + hex.slice(1,3));
       const g = parseInt('0x' + hex.slice(3,5));
       const b = parseInt('0x' + hex.slice(5,7));
       const color = 'rgb(' + r + ',' + g + ',' + b + ',' + opacity + ')';
       return color;
     }

     colorBoard(this_, selected, control) {
          const Board = this_.ChessBoard.Board;
          const tbox = this_.ChessBoard.tbox;
          const color = BOARDCOLOR_[selected];
          var reversed = this.tbox.reversed_;
          var len = 0;
          tbox.style.backgroundColor = color.sd;
          const lt = tbox.getElementsByClassName('lightsquare');
          const dt = tbox.getElementsByClassName('darksquare');
          len = lt.length;
          for (var i=0; i<len; i++) {
              const elem = lt[i];
              elem.style.backgroundColor = color.lt;
          }
          len = dt.length;
          for (var i=0; i<len; i++) {
              const elem = dt[i];
              elem.style.backgroundColor = color.dt;
          }
          tbox.boardcolor_ = color;

          // color Numbers
          for (var i=8; i>=1; i--) {
            var anum = Board['h' + i].td_.anum_;
            var bnum = Board[horiz[8-i] + 1].td_.bnum_;
            if (!control.boardnum) {
              anum.style.color = (i % 2) ? color.lt : color.dt;
              bnum.style.color = (i % 2) ? color.lt : color.dt;
            } else {
              anum.style.color = (i % 2) ? color.dt : color.lt;
              bnum.style.color = (i % 2) ? color.dt : color.lt;
            }
          }

          this_.container_.style.borderColor = tbox.boardcolor_.hdt;
          this_.footer_.style.backgroundColor = tbox.boardcolor_.sd;
          this_.header_.style.backgroundColor = tbox.boardcolor_.sd;
          this_.ftr_player_.style.color = '#2a2a2a'; // tbox.boardcolor_.hdt;
          this_.hdr_player_.style.color = '#2a2a2a'; // tbox.boardcolor_.hdt;
          this_.hdr_capture_.style.color = tbox.boardcolor_.lt;
          this_.ftr_capture_.style.color = tbox.boardcolor_.hdt;

          const white = tbox.boardcolor_.sd;
          const black = tbox.boardcolor_.dt;
          if (tbox.rating != null) {
            var score = tbox.score_;
            tbox.rating.style.backgroundColor = (reversed) ? white : black;
            tbox.rating.parentNode.style.backgroundColor = (reversed) ? black : white;
          }

          // color move hints
          if (this_.MoveHint_.length > 0) {
             var hint = this_.MoveHint_[this_.MoveHint_.length - 1];
             this_.resetHint(hint.src, false);
             this_.resetHint(hint.dst, false);
          }

          // color tooltip
          const tooltip = this_.header_.getElementsByClassName('tooltip')[0];
          tooltip.style.backgroundColor = tbox.boardcolor_.dt;
          tooltip.style.color = tbox.boardcolor_.hdt; // '#2a2a2a';

          // color message window;
          var msgwin = tbox.msgwin_;
          // msgwin.style.backgroundColor = tbox.boardcolor_.lt;
          msgwin.style.borderColor = tbox.boardcolor_.hdt;
          msgwin.style.color = tbox.boardcolor_.hdt;
     }


     createHeader() {
         this.header_ = chessheader.cloneNode(true);
         this.hdr_title_  = this.header_.getElementsByClassName('playertitle')[0]
         this.hdr_player_  = this.header_.getElementsByClassName('playerside')[0]
         this.hdr_elo_     = this.header_.getElementsByClassName('playerelo')[0]
         this.hdr_capture_ = this.header_.getElementsByClassName('playercapture')[0]
         this.hdr_timer_   = this.header_.getElementsByClassName('playertimer')[0]
         const tag =  this.header_.getElementsByTagName('button')[0];
         tag.game_ = this;
     }

     createFooter() {
         this.footer_ = chessfooter.cloneNode(true);
         this.ftr_title_  = this.footer_.getElementsByClassName('playertitle')[0]
         this.ftr_player_  = this.footer_.getElementsByClassName('playerside')[0]
         this.ftr_elo_     = this.footer_.getElementsByClassName('playerelo')[0]
         this.ftr_capture_ = this.footer_.getElementsByClassName('playercapture')[0]
         this.ftr_timer_   = this.footer_.getElementsByClassName('playertimer')[0]
         this.ftr_side_    = this.footer_.getElementsByClassName('sidetomove')[0]
     }

     createWindow(id, parent, control, variant) {
         const msg_board   = document.createElement('div');
         const container   = document.createElement('div');
         const chmoves = chessmoves.cloneNode(true);
         const tbox = this.ChessBoard.tbox; 
         this.createHeader();
         this.createFooter();
         container.appendChild(tbox);
         container.appendChild(this.header_);
         container.appendChild(this.footer_);
         container.appendChild(msg_board);
         container.appendChild(chmoves);
         parent.appendChild(container);
         const width = tbox.clientWidth;
         const height = tbox.clientHeight;
         const header = getCSS('.chessheader');
         const footer = getCSS('.chessfooter');
         const hdr_height = parseInt(header.style.height);
         const ftr_height = parseInt(footer.style.height);
         var cbdr_  = header.style.borderWidth;
         this.container_ = container;
         container.game_ = this;

         ZINDEX_ ++;
         container.id = 'contr_' + id;
         container.className = 'chesscontainer';
         this.container_.style.top = parseInt(tbox.style.top) + 'px';
         this.container_.style.left = parseInt(tbox.style.left) + 'px';
         this.container_.style.width = width + 'px';
         this.container_.style.height = (height + hdr_height + ftr_height) + 'px';
         this.container_.style.zIndex = ZINDEX_;

         this.container_.style.backgroundColor = tbox.boardcolor_.sd;

         // Board & tbox
         this.Board_ = this.ChessBoard.Board;
         this.tbox   = this.ChessBoard.tbox;

         // header & footer
         this.header_.style.height = hdr_height + 'px';
         this.header_.style.width = width + 'px';
         this.footer_.style.height = ftr_height + 'px';
         this.footer_.style.width = width + 'px';
         this.header_.style.cursor = 'pointer';

         tbox.style.top =  hdr_height + 'px';
         this.header_.style.top = '0px';
         this.footer_.style.top = (height + hdr_height) + 'px';

         tbox.style.left  = '0px';
         this.header_.style.left = '0px';
         this.footer_.style.left = '0px';

         // message board
         var contr_ = getCSS('.chesscontainer');
         var brdr_ = parseInt(contr_.style.borderWidth);
         this.msg_board_ = msg_board;
         this.msg_board_.style.left  = '0px';
         this.msg_board_.style.top = (height + hdr_height + ftr_height + brdr_) + 'px';
         this.msg_board_.innerHTML = 'Board Initialized ...';
         this.msg_board_.style.width = width + 'px';
         this.msg_board_.className = 'chessmsgboard';


         // chess move 
         chmoves.id = this.id + '_chessmoves';
         this.chmoves_ = chmoves; 
         this.chmoves_.style.left  = this.container_.clientWidth + 'px';
         this.chmoves_.style.visibility = 'hidden';

         // chess control
         var chesscontrol = chmoves.getElementsByClassName('chesscontrol')[0];
         this.chesscontrol_ = chesscontrol;

         // move analysis
         var brilliantw_ = chmoves.getElementsByClassName('chessbrilliantid')[0];
         var bestw_ = chmoves.getElementsByClassName('chessbestid')[0];
         var greatw_ = chmoves.getElementsByClassName('chessgreatid')[0];
         var goodw_ = chmoves.getElementsByClassName('chessgoodid')[0];
         var bookw_ = chmoves.getElementsByClassName('chessbookid')[0];
         var inaccuratew_ = chmoves.getElementsByClassName('chessinaccurateid')[0];
         var mistakew_ = chmoves.getElementsByClassName('chessmistakeid')[0];
         var blunderw_ = chmoves.getElementsByClassName('chessblunderid')[0];
         var accuracyw_ = chmoves.getElementsByClassName('chessaccuracyid')[0];
         var brilliantb_ = chmoves.getElementsByClassName('chessbrilliantid')[1];
         var bestb_ = chmoves.getElementsByClassName('chessbestid')[1];
         var greatb_ = chmoves.getElementsByClassName('chessgreatid')[1];
         var goodb_ = chmoves.getElementsByClassName('chessgoodid')[1];
         var bookb_ = chmoves.getElementsByClassName('chessbookid')[1];
         var inaccurateb_ = chmoves.getElementsByClassName('chessinaccurateid')[1];
         var mistakeb_ = chmoves.getElementsByClassName('chessmistakeid')[1];
         var blunderb_ = chmoves.getElementsByClassName('chessblunderid')[1];
         var accuracyb_ = chmoves.getElementsByClassName('chessaccuracyid')[1];
         this.enginescore_ =  {
                total_moves: 0, white_accuracy: 0, black_accuracy: 0,
                SCORES_: {},
                wanalysis_ : { 
                      'Brilliant': brilliantw_, 'Best': bestw_, 'Great': greatw_, 'Good': goodw_,
                      'Book': bookw_, 'Inaccurate': inaccuratew_, 'Mistake': mistakew_,
                      'Blunder': blunderw_, 'Accuracy': accuracyw_ },
                banalysis_ : { 
                      'Brilliant': brilliantb_, 'Best': bestb_, 'Great': greatb_, 'Good': goodb_,
                      'Book': bookb_, 'Inaccurate': inaccurateb_, 'Mistake': mistakeb_,
                      'Blunder': blunderb_, 'Accuracy' : accuracyb_ }
              }

         // chessls link
         this.chessls_ = chessls;

         this.setChessControl();

         this.createSideMenu(control);

         this.createMsgWindow();

         this.createWaitingWindow();

         this.createSideControl(control);

         this.header_.container_ = this.container_
         this.header_.game_ = this;

         // mouse events
         if (!control.fixed)  {
           container.addEventListener('mouseenter', this.highlightBoard, false);
           container.addEventListener('mouseleave', this.unhighlightBoard, false);
           this.header_.addEventListener('mousedown', this.mouseDownForContainer);
           document.addEventListener('mouseup', this.mouseUpForAll, false);
         }


         // resize operations
         const resizeContainer = container.cloneNode(false);
         resizeContainer.id = "clonedcontainer";
         resizeContainer.style.backgroundColor = '';
         resizeContainer.style.visibility = 'hidden';
         resizeContainer.style.zIndex = 250000;
         parent.appendChild(resizeContainer);
         this.resizeContainer_ = resizeContainer;

         if (control.border == false) {
            container.style.borderWidth = '0px';
            cbdr_ = 0;
         } 

         if (control.header == false) {
           this.container_.style.backgroundColor = '';
           this.resizeContainer_.style.backgroundColor = '';
         }

         // needs to be before resize container settings (see createSetPiece).
         this.createSetPiece(variant);

         this.createThreeChecks();

         if (!control.fixed) {
            container.addEventListener('mousedown', this.mouseDownForResize, false);
         }
         container.game_ = this;

         // Clone Promotion template
         this.promo_ = promoteid.cloneNode(true);
         this.promocoll_  = this.promo_.getElementsByClassName('promocontain')
         this.promoblack_ = this.promocoll_[0]
         this.promowhite_ = this.promocoll_[1]

         var next = this.promoblack_.firstChild;
         while (next) {
           if (next.nodeType == 1) { next.onclick = this.promotePiece; next.game_ = this }
           next = next.nextSibling;
         }
         next = this.promowhite_.firstChild;
         while (next) {
           if (next.nodeType == 1) { next.onclick = this.promotePiece; next.game_ = this }
           next = next.nextSibling;
         }
         this.container_.appendChild(this.promo_);

     }


     createMsgWindow() {
         var tbox = this.tbox;
         const msgwin = messagedivid.cloneNode(true);
         const msgid  = msgwin.getElementsByTagName('div')[0];
         var twidth = parseInt(tbox.style.width);
         var theight = parseInt(tbox.style.height);
         var width = parseInt(msgwin.style.width);
         var height = parseInt(msgwin.style.height);
         var left = (twidth - width ) / 2;
         var top = (theight - height ) / 2;
         this.tbox.msgwin_ = msgwin;
         this.tbox.msgid_ = msgid;
         msgwin.style.left = left + 'px';
         msgwin.style.top = top + 'px';
         msgwin.style.visibility = 'hidden';
        // msgwin.style.borderColor = tbox.boardcolor_.hdt;
        // msgwin.style.color = tbox.boardcolor_.hdt;
         tbox.appendChild(msgwin);
     }

     createWaitingWindow() {
         const tbox = this.tbox;
         const waiting = waitingmatchid.cloneNode(true);
         const waitid  = waiting.getElementsByTagName('span')[0];
         const twidth = parseInt(tbox.style.width);
         const theight = parseInt(tbox.style.height);
         const width = parseInt(waiting.style.width);
         const height = parseInt(waiting.style.height);
         const left = (twidth - width ) / 2; 
         const top = (theight - height ) / 2; 
         waiting.style.left = left + 'px'; 
         waiting.style.top = left + 'px'; 
         tbox.appendChild(waiting);
         tbox.waiting_ = waiting;
         tbox.waitid_ = waitid;
         waiting.game_ = this;
     }

     createThreeChecks() {
         var tbox = this.tbox;
         const threechecksid_ = threechecksid.cloneNode(true);
         const width = parseInt(tbox.style.width);
         const padL = parseInt(tbox.style.paddingLeft);
         const padR = parseInt(tbox.style.paddingRight);
         const padT = parseInt(tbox.style.paddingTop);
         const padB = parseInt(tbox.style.paddingBottom);
         const hheight = parseInt(this.header_.style.height);

         threechecksid_.style.top = '0px';
         threechecksid_.style.left = (width + padL + padR) + 'px';

         if (this.GAME_STATE.variant == THREECHECKS) {
             threechecksid_.style.visibility = 'visible';
         }

         const imgs = threechecksid_.getElementsByTagName('img');
         for (var p in imgs) {
            const img = imgs[p];
            if (img.nodeType == 1) {
              img.role_ = img.id[0].toUpperCase();
              img.color_ = img.id.slice(0,3);
              img.game_ = this;
            }
         }

         tbox.spanchecks_ = {};
         const spans = threechecksid_.getElementsByTagName('span');
         for (var p in spans) {
            const span = spans[p];
            if (span.nodeType == 1) {
               tbox.spanchecks_[span.id] = span;
               span.innerHTML = '+';
               span.style.visibility = 'hidden';
            }
         }

         const funcV = function() { this.style.visibility = 'visible' };
         const funcH = function() { this.style.visibility = 'hidden' };

         tbox.appendChild(threechecksid_);
         tbox.threechecks_ = threechecksid_;
         tbox.threechecks_.hide = funcH;
         tbox.threechecks_.show = funcV;

         this.adjustThreeChecks();

     }

     createSetPiece(variant) {
         var tbox = this.tbox;
         const setpiece = setpieceid.cloneNode(true);
         const setfen = setfenid.cloneNode(true);
         const width = parseInt(tbox.style.width);
         const padL = parseInt(tbox.style.paddingLeft);
         const padR = parseInt(tbox.style.paddingRight);
         const padT = parseInt(tbox.style.paddingTop);
         const padB = parseInt(tbox.style.paddingBottom);
         const hheight = parseInt(this.header_.style.height);

         setpiece.style.top = '0px';
         setpiece.style.left = (width + padL + padR) + 'px';
         if (this.GAME_STATE.variant == CRAZYHOUSE) {
             setpiece.style.visibility = 'visible';
         }

         const imgs = setpiece.getElementsByTagName('img');
         for (var p in imgs) {
            const img = imgs[p];
            if (img.nodeType == 1) {
              img.addEventListener('mousedown', this.mouseDownForSet);
              img.role_ = img.id[0].toUpperCase();
              img.color_ = img.id.slice(0,3);
              img.game_ = this;
            }
         }

         tbox.spancaptures_ = {};
         const spans = setpiece.getElementsByTagName('span');
         for (var p in spans) {
            const span = spans[p];
            if (span.nodeType == 1) {
               tbox.spancaptures_[span.id] = span;
               span.innerHTML = 0;
               span.style.visibility = 'hidden';
            }
         }
         
         const funcV = function() { this.style.visibility = 'visible' };
         const funcH = function() { this.style.visibility = 'hidden' };
         
         const twidth = parseInt(setfen.style.width);
         tbox.appendChild(setpiece);
         this.resizeContainer_.appendChild(setfen);
         setfen.style.top = (parseInt(this.tbox.style.height) + padT + padB + hheight + 10) + 'px';
         setfen.style.left = ((width - twidth ) / 2) + 'px';
         tbox.setpiece_ = setpiece;
         tbox.setfen_    = setfen;
         tbox.setpiece_.hide = funcH;
         tbox.setpiece_.show = funcV;
         setfen.game_ = this;

         this.adjustSetPiece();
 
         const btns = setfen.getElementsByTagName('div');
         for (var p in btns) {
           const btn = btns[p];
           if (btn.nodeType == 1) {
               btn.onmousedown = function() { this.style.color = "#FFFFFF"; } 
               btn.onmouseup = function() { this.style.color = "#252525"; } 
           }
         }
     }

     setChessControl() {
        var chmoves = this.chmoves_;
        var chessctl = this.chesscontrol_;
        chessctl.style.zIndex = ZINDEX_;
        chessctl.tag_ = 1;
        const notes = chmoves.getElementsByClassName("chessgame")[0];
        this.Notes_ = notes;
        const movebtns = chessctl.getElementsByClassName("chessplaybtn");
        for (var p in movebtns) {
           const btn = movebtns[p];
           if (btn.nodeType == 1) {
             btn.game_ = this;
              mouseEvent(btn, '#808080', '#000000', '#038A12');
              btn.style.cursor = 'pointer';
           }
        }
     }

     createSideControl() {
         const icons = [ '&#x1F4DC', '-', '&#x265F;', '&#x1F4DC', '&#x1F532;', '&#x23F0;', '&#x274C;' ];
         const func  = [ this.showPGN, '', this.setPosition, this.loadPosition, null, this.chooseTimer, this.closeBoard ];
         const title = [ 'Show Moves', '', 'Set Position', 'Load a Game', 'Maximize Size', 'Timer', 'Close' ];
         const div = useMenu(icons, func, title);
         div.style = 'position: absolute; top: 280px; left: 0px; width: 120px; height: 190px';
         this.container_.appendChild(div);
         this.sidecontrol_ = div;
 /*
         const condiv = document.createElement('div');
         condiv.style = 'position: absolute; margin: 0px 0px 0px 0px; background-color: #dedede; box-shadow: 3px 3px 3px 3px rgb(50, 50, 50, 0.5);' +
                        'border: 2px solid #efefef; top: 280px; left: 0px; width: 120px; height: 170px';
         this.container_.appendChild(condiv);

         const icons = [ '&#x1F4DC', '&#x265F;', '&#x1F4DC', '&#x1F532;', '&#x23F0;', '&#x274C;' ];
         const func  = [ this.showPGN, this.setPosition, this.loadPosition, null, this.chooseTimer, this.closeBoard ];
         const title = [ 'Show Moves', 'Set Position', 'Load a Game', 'Maximize Size', 'Timer', 'Close' ];

         for (var i=0; i<6; i++) {
            const ctrl = document.createElement('span');
            const tt = '<span style="font-size: 12px; font-weight: normal; font-family: helvetica">' + title[i] + '</span>';
            ctrl.style = 'position: absolute; cursor: pointer; left: 10px; top: ' + (5 + i * 28) +  'px';
            ctrl.innerHTML = icons[i] + '&nbsp;&nbsp;&nbsp;' + tt;
            ctrl.onclick = func[i];
            ctrl.title = title[i];
            ctrl.game_ = this;
            condiv.appendChild(ctrl);
         }
         condiv.title = 'ToolTips';
         condiv.style.visibility = 'hidden';
         this.sidecontrol_ = condiv;
         condiv.addEventListener('mouseleave', this.leaveMeBeorEnter, false);
 */
     }

     createSideMenu(control) {
         const condiv = document.createElement('div');
         const helicopter = '&#x1F681';
         condiv.style = 'position: absolute; margin: 0px 0px 0px 0px; background-color: #dedede; cursor: pointer; ' +
                        'top: -3px; left: -31px; width: 28px; height: 370px';
         this.container_.appendChild(condiv);
         const icons = ['&#x1F590;', '&#x1F44E;', '&#x1F519', '&#x1F44A','&#x21BB;', '&#x1F3A8;', helicopter,
			'&#x25A3;', '&#x1F521', '&#x1F4AC;', '&#x1F4CC', '&#x2630', '&#x274C;' ]; 
         const func  = [ this.abortGame, this.resignGame, this.takeBack, this.offerDraw,  this.reverseBoard, this.chooseColor, this.slideMove,
                         this.setSquare,  this.disableBoardNumbers, this.sendMessage, this.pinBoard, this.MoreTools, this.closeBoard ];
         const title = [ 'Abort Game', 'Resign', 'Take Back', 'Offer Draw', 'Reverse Board', 'Choose Color', 'Slide Move',
                         'Square Size',  'Disable Board Numbers', 'Send Message', 'Pin Board', 'More Tools', 'Close Board' ];
/*
         const icons = ['&#x2795;', '&#x1F4CC;', '&#x1F44E;', '&#x21BB;', '&#x1F3A8;',
			'&#x1F519;', '&#x1F916', '&#x1F4DC;', '&#x1F5C4;', '&#x1F4AC;', '&#x2630' ]; 
         const func  = [ this.newMatch, this.pinBoard, this.resignGame, this.reverseBoard, this.chooseColor,
                         this.takeBack, this.showPGN, this.loadPosition, this.loadPGN, this.sendMessage, this.MoreTools ];
         const title = [  'New Game', 'Pin Board', 'Resign', 'Reverse Board', 'Choose Color',
                         'Take Back', 'Show Moves', 'Load a Game', 'Load a Database', 'Send Message', 'More Tools' ];
*/
         for (var i=0; i<13; i++) {
            const ctrl = document.createElement('span');
            ctrl.style = 'position: absolute; cursor: pointer; left: 5px; top: ' + (5 + i * 28) +  'px';  // above the board
            if (i == -1) {
               const img = document.createElement('img');
               img.src = '/images/pgn.svg';
               img.style.width='21px';
               ctrl.appendChild(img);
            } else {
               ctrl.innerHTML = icons[i];
            } 
            if (icons[i] == helicopter) {
               ctrl.func_ = func[i];
               ctrl.heli_ = '1F681';
               ctrl.onclick = function(e) {
                   const helicopter = '1F681', snail =  '1F40C';
                   this.func_(e);
                   ctrl.heli_ = (this.heli_ == helicopter) ? snail: helicopter;
                   this.innerHTML = '&#x' + this.heli_;
                   this.title = (ctrl.heli_ == snail) ? 'Do not Slide Move' : 'Slide Move'; 
               } 
            } else ctrl.onclick = func[i];
            ctrl.title = title[i];
            ctrl.game_ = this;
            ctrl.addEventListener('mouseenter', this.leaveMeBeorEnter, false);
            condiv.appendChild(ctrl); 
         }

         this.control_ = condiv;
         condiv.style.visibility = 'hidden';
         if (!control.sidepanel) condiv.style.visibility = 'hidden';


     }

     sendMessage() {
      var this_ = this.game_;
         log("send message ...");
     }

     notice(msg, inp = null ) {
       var span1 = document.createElement('span');
       span1.innerHTML = msg; 
       this.msg_board_.innerHTML = '';
       this.msg_board_.appendChild(span1);
       if (inp != null) {
           var span2 = document.createElement('span');
           var label = inp.label;
           this.msg_board_.appendChild(span2);
           span2.style = 'color: #81d765; cursor: pointer';
           if (label == "acceptabort") {
              span2.innerHTML = ' accept?';
              span2.onclick = this.acceptAbort;
           } else
           if (label == "acceptdraw") {
              span2.innerHTML = ' accept?';
              span2.onclick = this.acceptDraw;
           } else
           if (label == "granttakeback") {
              span2.innerHTML = ' grant?';
              span2.onclick = this.acceptTakeback;
           } else
           if (label == "continueaftertakeback") {
              span2.innerHTML = ' continue?';
              span2.onclick = this.continueEnginePlay;
           }
           span2.game_ = this;
       } 
     }

     MoreTools() {
      var this_ = this.game_;
      if (this_ != null && this_.sidecontrol_ != null) {
          this_.disablePopups();
          const vis = this_.sidecontrol_.style.visibility;
          this_.sidecontrol_.style.visibility = (vis == 'visible') ? 'hidden' : 'visible';
      }
     }

     leaveMeBeorEnter(e) {
        e.preventDefault();
        var this_ = this.game_;
        var color, analyze, database;
        if (this.title == 'Choose Color') {
           analyze = document.getElementById('chooseanalyzeid_' + this_.id);
           database = document.getElementById('choosedatabaseid_' + this_.id);
           if (analyze != null) analyze.style.visibility = 'hidden';
           if (database != null) database.style.visibility = 'hidden';
        } else
        if (this.title == 'Load a Game') {
           color = document.getElementById('choosecolorid_' + this_.id);
           database = document.getElementById('choosedatabaseid_' + this_.id);
           if (color != null) color.style.visibility = 'hidden';
           if (database != null) database.style.visibility = 'hidden';
        } else
        if (this.title == 'Load a Game') {
           color = document.getElementById('choosecolorid_' + this_.id);
           analyze = document.getElementById('chooseanalyzeid_' + this_.id);
           if (color != null) color.style.visibility = 'hidden';
           if (analyze != null) analyze.style.visibility = 'hidden';
        } else
        if (this.title == 'ToolTips') {
           this.style.visibility = 'hidden';
        }
     }

     minimizeControl() {
         var this_  = this.condiv_;
         var c = this_.style.visibility;
         this_.style.visibility = (c == 'hidden') ? 'visible' : 'hidden';
     }

     showPGN(e, oper = 0) {
       if(!e.detail || e.detail == 1){
         e.preventDefault();
         var this_  = this.game_;
         if (document.containergame_) {
          this_ = document.containergame_;
         } else
         if (document.resizegame_) {
          this_ = document.resizegame_;
         } else
         if (document.setsquaregame_) {
          this_ = document.setsquaregame_;
         }
         var pos    = scrollOffset(e);
         var hdrh_  = parseInt(this_.header_.style.height);
         var cbdr_  = parseInt(this_.container_.style.borderWidth);
         var width  = parseInt(this_.container_.style.width);
         var height = parseInt(this_.container_.style.height);
         var top    =  parseInt(this_.container_.style.top);
         var left  =  parseInt(this_.container_.style.left);
         var bottom = this_.container_.offsetTop + height + cbdr_ * 2;
         var chessmv = this_.chesscontrol_; // this_.container_.chesscontrol_;

         const btns = chessmv.getElementsByClassName('chesscontrolbtn');

         if (chessmv.tag_ == 3 && oper) {  // for move & resize operations
            chessmv.style.width= ( width + cbdr_ * 2) + 'px';
            chessmv.style.height= '250px';
            chessmv.style.top = bottom + 'px';
            chessmv.style.left = left + 'px'
         } else 
         if ((chessmv.tag_ == 4) && oper) { // for move & resize operations
            chessmv.style.width= '450px';
            chessmv.style.height= ( height + cbdr_ * 2) + 'px';
            chessmv.style.top = top + 'px';
            chessmv.style.left = (this_.container_.offsetLeft + width + cbdr_ * 2)  + 'px';
         } else
         if (!oper && (chessmv.tag_ == 1 || chessmv.tag_ == 2)) {
            chessmv.style.visibility = 'visible';
            btns[0].style.visibility = 'visible';
            chessmv.style.width= ( width + cbdr_ * 2) + 'px';
            chessmv.style.height= '250px';
            chessmv.style.top = bottom + 'px';
            chessmv.style.left = left + 'px';
            chessmv.tag_ = 3;
          } else
         if (!oper && chessmv.tag_ == 3)  {
            chessmv.style.visibility = 'visible';
            btns[0].style.visibility = 'visible';
            chessmv.style.width= '450px';
            chessmv.style.height= ( height + cbdr_ * 2) + 'px';
            chessmv.style.top = top + 'px';
            chessmv.style.left = (this_.container_.offsetLeft + width + cbdr_ * 2)  + 'px';
            chessmv.tag_ = 4;
         } else 
         if (!oper && chessmv.tag_ == 4)  {
            chessmv.style.visibility = 'hidden';
            btns[0].style.visibility = 'hidden';
            chessmv.tag_ = 2;
         }
        }
     }

     disablePopups() {
          var pops = document.getElementsByClassName('popupdiv');
          for (var p in pops) {
             if (pops[p].nodeType == 1) {
                  pops[p].style.visibility = 'hidden';
             }
          }
          this.sidecontrol_.style.visibility = 'hidden';
     }

     chooseColor(e) {
       if(!e.detail || e.detail == 1){
         e.preventDefault();
         var this_ = this.game_;
       //  var top = 0;
       //  var left = parseInt(this.style.left.replace(/px/,'')) - 10;
         this_.disablePopups();
         var top = this.offsetTop + this.parentNode.offsetTop;
         var left = parseInt(this.style.left.replace(/px/,'')) - 10;
         chooseBoardColor( this_, { y: top, x: left } ); // references external function
        }
     }

     changeBoardColor() { // this is internal function. Don't confuse with the external one
         var this_ = this.game_;
         var color = this.value_;
         this_.colorBoard(this_, color, _CONTROLON_);
         CONFIG_.boards[this_.id].color = color;
log(CONFIG_);
     }

     highlightBoard(e) {
         e.preventDefault();
         if (typeof(document.resizegame_) != "undefined") return;
         var this_ = this.game_
         var color = this_.tbox.boardcolor_.lt;
         this.style.borderStyle = 'solid';
         this.style.borderColor =  '#3CC187'; // color; 
         return true;
     }

     unhighlightBoard(e) {
         e.preventDefault();
         if (typeof(document.resizegame_) != "undefined") return;
         var this_ = this.game_
         var color = this_.tbox.boardcolor_.hdt;
         this.style.borderStyle = 'solid';
         this.style.borderColor =  color; 
         this_.disablePopups();
         return true;
     }

     resetBoard(fen, this_) {  // using  UCI-fen
            if (fen == null) return;
            this_.quiesce_system(this_);
            this_.clearBoard(this_);
            this_.setFENonBoard(fen, this_);
     }

     clearBoard(this_) {
         var Board = this_.ChessBoard.Board;
         // Initialize Board
         for (var p in Board) {
            const board = Board[p];
            const img_ = getImage(board.td_); 
            if (img_ != null) { board.td_.removeChild(img_); }
            delete board.piece;
            board.piece = null;
            this_.resetHint(board.td_.id, true);
         }
     }

     // expect to set board on white side
     setFENonBoard(fen, this_, set_it = false) {  // using  UCI-fen
            if (fen == null) return;
            const ranks = fen.split(' ')[0].split('/');
            const Board = this_.ChessBoard.Board;
            const tbox  = this_.ChessBoard.tbox;
            for (var r in ranks) {
                const pieces = ranks[r];
                const rank = 8 - parseInt(r);
                var v = 0;
                for (var p in pieces) {
                  var role = null, color = null, location = null;
                  const piece = pieces[p];
                  location = horiz[v] + rank;
                  if (piece.match(/[RNBQKP]/)) { // lt
                     role = piece.toUpperCase();
                     color = piece.toLowerCase() + 'lt';
                     v++;
                  } else
                  if (piece.match(/[rnbqkp]/)) { // dt
                     role = piece.toUpperCase();
                     color = piece.toLowerCase() + 'dt';
                     v++;
                  } else {
                     const spaces = parseInt(piece);
                     v +=  (spaces );
                  }
                  if (role != null) {
                     const new_piece = new this.Piece(this, role, color, location, set_it);
                     Board[location].piece = new_piece;
                     Board[location].td_.appendChild(new_piece.img_);
                  }
              }
           }
           if (tbox.reversed_) {
              this_.reverseBoard(null, this_);
           }
     }

     quiesce_system(this_, keep_moves = false) {
         var Board = this_.ChessBoard.Board;
         var Bench = this_.ChessBoard.Bench;
         var Undo_ = this_.Undo_;
         var MoveHint_ = this_.MoveHint_;
         var Moves_ = this_.Moves_;
         var RepeatDraw_ = this_.RepeatDraw_;

         // quiesce engine
         if (this_.enginetime != null || this_.int_engine) {
             clearInterval(this_.enginetime);
             this_.int_engine = 0;
         }

         // clear timer
         this_.ftr_timer_.innerHTML = padTime(this.PLAYTIME_);
         this_.hdr_timer_.innerHTML = padTime(this.PLAYTIME_);
         if (this_.GAME_STATE.ptimer_ != null) {
            clearInterval(this_.GAME_STATE.ptimer_);
         }
         this_.WTIMER_ = Object.assign({}, this_.INIT_TIMER_);
         this_.BTIMER_ = Object.assign({}, this_.INIT_TIMER_);

         // reset Hints;
         for (var v = 8; v>=1; v--) {
            for (var p=0; p<=7; p++) {
               const h = horiz[p];
               this_.resetHint(h + v);
            }
         }

         // clear queues
         while (Bench.length) { Bench.pop(); }
         while (Undo_.length) { Undo_.pop(); }
         while (MoveHint_.length) { MoveHint_.pop(); }
         if (!keep_moves) while (Moves_.length) { Moves_.pop(); }
         while (RepeatDraw_.length) { RepeatDraw_.pop(); }

         // clear states
         this_.GAME_STATE = Object.assign({}, this_.INIT_STATE);
         this_.sideBoard(true);

         // clear moves
         if (!keep_moves && this_.Notes_ != null) {
           const Notes = this_.Notes_;
           while (Notes.firstChild) Notes.removeChild(Notes.firstChild);
         }

         // clear popups
         this_.disablePopups();   
         this_.tbox.msgwin_.style.visibility = 'hidden';
     }

     mouseDownForContainer(e)  {
       e.preventDefault();
       if(!e.detail || e.detail == 1) {
           // if (!CONFIG_.layout.free) return;
           var this_ = this.game_;
           var pos = scrollOffset(e);
           this.container_.startPosX = pos.x;
           this.container_.startPosY = pos.y;
           document.addEventListener('mousemove', this_.mouseMoveForContainer, false);
           document.containergame_ = this_;
           document.targetmove_ = this;
       }
     }

     mouseMoveForContainer(e) {
           e.preventDefault();
           if (typeof(this.targetmove_) == "undefined") return;
           var this_ = this.targetmove_;
           var contr = this_.container_;
           var top = parseInt(contr.style.top);
           var left = parseInt(contr.style.left);
           var game_ = document.containergame_;
           var pos = scrollOffset(e), x = pos.x, y = pos.y;
           contr.newPosX   = contr.startPosX - x;
           contr.newPosY   = contr.startPosY - y;
           if (top - contr.newPosY < 5) {  return; }
           if (left - contr.newPosX < 5) {  return;  }
           contr.startPosX = x;
           contr.startPosY = y;

           contr.style.top  = (top - contr.newPosY) + 'px';
           contr.style.left = (left - contr.newPosX) + 'px';
           game_.showPGN(e, 1);

           const res_ctrl = game_.resizeContainer_;
           res_ctrl.style.top  = (top - contr.newPosY) + 'px';
           res_ctrl.style.left = (left - contr.newPosX) + 'px';
      }

      mouseUpForAll(e) {
           e.preventDefault();
           if (typeof(document.containergame_) != "undefined") {
              var this_ = document.containergame_;
              this_.moveBoard(e);
              this_.showPGN(e, 1);
              this_.postScore();
              document.removeEventListener('mousemove', document.containergame_.mouseMoveForContainer);
              delete document.containergame_;
           } else
           if (typeof(document.resizegame_) != "undefined") {
              var this_ = document.resizegame_;
              this_.resizeBoard(e);
              this_.showPGN(e, 1);
              this_.postScore();
              adjustAllLayout(this_);
              document.removeEventListener('mousemove', document.resizegame_.mouseMoveForResize);
              delete document.resizegame_;
           } else
           if (typeof(document.movegame_) != "undefined") {
              var this_ = document.movegame_;
              this_.playHuman();
              document.removeEventListener('mousemove', document.movegame_.mouseMove);
              delete document.movegame_;
           } else
           if (typeof(document.setgame_) != "undefined") {
              var this_ = document.setgame_;
              this_.setPiece();
              document.removeEventListener('mousemove', document.setgame_.mouseMoveForSet);
              delete document.setgame_;
           } 
      }

      mouseDownForResize(e) {
         e.preventDefault();
         if(!e.detail || e.detail == 1) {
           var this_ = this.game_;
           var hdrh_ = parseInt(this_.header_.style.height);
           var ctrl = getCSS('.chesscontainer');
           var cbdr_ = parseInt(ctrl.style.borderWidth);
           var width = parseInt(this_.container_.style.width);
           var height = parseInt(this_.container_.style.height);
           var right = this.offsetLeft + width + cbdr_ * 2;
           var bottom = this.offsetTop + height + cbdr_ * 2;
           var pos = scrollOffset(e), lim_ = 35;
           if ((pos.x > right - lim_ && pos.x < right + lim_) &&
               (pos.y > bottom - lim_ && pos.y < bottom + lim_)) {
                this.startPosX = pos.x;
                this.startPosY = pos.y;
                document.addEventListener("mousemove", this_.mouseMoveForResize, false);
                document.targetmove_ = this;
                document.resizegame_ = this_;

                // Use resize container
                const res_ctrl = this_.resizeContainer_;
                res_ctrl.style.top = this.style.top;
                res_ctrl.style.left = this.style.left;
                res_ctrl.style.visibility = 'visible';
		res_ctrl.style.borderStyle = 'dashed';
                res_ctrl.style.borderColor = '#ff0000';
                this.initWidth = parseInt(res_ctrl.style.width);
                this.initHeight = parseInt(res_ctrl.style.height);
           }

          ZINDEX_ ++;
          // const con_ = this_.container_;
          // con_.style.zIndex = ZINDEX_;
          //con_.chesscontrol_.style.zIndex = ZINDEX_;

          chessdiv.game_ = this_; // helps key strokes identify current game.

          CONFIG_.boards[this_.id].zIndex =  ZINDEX_;
         
          humanid.style.visibility = 'hidden';
          computerid.style.visibility = 'hidden';
          blanket.style.visibility = 'hidden';
          settingsdivid.style.visibility = 'hidden';

         }
     }

     mouseMoveForResize(e) {
           e.preventDefault();
           if (typeof(this.targetmove_) == "undefined") return;
           if (typeof(this.resizegame_) == "undefined") return;
           var this_   = this.targetmove_; // container
           var game_   = this.resizegame_; // container
           const res_ctrl = game_.resizeContainer_;
           var width_  = parseInt(res_ctrl.style.width);
           var height_ = parseInt(res_ctrl.style.height);
           var pos = scrollOffset(e);

           if (pos.x < res_ctrl.offsetLeft + 300 || pos.y < res_ctrl.offsetTop + 300) return;
           if (pos.x > res_ctrl.offsetLeft + 1124 || pos.y > res_ctrl.offsetTop + 1124) return;

           this_.newPosX = this_.startPosX - pos.x;
           this_.newPosY = this_.startPosY - pos.y;
           this_.startPosX = pos.x;
           this_.startPosY = pos.y;
           res_ctrl.style.width = ( width_ - this_.newPosX ) + 'px';
           res_ctrl.style.height = ( height_ - this_.newPosY ) + 'px';
     }

     moveBoard(e) {
         if (document.containergame_) {
           var this_ = document.containergame_;
           var ctrl_ = this_.container_;
           // Config
           CONFIG_.boards[this_.id].top = parseInt(ctrl_.style.top);
           CONFIG_.boards[this_.id].left = parseInt(ctrl_.style.left);
log(CONFIG_);
         } 
     }

     resizeBoard(e, pin = false) {
         var this_ = null 
         if (document.setsquaregame_) {
           this_ = document.setsquaregame_;
         } else {
         if (document.resizegame_);
           this_ = document.resizegame_;
         }
         var tbox  = this_.tbox;
         var Board = this_.ChessBoard.Board;
         var ctrl_ = this_.container_;
         var res_ctrl_ = this_.resizeContainer_;
         var Bench = this_.ChessBoard.Bench;
         var contr_ = getCSS('.chesscontainer');
         var brdr_ = parseInt(contr_.style.borderWidth);
         var paddingL = parseInt(tbox.style.paddingLeft);
         var paddingR = parseInt(tbox.style.paddingRight);
         var paddingT = parseInt(tbox.style.paddingTop);
         var paddingB = parseInt(tbox.style.paddingBottom);
         const hHeight = chessheader.clientHeight;
         const fHeight = chessfooter.clientHeight;


         if ( this_.tbox.setpiece_.style.visibility == 'visible' ||
              this_.tbox.threechecks_.style.visibility == 'visible' ) {
              if ( parseInt(res_ctrl_.style.height) < (520 + hHeight + fHeight) || parseInt(res_ctrl_.style.width) < 520 ) {
                  res_ctrl_.style.width  = 520 + 'px';
                  res_ctrl_.style.height = (520 + hHeight + fHeight) + 'px';
                   
              }
         }

         if (pin) { this_.tbox.setposmode_ = true; }

         var minX = ctrl_.initWidth - parseInt(res_ctrl_.style.width);
         var minY = ctrl_.initHeight - parseInt(res_ctrl_.style.height);
         var new_width = parseInt(this_.tbox.style.width) - minX;
         var new_height = parseInt(this_.tbox.style.height) - minY;

         // resize tboxes
         tbox.style.width = new_width + 'px';
         tbox.style.height = new_height + 'px';

         // resize cells in board
         var new_cellwidth = parseInt(tbox.style.width) / 8;
         var new_cellheight = parseInt(tbox.style.height) / 8;

         var hdr_height = parseInt(this_.header_.style.height);
         var ftr_height = parseInt(this_.footer_.style.height);
         this_.cellwidth = new_cellwidth;
         this_.cellheight = new_cellheight;
         this_.header_.style.width = (new_width + paddingL + paddingR) + 'px';
         this_.footer_.style.width = (new_width + paddingL + paddingR) + 'px';
         this_.footer_.style.top = (new_height + paddingT + paddingB + hdr_height) + 'px';

         // resize message board
         this_.msg_board_.style.width = (new_width + (paddingL + paddingR)) + 'px';
         this_.msg_board_.style.top = (new_height + (paddingT + paddingB) + hdr_height + ftr_height + brdr_) + 'px';

       


         for (var p in Board) {
             const board = Board[p];
             const td = board.td_;
             const img = getImage(board.td_);
             td.parentNode.style.width = new_cellwidth + 'px';
             td.parentNode.style.height = new_cellheight + 'px';
             td.style.width =  new_cellwidth  + 'px';
             td.style.height = new_cellheight + 'px';
             if (img != null) {
               img.style.width =  ( new_cellwidth ) + 'px';
               img.style.height = ( new_cellheight ) + 'px';
             }
            
         }

         // resize cells in bench
         for (var p in Bench) {
            const board = Bench[p];
            if (board.piece != null) {
                const td = board.td_;
                const img = getImage(board.td_);
                td.parentNode.style.width = new_cellwidth + 'px';
                td.parentNode.style.height = new_cellheight + 'px';
                td.style.width =  new_cellwidth  + 'px';
                td.style.height = new_cellheight + 'px';
                if (img != null) {
                  img.style.width =  ( new_cellwidth )  + 'px';
                  img.style.height = ( new_cellheight ) + 'px';
                }
             }
         }

         // Reposition message windows
         const msg = tbox.msgwin_;
         var twidth = parseInt(this_.tbox.style.width);
         var theight = parseInt(this_.tbox.style.height);
         var width = parseInt(msg.style.width);
         var height = parseInt(msg.style.height);
         var left = (twidth - width ) / 2;
         var top = (theight - height ) / 2;
         msg.style.left = left + 'px';
         msg.style.top = top + 'px';

         // resize waiting window
         const waiting = tbox.waiting_;
         var width = parseInt(waiting.style.width);
         var height = parseInt(waiting.style.height);
         var left = (twidth - width ) / 2;
         var top = (theight - height ) / 2;
         waiting.style.left = left + 'px';
         waiting.style.top = top + 'px';

         ctrl_.style.width = res_ctrl_.style.width;
         ctrl_.style.height = res_ctrl_.style.height;
         res_ctrl_.style.visibility = 'hidden';

         // Config
         CONFIG_.boards[this_.id].width = parseInt(ctrl_.style.width);
         CONFIG_.boards[this_.id].height = parseInt(ctrl_.style.height);
log(CONFIG_);

         // reposition setpiece

         // disable capture display for small board sizes
         if (parseInt(res_ctrl_.style.width) < 350) {
             this_.hdr_capture_.style.visibility = 'hidden';
             this_.ftr_capture_.style.visibility = 'hidden';
         } else {
             this_.hdr_capture_.style.visibility = '';
             this_.ftr_capture_.style.visibility = '';
         }

         // resize setposition
         var tbox = this.tbox;
         const setfen = tbox.setfen_;
         const offsetT = parseInt(this_.resizeContainer_.style.height) + 10;
         const fwidth = parseInt(setfen.style.width);
         setfen.style.top = offsetT + 'px';
         setfen.style.left = ((twidth - fwidth)/2) + 'px';
         
          // adjust setPiece
          tbox.setpiece_.style.left = (parseInt(tbox.style.width) + paddingL + paddingR + 3) + 'px';
          this.adjustSetPiece(); 

          // adjust Three checks
          tbox.threechecks_.style.left = (parseInt(tbox.style.width) + paddingL + paddingR + 3) + 'px';
          this.adjustThreeChecks(); 

          // chess moves
          // give it a space distance of 55 pixels
          this_.chmoves_.style.left = (parseInt(tbox.style.width) + paddingL + paddingR + 3 + 55) + 'px';
         
     }

     alignBoardNumbering(Board, tbox) {
         for (var i=8; i>=1; i--) {
            var anum = Board['h' + i].td_.anum_;
            var bnum = Board[horiz[8-i] + 1].td_.bnum_;
            anum.innerHTML = (tbox.reversed_) ? (9 - i) : i;
            bnum.innerHTML = (tbox.reversed_) ? horiz[i - 1] : horiz[ 8 - i];
         }
     }

     adjustSetPiece() {
         var this_ = this;
         var tbox = this_.tbox;
         var setpiece = tbox.setpiece_;
         if (this_.GAME_STATE.variant == CRAZYHOUSE) {
            const divs = setpiece.getElementsByTagName('div');
            var wpiece = null, bpiece = null;
            for (var p in divs) {
                const div = divs[p];
                if (div.nodeType == 1) {
                   if (div.id == 'wpieceid') wpiece = div;
                   if (div.id == 'bpieceid') bpiece = div;
                }
            }
            if (wpiece != null && bpiece != null) {
                 const height =  tbox.clientHeight - bpiece.clientHeight;
                 if (tbox.reversed_) {
                    wpiece.style.top = '0px';
                    bpiece.style.top = height + 'px';
                 } else {
                    wpiece.style.top = height + 'px';
                    bpiece.style.top = '0px';
                 }
            }
         }
     }

     adjustThreeChecks() {
         var this_ = this;
         var tbox = this_.tbox;
         var threechecks = tbox.threechecks_;
         if (this_.GAME_STATE.variant == THREECHECKS) {
            const divs = threechecks.getElementsByTagName('div');
            var wpiece = null, bpiece = null;
            for (var p in divs) {
                const div = divs[p];
                if (div.nodeType == 1) {
                   if (div.id == 'wpieceid') wpiece = div;
                   if (div.id == 'bpieceid') bpiece = div;
                }
            }
            if (wpiece != null && bpiece != null) {
                 const height =  tbox.clientHeight - bpiece.clientHeight;
                 if (tbox.reversed_) {
                    wpiece.style.top = '0px';
                    bpiece.style.top = height + 'px';
                 } else {
                    wpiece.style.top = height + 'px';
                    bpiece.style.top = '0px';
                 }
            }
         }
     }

     setMole(mole, color = null) {
log("set the mole ...");
log(mole);
        var this_ = this;
        var white_side = (color != null) ? color : this_.OURSIDE_;
/*
        var wmoles = null, bmoles = null, MOLE = null; 
        if (mole >= 0 && mole <=9) {
           wmoles = ['a2','b2','c2','d2','e2','f2','g2','h2'];
           bmoles = ['a7','b7','c7','d7','e7','f7','g7','h7'];
           MOLE = Math.round(Math.random() * 7) 
        } else 
        if (mole >= 10 && mole <= 12) {
           wmoles = ['b1','g1'];
           bmoles = ['b8','g8'];
           MOLE = Math.round(Math.random() * 1) 
        } else
        if (mole >= 13 || mole <= 14) {
           wmoles = ['a1','h1'];
           bmoles = ['a8','h8'];
           MOLE = Math.round(Math.random() * 1) 
        }
*/
        var Board = this_.ChessBoard.Board;
        var loc = mole; // null;
        if (white_side == WHITE) {
           //var loc = bmoles[MOLE]; // set a mole on black side
           var piece = Board[loc].piece;
           if (piece != null) {
               if (this_.OURSIDE_ == WHITE) {
                  var p_ = null;
                  if (piece.role == 'P') p_ = 'mpdt';
                  if (piece.role == 'R') p_ = 'mrdt';
                  if (piece.role == 'N') p_ = 'mndt';
                  piece.img_.src = getImgSrc(p_); 
               }
               piece.mole_ = WHITE;
           }
        } else {
           // var loc = wmoles[MOLE]; // set a mole on black side
           var piece = Board[loc].piece;
           if (piece != null) {
               if (this_.OURSIDE_ == BLACK ) {
                  var p_ = null;
                  if (piece.role == 'P') p_ = 'mplt';
                  if (piece.role == 'R') p_ = 'mrlt';
                  if (piece.role == 'N') p_ = 'mnlt';
                  piece.img_.src = getImgSrc(p_); 
               }
               piece.mole_ = BLACK;
           }
        }
     }

     revealMole(piece) {
        var this_ = this;
        var our_side = this_.OURSIDE_;
        if (piece.mole_ != null) {
           var loc = parseInt(piece.location_[1]);

           if (our_side == piece.mole_) {
               if (our_side == WHITE) {
                 if (loc <= 4) {
                      var c_ = null, p_ = null;
                      if (piece.color == 'pdt') { c_ = 'pdt'; p_ = 'plt'; } else
                      if (piece.color == 'ndt') { c_ = 'ndt'; p_ = 'nlt'; } else
                      if (piece.color == 'rdt') { c_ = 'rdt'; p_ = 'rlt'; } 
                      if (piece.color == c_) {
                         piece.img_.src = getImgSrc(p_); 
                         piece.color_ = p_;
                         delete piece.mole_;
                         chess_whistle.play();
                         notice("Mole has been revealed on " + piece.location_ );
                         if (!(this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE)) {
                           socket.emit("revealmole", { sessionid: SESSION_.sessionid, username: SESSION_.username,
                                      mole: piece.location_, ismole: true, istraitor: false, game: this_.rematch_ });
                         }    
                      }
                 }
               } else
               if (our_side == BLACK) {
                 if (loc >= 5) {
                      var c_ = null, p_ = null;
                      if (piece.color == 'plt') { c_ = 'plt'; p_ = 'pdt'; } else
                      if (piece.color == 'nlt') { c_ = 'nlt'; p_ = 'ndt'; } else
                      if (piece.color == 'rlt') { c_ = 'rlt'; p_ = 'rdt'; } 
                      if (piece.color == c_) {
                         piece.img_.src = getImgSrc(p_); 
                         piece.color_ = p_;
                         delete piece.mole_;
                         chess_whistle.play();
                         notice("Mole has been revealed on " + piece.location_ );
                         if (!(this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE)) {
                            socket.emit("revealmole", { sessionid: SESSION_.sessionid, username: SESSION_.username,
                                      mole: piece.location_, ismole: true, istraitor: false, game: this_.rematch_ });
                         }
                      }
                 }
               }
           } else {
log("their side ...");
               if (our_side == WHITE) {
                 if (loc >= 5) {
log("got here 1 ...");
log(piece);
                      var c_ = null, p_ = null;
                      if (piece.color == 'plt') { c_ = 'plt'; p_ = 'pdt'; } else
                      if (piece.color == 'nlt') { c_ = 'nlt'; p_ = 'ndt'; } else
                      if (piece.color == 'rlt') { c_ = 'rlt'; p_ = 'rdt'; }
                      if (piece.color == c_) {
                         piece.img_.src = getImgSrc(p_);
                         piece.color_ = p_;
                         delete piece.mole_;
                         chess_whistle.play();
                         notice("Mole has been revealed on " + piece.location_ );
                         if (!(this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE)) {
                           socket.emit("revealmole", { sessionid: SESSION_.sessionid, username: SESSION_.username,
                                      mole: piece.location_, ismole: true, istraitor: false, game: this_.rematch_ });
                         }
                      }
                 }
               } else
               if (our_side == BLACK) {
                 if (loc <= 4) {
log("got here 2 ...");
log(piece);
                      var c_ = null, p_ = null;
                      if (piece.color == 'pdt') { c_ = 'pdt'; p_ = 'plt'; } else
                      if (piece.color == 'ndt') { c_ = 'ndt'; p_ = 'nlt'; } else
                      if (piece.color == 'rdt') { c_ = 'rdt'; p_ = 'rlt'; }
                      if (piece.color == c_) {
                         piece.img_.src = getImgSrc(p_);
                         piece.color_ = p_;
                         delete piece.mole_;
                         chess_whistle.play();
                         notice("Mole has been revealed on " + piece.location_ );
                         if (!(this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE)) {
                           socket.emit("revealmole", { sessionid: SESSION_.sessionid, username: SESSION_.username,
                                      mole: piece.location_, ismole: true, istraitor: false, game: this_.rematch_ });
                         }
                      }
                 }
               }
           } 
        }
     }

     setTraitor(mole, color = null) {
        var this_ = this;
        var white_side = (color != null) ? color : this_.OURSIDE_;
        var wmoles = null, bmoles = null, MOLE = null;
        if (mole >= 0 && mole <=9) {
           wmoles = ['a2','b2','c2','d2','e2','f2','g2','h2'];
           bmoles = ['a7','b7','c7','d7','e7','f7','g7','h7'];
           MOLE = Math.round(Math.random() * 7)
        } else
        if (mole >= 10 && mole <= 12) {
           wmoles = ['b1','g1'];
           bmoles = ['b8','g8'];
           MOLE = Math.round(Math.random() * 1)
        } else
        if (mole >= 13 || mole <= 14) {
           wmoles = ['a1','h1'];
           bmoles = ['a8','h8'];
           MOLE = Math.round(Math.random() * 1)
        }
        var Board = this_.ChessBoard.Board;
        var loc = null;
        if (white_side == WHITE) {
           var loc = bmoles[MOLE]; // set a mole on black side
           var piece = Board[loc].piece;
           if (piece != null) {
               piece.mole_ = WHITE;
           }
        } else {
           var loc = wmoles[MOLE]; // set a mole on black side
           var piece = Board[loc].piece;
           if (piece != null) {
               piece.mole_ = BLACK;
           }
        }
     }

     revealTraitor(piece) {
        var this_ = this;
        var our_side = this_.OURSIDE_;
        if (piece.mole_ != null) {
           var loc = parseInt(piece.location_[1]);

           if (our_side == piece.mole_) {
               if (our_side == WHITE) {
                 if (loc <= 4) {
                      var c_ = null, p_ = null;
                      if (piece.color == 'pdt') { c_ = 'pdt'; p_ = 'plt'; } else
                      if (piece.color == 'ndt') { c_ = 'ndt'; p_ = 'nlt'; } else
                      if (piece.color == 'rdt') { c_ = 'rdt'; p_ = 'rlt'; }
                      if (piece.color == c_) {
                         piece.img_.src = getImgSrc(p_);
                         piece.color_ = p_;
                         delete piece.mole_;
                         chess_whistle.play();
                         notice("Traitor has been revealed on " + piece.location_ );
                         if (!(this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE)) {
                            socket.emit("revealmole", { sessionid: SESSION_.sessionid, username: SESSION_.username,
                                      mole: piece.location_, ismole: false, istraitor: true, game: this_.rematch_ });
                         }
                      }
                 }
               } else
               if (our_side == BLACK) {
                 if (loc >= 5) {
                      var c_ = null, p_ = null;
                      if (piece.color == 'plt') { c_ = 'plt'; p_ = 'pdt'; } else
                      if (piece.color == 'nlt') { c_ = 'nlt'; p_ = 'ndt'; } else
                      if (piece.color == 'rlt') { c_ = 'rlt'; p_ = 'rdt'; }
                      if (piece.color == c_) {
                         piece.img_.src = getImgSrc(p_);
                         piece.color_ = p_;
                         delete piece.mole_;
                         chess_whistle.play();
                         notice("Traitor has been revealed on " + piece.location_ );
                         if (!(this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE)) {
                            socket.emit("revealmole", { sessionid: SESSION_.sessionid, username: SESSION_.username,
                                      mole: piece.location_, ismole: false, istraitor: true, game: this_.rematch_ });
                         }
                      }
                 }
               }
           } else {
log("their side ...");
               if (our_side == WHITE) {
                 if (loc >= 5) {
log("got here 1 ...");
log(piece);
                      var c_ = null, p_ = null;
                      if (piece.color == 'plt') { c_ = 'plt'; p_ = 'pdt'; } else
                      if (piece.color == 'nlt') { c_ = 'nlt'; p_ = 'ndt'; } else
                      if (piece.color == 'rlt') { c_ = 'rlt'; p_ = 'rdt'; }
                      if (piece.color == c_) {
                         piece.img_.src = getImgSrc(p_);
                         piece.color_ = p_;
                         delete piece.mole_;
                         chess_whistle.play();
                         notice("Traitor has been revealed on " + piece.location_ );
                         if (!(this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE)) {
                           socket.emit("revealmole", { sessionid: SESSION_.sessionid, username: SESSION_.username,
                                      mole: piece.location_, ismole: true, istraitor: false, game: this_.rematch_ });
                         }
                      }
                 }
               } else
               if (our_side == BLACK) {
                 if (loc <= 4) {
log("got here 2 ...");
log(piece);
                      var c_ = null, p_ = null;
                      if (piece.color == 'pdt') { c_ = 'pdt'; p_ = 'plt'; } else
                      if (piece.color == 'ndt') { c_ = 'ndt'; p_ = 'nlt'; } else
                      if (piece.color == 'rdt') { c_ = 'rdt'; p_ = 'rlt'; }
                      if (piece.color == c_) {
                         piece.img_.src = getImgSrc(p_);
                         piece.color_ = p_;
                         delete piece.mole_;
                         chess_whistle.play();
                         notice("Traitor has been revealed on " + piece.location_ );
                         if (!(this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE)) {
                           socket.emit("revealmole", { sessionid: SESSION_.sessionid, username: SESSION_.username,
                                      mole: piece.location_, ismole: true, istraitor: false, game: this_.rematch_ });
                         }
                      }
                 }
               }
           }
        }
     }

     reverseBoard(e, this_ = null) {

         // check if invoked from control tool
         var controlled_ = ( e != null && typeof(e.detail) != "undefined" );
         var this_ = (controlled_) ? this.game_ : this_;

         var Board = this_.ChessBoard.Board;
         var Bench = this_.ChessBoard.Bench;
         var tbox  = this_.ChessBoard.tbox;
         var hints = this_.MoveHint_;
         var temp_board_ = {};
         tbox.style.visibility = "hidden";
         for (var p in Board) {
            var board = Board[p];
            const b_ = document.createElement('div');
            const img = getImage(board.td_);
            if (img != null) {
               b_.appendChild(img);
               temp_board_[board.td_.id] = { div: b_ } 
            }
         }
         for (var p in temp_board_) {
             var board = temp_board_[p];
             var revLoc = reverseLoc(p);
             Board[revLoc].td_.appendChild(board.div.firstChild);
         }
         if (controlled_) tbox.reversed_ = !tbox.reversed_;
         if (hints.length > 0) {
            const last = hints[hints.length - 1];
            var rvs_src_ = reverseLoc(last.src);
            var rvs_dst_ = reverseLoc(last.dst);
            this_.resetHint(rvs_src_);
            this_.resetHint(rvs_dst_);
            this_.resetHint(last.src, false);
            this_.resetHint(last.dst, false);
         }

         this_.adjustSetPiece();
         this_.adjustThreeChecks();

         this_.alignBoardNumbering(Board, tbox);
         // infoHeader(game);
         // setRate();
         this_.reversePlayers();
         this_.postScore();
         tbox.style.visibility = "visible";
     }

     reversePlayers() {
         var reversed = this.tbox.reversed_;
         var p = null, e = null, c = null, t = null, tl = null;
         p = this.hdr_player_.innerHTML;
         e = this.hdr_elo_.innerHTML;
         c = this.hdr_capture_.innerHTML;
         t = this.hdr_timer_.innerHTML;
         tl = this.hdr_title_.innerHTML;
         this.hdr_player_.innerHTML = this.ftr_player_.innerHTML;
         this.hdr_elo_.innerHTML = this.ftr_elo_.innerHTML;
         this.hdr_capture_.innerhTML = this.ftr_capture_.innerHTML;
         this.hdr_timer_.innerHTML = this.ftr_timer_.innerHTML;
         this.hdr_title_.innerHTML = this.ftr_title_.innerHTML;
         this.ftr_player_.innerHTML = p;
         this.ftr_elo_.innerHTML = e;
         this.ftr_capture_.innerHTML = c;
         this.ftr_timer_.innerHTML = t;
         this.ftr_title_.innerHTML = tl;

     }

     pinBoard(e) {
      if(!e.detail || e.detail == 1){
         e.preventDefault();
         var this_ = this.game_;
         pinCube(this_.id);  
       }
     }
 
     setPosition(e) {
      if(!e.detail || e.detail == 1){
          e.preventDefault();
        var this_ = this.game_;
        var tbox = this_.tbox;
        if (this_.GAME_STATE.status_ == STATUS.SET) {
          tbox.setpiece_.style.visibility = 'hidden';
          tbox.setfen_.style.visibility = 'hidden';
          delete tbox.setposmode_;
          this_.GAME_STATE.status_ = STATUS.INIT;
          this_.sideBoard();
          keyPress(false);
        } else {
          var this_ = this.game_;
          var tbox = this_.tbox;
          this_.quiesce_system(this_);
          this_.clearBoard(this_);
          tbox.setpiece_.style.visibility = 'visible';
          tbox.setfen_.style.visibility = 'visible';
          this_.GAME_STATE.status_ = STATUS.SET;
          this_.sideBoard();
          this_.game_ = this_;
          this_.setSquare(e, 700);
          keyPress(true);
        }
      }
     }

     disableBoardNumbers(e) {
       var this_  = this.game_;
       const Board = this_.ChessBoard.Board;
       var tnum = this_.tbox.disablenum_;
       const color = this_.tbox.boardcolor_;
       this_.tbox.disablenum_ = (tnum == null) ? true: !tnum;
          // color Numbers
       for (var i=8; i>=1; i--) {
            var anum = Board['h' + i].td_.anum_;
            var bnum = Board[horiz[8-i] + 1].td_.bnum_;
            if (!tnum) {
              anum.style.color = (i % 2) ? color.lt : color.dt;
              bnum.style.color = (i % 2) ? color.lt : color.dt;
            } else {
              anum.style.color = (i % 2) ? color.dt : color.lt;
              bnum.style.color = (i % 2) ? color.dt : color.lt;
            }
       }

     } 

     slideMove(e) {
      if(!e.detail || e.detail == 1){
       e.preventDefault();
       var this_  = this.game_;
       this_.tbox.slidemove_ = (this_.tbox.slidemove_ == null) ? true : !this_.tbox.slidemove_;
      }
     }

     setSquare(e, size = null) {
      if(!e.detail || e.detail == 1){
       e.preventDefault();
       var this_  = this.game_;
       var res_ctrl_ = this_.resizeContainer_;
       var rwidth  = parseInt(res_ctrl_.style.width);
       var rheight = parseInt(res_ctrl_.style.height);
       var width  = parseInt(this_.tbox.style.width);
       var height = parseInt(this_.tbox.style.height);
       var size_ = (width < height) ? width : height;
       if (size != null) size_ = size;
       var minX = size_ - width;
       var minY = size_ - height;
       this_.container_.initWidth = rwidth;
       this_.container_.initHeight = rheight;
       res_ctrl_.style.visibility = 'visible';
       res_ctrl_.style.width =  (rwidth + minX) + 'px';
       res_ctrl_.style.height = (rheight + minY)  + 'px';
       document.setsquaregame_ = this_;
       this_.resizeBoard(e, (size != null) ? true : false );
       this_.showPGN({ detail: 1, preventDefault: function() {}} , 1);
       this_.postScore();

       adjustAllLayout(this_);
       delete document.setsquaregame_;
      }
     }

     maxSize(e, this_) {
       var ctrl_ = this_.container_;
       var res_ctrl_ = this_.resizeContainer_;
       var rwidth  = parseInt(res_ctrl_.style.width);
       var rheight = parseInt(res_ctrl_.style.height);
       var width  = parseInt(this_.tbox.style.width);
       var height = parseInt(this_.tbox.style.height);
       var size = (width < height) ? width : height;
       var psize = pageSize();
       var minX = (psize.height - 200)  - width;
       var minY = (psize.height - 200) - height;
       this_.container_.initWidth = rwidth;
       this_.container_.initHeight = rheight;
       res_ctrl_.style.visibility = 'visible';
       res_ctrl_.style.width =  (rwidth + minX) + 'px';
       res_ctrl_.style.height = (rheight + minY)  + 'px';

       const oldpos_ = { top: ctrl_.style.top, left: ctrl_.style.left, width: width, height: height };
       document.setsquaregame_ = this_;
       this_.resizeBoard(null);
       this_.showPGN({ detail: 1, preventDefault: function() {}} , 1);
       this_.postScore();

       if (ctrl_.oldpos_ == null) {
         const pos = scrollOffset(e, false);
         ctrl_.oldpos_ = oldpos_;
         ctrl_.style.top = (pos.y + 50) + 'px';
         res_ctrl_.style.top =  (pos.y + 50) + 'px';
         ctrl_.style.left = '100px'; // (pos.x + (psize.width - ctrl_.clientWidth)/2) + 'px';
         res_ctrl_.style.left = (pos.x + (psize.width - ctrl_.clientWidth)/2) + 'px';
       } else {
         adjustSquare(this_, ctrl_.oldpos_.width, ctrl_.oldpos_.height);
         ctrl_.style.top = ctrl_.oldpos_.top;
         res_ctrl_.style.top = ctrl_.oldpos_.top;
         ctrl_.style.left = ctrl_.oldpos_.left;
         res_ctrl_.style.left = '100px'; // ctrl_.oldpos_.left;
         delete ctrl_.oldpos_;
       }
       delete document.setsquaregame_;
     }

     chooseTimer(e) {
      if(!e.detail || e.detail == 1){
       e.preventDefault();
       var this_ = this.game_;
log("choose timer");
      }
     }

     closeBoard(e) {
      if(!e.detail || e.detail == 1){
       e.preventDefault();
       var this_ = this.game_;
log(this);
log(this.game_);
       this_.container_.remove();
       if (this_.GAME_STATE.ptimer_ != null) { clearInterval(this_.GAME_STATE.ptimer_); }

       var tmp_brds = [];
log("deleting ...");
log(BOARDS_.length);
       while (BOARDS_.length) {
          var board = BOARDS_.pop();
          if (board.id != this_.id) tmp_brds.push(board);
          if (CONFIG_.boards[this_.id]) { delete CONFIG_.boards[this_.id]; }
       }
       Object.keys(this_).forEach(key => delete this_[key]);
       BOARDS_ = tmp_brds;
       if (BOARDS_.length) { 
         this_ = BOARDS_[0]; 
         adjustAllLayout(this_);
       }
log(BOARDS_.length);
log("close board");
      }
     }

     loadPGN(e) {
       if(!e.detail || e.detail == 1){
         e.preventDefault();
         var this_ = this.game_;
         this_.disablePopups();

         if (this_.GAME_STATE.status_ == STATUS.SET) return;
         // var top = 0;
         //var left = parseInt(this.style.left.replace(/px/,'')) - 70;
         var top = this.offsetTop + this.parentNode.offsetTop;
         var left = parseInt(this.style.left.replace(/px/,'')) - 10;
         chooseDatabase( this_, { y: top, x: left } );
       }
     }

     LOADINGPGN_ = false
     pgntime = null
     changeDatabase() {
          var this_ = this.game_;
          var pgn = this.value_;
          const pgn_ = "/pgn/" + pgn + ".pgn";
          if (this_.LOADINGPGN_) return;
          this_.LOADINGPGN_ = true;
          this_.pgn_interval = 0;
          this_.pgntime = setInterval(this_.readyPGN, 50, this_, pgn_);
     }

     pgn_interval = 0
     readyPGN(this_, pgn_) {
          if (this_.pgn_interval > 20) { 
		this_.pgn_interval = 0; clearInterval(this_.pgntime); 
		// message(this_, "Loading database ...", false); 
		this_.fetchPGN(this_, pgn_);
                return  
           }
          this_.pgn_interval ++;
          if (this_.LOADPGN_ == false) {
              this_.pgn_interval = 0;
              clearInterval(this_.pgntime);
              // message(this_, "Loading database ...", false);
              this_.fetchPGN(this_, pgn_);
          }
     }

     Games = []
     async fetchPGN(this_, pgn_){
          const res = await fetch(pgn_);
          const pgngame = await res.json();
          this_.Games = [];
          class Game {
             constructor (game) {
                var moves_ = game.moves.split(' ').length - 4; moves_ = Math.ceil(moves_ / 2);
                game.ct = moves_;
                this.detail_ = game;
             }
             get detail()  { return this.detail_; }
          }

          for (let i=0; i < pgngame.length; i++) {
               const game = new Game(pgngame[i])
               this_.Games.push(game.detail)
          }
          chessdiv.loadedgame_ = this_;
          await refreshListing(this_, this_.Games);
          this_.LOADINGPGN_ = false;

          showPGNWindow(null, true);

          // cover board for mouse movement
          // this_.tbox.cover_.style.visibility = 'visible';

          // clear old database (for now )
          for (var p in this_.PGNDB_) {
              delete this_.PGNDB_[p];
          }
          this_.PGNDB_ = {};
     }

     // CURRENT_GAME_ = 0
     CONTINUOUS_PLAY_ = false
     CONTINUOUS_INTERRUPTED = false
     async continuousPlay(e, spn) {
          var this_ = this;
           // interrupt async playing ...
           if (this_.GAME_STATE.playstatus_ == STATUS.PLAYING || this_.CONTINUOUS_PLAY_) { 
		this_.GAME_STATE.playstatus_ = STATUS.INTERRUPTED; 
	        return;
           }
           var Games = this_.Games;
           var len_ = Games.length, current_ = 0;
           if (this_.tbox.prevgame_ != null) current_ = parseInt(this_.tbox.prevgame_.value);
           if (Games.length == 0) { message(this_, "No database loaded!", false); return; }
           //   chess_awalker.playbackRate = 1.0;
           //   chess_awalker.currentTime = 1.0;
           //   chess_awalker.play();
            //  this_.GAME_STATE.playstatus_ = STATUS.PLAYING;
           this_.CONTINUOUS_PLAY_ = true;
           spn.innerHTML = '&#x26AC;';
           for (var i = current_; i < len_; i++) {
               const bt = document.getElementById("gameid_" + i);
               await bt.onclick(e); 
               if (this_.CONTINUOUS_INTERRUPTED) break;
               if (this_.GAME_STATE.playstatus_ == STATUS.INTERRUPTED) break;
           }
           this_.CONTINUOUS_INTERRUPTED = false;
           this_.GAME_STATE.playstatus_ = STATUS.STOPPED;
           this_.CONTINUOUS_PLAY_ = false;
           spn.innerHTML = '&#x25B6';
     }

     whichSound(restype) {
        if (restype == GOODMOVE) { chess_move.currentTime = 0; chess_move.play(); return; }; 
        if (restype == EATPIECE || restype == ENPASSANT) { chess_capture.currentTime = 0; chess_capture.play(); return; }; 
        if (restype == CASTLESHORT || restype == CASTLELONG) { chess_castle.currentTime = 0; chess_castle.play(); return; }; 
        chess_move.currentTime = 0; chess_move.play();
     }

     async playNext(e) {
       e.preventDefault();
       if(!e.detail || e.detail == 1) {
          // replaying current game
          var this_ = this.game_;
          var node = this.parentNode.parentNode;
     
          if (this.game_.GAME_STATE.playstatus_ ==  STATUS.PLAYING) {
                this.game_.GAME_STATE.playstatus_ = STATUS.INTERRUPTED;
                this.innerHTML = "&#8594;"
                node.className = 'chesstr';
          } else {
                var bgcolor = node.style.backgroundColor;
                this.game_.tbox.prevgame_ = this;
                this.innerHTML = "&#9675;"
                node.className = 'chesstr chesstrcurrent';
		node.style.backgroundColor = '#6a6a6a';
              
                await this.game_.play(e, this.value, this.game_.MUSIC_TIME);
                this.innerHTML = "&#8594;"
                node.className = 'chesstr';
		node.style.backgroundColor = bgcolor;
          }
       }
     }


     PGNDB_ = {}
     MUSIC_TIME = 330.924;
     async play(e, value, MUSIC_TIME = null) {
       const this_ = this;
       const notes = this_.Notes_;
       var current_ = this_.Games[value];
       if (typeof(this_.PGNDB_[value]) == "undefined") {
          this_.newGame(e, this_, false);
          this_.recordPlayers(current_);
          var fens = await this_.recordFEN(value);
          this_.PGNDB_[value] = fens;
       } else { chess_reset.currentTime = 0; chess_reset.play();  }
       const mymoves = this_.PGNDB_[value];
       if (this_.GAME_STATE.playstatus_ == STATUS.STOPPED) {
          this_.GAME_STATE.playstatus_ = STATUS.PLAYING;
          this_.recordPlayers(current_);
          this_.quiesce_system(this_, false);
          this_.clearBoard(this_);
          this_.setFENonBoard(wINITFEN_, this_);
          await this_.setMoves(this_, current_.moves);
          current_ = null;
          await pause(1000);
       }
       this_.GAME_STATE.gamecurrent_  = value;
       this_.GAME_STATE.playstatus_ = STATUS.PLAYING;
       for (var p in mymoves) {
           current_ = await this_.jumpMove(null, p);
           this_.GAME_STATE.playcurrent_  = p;
           await pause(500);
           if (this_.GAME_STATE.playstatus_ == STATUS.INTERRUPTED ||
             this_.GAME_STATE.playstatus_ == STATUS.STOPPED)  return;
       }
       this_.GAME_STATE.playstatus_ = STATUS.STOPPED;
     }

     async recordFEN(value) {
       //  const fens_ = [];
         const this_ = this;
         var cnt = 0, fen = null;
         var current_ = this_.Games[value];

         this_.quiesce_system(this_, true);
         this_.clearBoard(this_);
         this_.setFENonBoard(wINITFEN_, this_);

         await this_.setMoves(this_, current_.moves); 

         const fens_ = generateFENS(this_); // requires this_.Moves_

      /*
         for (var p in this_.Moves_) {
            const move = this_.Moves_[p];
            const turn = this_.simpleMove(this_, move, null);
            const restype = this_.captureMove(turn, HUMAN, NOTMANUAL, false, false, true);
            const fen = generateFEN(this, this.GAME_STATE.sidetomove_ == WHITE ? 'w' : 'b');
            const rmove_ = { fen: fen, turn: turn, restype: restype }
            fens_.push(rmove_);
         }
      */
         return fens_;
     }


     highlightMove(notes, current_) {
          var elem = null, move = null
          for (var p in notes.childNodes) {
            elem = notes.childNodes[p];
            if (elem.nodeType == 1) {
               move = elem.firstChild.nextSibling;
               move.className = 'chesspiecenomove';
            }
          }
          if (current_ == 0) return null;
          elem= notes.childNodes[current_ - 1];
          move = elem.firstChild.nextSibling;
          move.className = 'chesspiecemove';
          return move;
     }

     simpleMove(this_, turn, player = null) {
        var src_loc = null, dest_loc = null, role = null, src = null, hint = null;
        var move = turn.move.replace(/^[0-9]+\./,'');
        var color = turn.side;
        var promote = turn.promote;
        var len = move.length;
        role = move[0];
        dest_loc = move.slice(-2);

        if ( move.match(/(=)?(\([qbnr]\)|[qbnr])$/i) ) {
             promote = move.match(/(=)?(\([qbnr]\)|[qbnr])$/i)[0].replace(/[=()]/g,'');
             move = move.replace(/(=)?(\([qbnr]\)|[qbnr])$/i, '');
        }

        if (player == MACHINE || player == HUMAN) {
            src_loc  = move.slice(0, move.length - 2);
            dest_loc = move.slice(-2);
        } else
        if (move == "O-O") {
             src_loc = [ (color == 'lt') ? "e1" : "e8" ]; dest_loc = (color == 'lt') ? "g1" : "g8";
        } else
        if ( move == "O-O-O") {
             src_loc = [ (color == 'lt') ? "e1" : "e8" ]; dest_loc = (color == 'lt') ? "c1" : "c8";
        } else if (len == 2) {
             dest_loc = move;
             src_loc = find_location(this_, color, move[0], dest_loc);
        } else if (len == 3) {
             src_loc = find_location(this_, color, role, dest_loc);
        } else
        if (len == 4) { // e.g. Rxe1 exd1 Rhe1
             hint = move[1];
             if (hint != 'x') { hint = null; src = move[1]; }
             src_loc = find_location(this_, color, role, dest_loc, hint, src);
        } else
        if (len == 5) { // e.g. Rhxe1 R8xe1  Nh8g6
             hint = move[2];
             if (hint == 'x') {
                   src = move[1];
             } else {
                   hint = null;
                   src = move.slice(1,3).match(/[a-h][1-8]/)[0]
             }
             src_loc = find_location(this_, color, role, dest_loc, hint, src);
        } else
        if (len == 6) { // e.g. Rh8xe1
             src = move.slice(1,3); hint = move[3];
             src_loc = find_location(this_, color, role, dest_loc, hint, src);
        }
        log("Final " + color + " location: " + src_loc + " " + dest_loc + " " + promote);
        if (typeof(src_loc) != "string" && src_loc.length ==1) src_loc = src_loc[0];
        return { src: src_loc, dst: dest_loc, promote: promote };
    }


     setMoves(this_, moves_) {
         const parsed_ = parser.parse(moves_);
         const pmoves = parsed_[0];
         var moves = moves_.split(' ');

         var RS_ = null;
         if (parsed_[1] != "1-0" && parsed_[1] != "0-1" && parsed_[1] != "1/2-1/2") {
             pmoves.push([parsed_[1],['']]);
         } else {
             RS_ = parsed_[1];
         }

         this_.GAME_STATE.sidetomove_ = WHITE;
         this_.GAME_STATE.movecount_ = 0;
         for (var m in pmoves) {
            const move = pmoves[m][0];
            const wmove = move[2][0];
            const wprom = move[2][1].replace(/[=()]/g,'');
            const wchk = move[2][2];
            const wcmt = move[2][3];
            this_.recordMove(wmove, wprom, wchk, wcmt); 
            this_.GAME_STATE.sidetomove_ = (this_.GAME_STATE.sidetomove_ == WHITE) ? BLACK : WHITE;
            if (typeof(move[4]) == "object") {
              const bmove = move[4][0];
              const bprom = move[4][1].replace(/[=()]/g,'');
              const bchk = move[4][2];
              const bcmt = move[4][3];
              this_.recordMove(bmove, bprom, bchk, bcmt); 
              this_.GAME_STATE.sidetomove_ = (this_.GAME_STATE.sidetomove_ == WHITE) ? BLACK : WHITE;
            } else {
               RS_ = (RS_ != null) ? RS_ : move[4];
               break;
            }
            this_.GAME_STATE.movecount_ ++;
         }
         this_.recordScore(RS_);
         this_.GAME_STATE.sidetomove_ = WHITE;
         this_.GAME_STATE.movecount_ = 0;
    }

     loadPosition(e) {
       if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
          this_.disablePopups();    
          if (this_.GAME_STATE.status_ == STATUS.SET) return;
         // var top = 0; 
         // var left = parseInt(this.style.left.replace(/px/,'')) - 70;
          var top = this.offsetTop + this.parentNode.offsetTop;
          var left = parseInt(this.style.left.replace(/px/,'')) - 10;
          chooseAnalyze( this_, { y: top, x: left } );
       }
     }

     async analyzePosition() {
          var this_ = this.game_;
          var tbox  = this_.tbox;
          var fen = this.value_;
          var who_ = fen.split(' ')[1]
          var popup = document.getElementById('pop_chooseanalyzeid_' + this_.id);
          popup.parentNode.parentNode.style.visibility = 'hidden';
          await pause(250);
          try {
             const reverseB = checkPositionLegality(this_, fen);
             if (reverseB) {
               this_.resetBoard(wINITFEN_, this_ );
             } else {
               this_.resetBoard(fen, this_);
             }
             this_.GAME_STATE.status_ = STATUS.NEW;
             this_.GAME_STATE.sidetomove_ = (who_ == 'w') ? WHITE : BLACK;
             this_.sideBoard();
             this_.nextToPlay();
           } catch(e) { log(e) }
     }

     rematchGame(e, this_ = null) {
log("rematch ");
       if(!e.detail || e.detail == 1) { // avoid multiple clicks
          e.preventDefault();
          const this_ = this.game_;
log(this_.rematch_);
          closeGameSettings(null, this_);
log("rematch 1");
log(this_.BPLAYER_);
log(this_.WPLAYER_);
          if (this_.BPLAYER_ == MACHINE && this_.WPLAYER_ == HUMAN) {
log("rematch 1a");
                if (this_.rematch_ != null) {
log("rematch 1b");
                   const variant = variants[this_.rematch_.settings.variant - 1].item;
                   var match = this_.rematch_.wgame;
                   this_.rematch_.wgame = this_.rematch_.bgame;
                   this_.rematch_.bgame = match;
                   this_.BPLAYER_       = HUMAN;
                   this_.WPLAYER_       = MACHINE;
                   this_.rematch_.fen   = (variant == CHESS960) ? randomFENchess960() : wINITFEN_;
                   this_.startGame(this_.rematch_, false);
                   runEngine(this_);
                }
          } else
          if (this_.BPLAYER_ == HUMAN && this_.WPLAYER_ == MACHINE) {
log("rematch 2a");
                if (this_.rematch_ != null) {
log("rematch 2b");
                   const variant = variants[this_.rematch_.settings.variant - 1].item;
                   var match = this_.rematch_.wgame;
                   this_.rematch_.wgame = this_.rematch_.bgame;
                   this_.rematch_.bgame = match;
                   this_.WPLAYER_       = HUMAN;
                   this_.BPLAYER_       = MACHINE;
                   this_.rematch_.fen   = (variant == CHESS960) ? randomFENchess960() : wINITFEN_;
                   this_.startGame(this_.rematch_, true);
                }
          } else {
log("rematch 2");
             if (SESSION_.sessionid != null) {
log("rematch 3");
log(this_.rematch_);
                var msgwin = this_.tbox.msgwin_;
                const rematch = { username: SESSION_.username,
                                 sessionid: SESSION_.sessionid,
                                 utype: SESSION_.utype,
                                 gametoken: this_.rematch_.gametoken,
                                 rematch: true };
                socket.emit("match", rematch ); // ready for a match
                notice("Offering a rematch ...");
                msgwin.style.visibility = 'hidden';
             } else {
                notice("Please login first ...");
             }
          }
       }
     }

     /* Remove - obsoleted */
     seekMatch(e) {
       if(!e.detail || e.detail == 1) { // avoid multiple clicks
          e.preventDefault();
          const this_ = this.game_;
          closeGameSettings(null, this_);
          if (SESSION_.sessionid != null) {
                message(this_,"searching for a match ...", false);
                captureGameSettings(this_, false);

                const match = { username: SESSION_.username,
                                sessionid: SESSION_.sessionid,
                                gameid: this_.id,
                                room: 'Single Game',
                                gametoken: this_.GAME_STATE.gametoken_,
                                rematch: false,
                                settings: this_.tbox.humanoid_ };
                socket.emit("match", match); // ready for a match
          } else {
             message(this_,"Please login first ...", false);
          }
       } 
     }

     async startGame(match, white = true, missing_player = null) {
          // set board to white first ...
          var fen = wINITFEN_, variant = null; 
          if (this.BPLAYER_ == MACHINE || this.WPLAYER_ == MACHINE) {
             variant = compvariants[match.settings.variant - 1].item;
          } else {
             variant = variants[match.settings.variant - 1].item;
          }
          this.GAME_STATE.variant = variant;
log("start game variant: " + variant);
          if (this.GAME_STATE.variant == CHESS960 ||
              this.GAME_STATE.variant == HORDE) { fen = match.fen; }

          this.OURSIDE_ = (white) ? WHITE : BLACK;

          this.tbox.reversed_ = false;
          this.resetBoard(fen, this);  // this resets GAME_STATE
          this.GAME_STATE.fen_ = fen;
          this.GAME_STATE.variant = variant;
          this.GAME_STATE.sidetomove_ = WHITE;
          this.GAME_STATE.simul = (match.simul == null) ? false : match.simul;
          this.tbox.waiting_.style.visibility = 'hidden';
          this.hdr_player_.innerHTML = match.bgame.player; 
          this.ftr_player_.innerHTML = match.wgame.player; 
log("start games ....");
log(match);

          var helo = '', felo = '', rsystem = '';
          var gt = match.gametype;
          var wtitle = match.wgame.title;
          var btitle = match.bgame.title;
          var gametype_ = timer_types[match.gametype - 1];
          var wrating = match.wgame.rating[variant][gametype_];          
          var brating = match.bgame.rating[variant][gametype_];          
log(variant);
log(gametype_);
log(wrating);
log(brating); 
          if (CONFIG_.ratesystem == 'rmoo') {
             helo = brating.rmoo;
             felo = wrating.rmoo;
             rsystem = '(O)';
          } else
          if (CONFIG_.ratesystem == 'elo') {
             helo = brating.elo;
             felo = wrating.elo;
             rsystem = '(E)';
          } else
          if (CONFIG_.ratesystem == 'glicko2' || CONFIG_.ratesystem == 'glicko') {
             helo = brating.glicko;
             felo = wrating.glicko;
             rsystem = '(G2)';
          }
          this.hdr_title_.innerHTML = (btitle != null && btitle > 0) ? titles[btitle - 1].initial : '';
          this.ftr_title_.innerHTML = (wtitle != null && wtitle > 0) ? titles[wtitle - 1].initial : '';
          this.hdr_elo_.innerHTML = helo + ' ' + rsystem;
          this.ftr_elo_.innerHTML = felo + ' ' + rsystem;
          this.gameround_ = match.round;
          if (white) {
             this.opp_side_ = BLACK;
             this.GAME_STATE.remoteside_ = BLACK;
             this.GAME_STATE.remoteplayer_ = match.bgame.player;
             this.alignBoardNumbering(this.ChessBoard.Board, this.tbox);
          } else {
             this.opp_side_ = WHITE;
             this.GAME_STATE.remoteside_ = WHITE;
             this.GAME_STATE.remoteplayer_ =  match.wgame.player;
             this.tbox.reversed_ = true;
             this.reverseBoard(null, this);
          }

log("yes in mole 0 ..." + variant);
          if (variant == THEMOLE) {
log("yes in mole 1 ...");
               if (this.BPLAYER_ == MACHINE || this.WPLAYER_ == MACHINE) {
log("yes in mole 2 ...");
                   this.setMole(match.mole, WHITE);
                   this.setMole(match.mole, BLACK);
               } else
                   this.setMole(match.mole);
          } else
          if (variant == THETRAITOR) { 
               if (this.BPLAYER_ == MACHINE || this.WPLAYER_ == MACHINE) {
                   this.setTraitor(match.mole, WHITE);
                   this.setTraitor(match.mole, BLACK);
               } else
                   this.setTraitor(match.mole);
          }

          this.sideBoard(false);
          this.GAME_STATE.status_ = STATUS.NEW;
          this.GAME_STATE.playstatus_ = STATUS.PLAYING;
          this.GAME_STATE.gameover_ = 0;
          this.GAME_STATE.gametoken_ = match.gametoken;

          this.rematch_ = match; // reuse for rematches

          // preserve in cookie ...
          document.cookie = "playinggame_=" + this.GAME_STATE.gametoken_;
          document.cookie = "simul_=" + this.GAME_STATE.simul;
          SESSION_.status = (match.simul) ? STATUS.SIMULPLAYING : STATUS.PLAYING;
          if (missing_player != null) {
             notice("Waiting for player before forfeiting ...");
             this.notice("Game started but " + missing_player + " is not online ...");
          } else {
             notice("Playing " + this.GAME_STATE.variant  + " ...");
             this.notice("Game started. White to move ...");
          }
          await chess_reset.play();
     }

     capturePlayerMove(game) {
        var side = this.GAME_STATE.sidetomove_;
        if (game.username == SESSION_.username && game.side == side ) {
          const move = { move: game.move, side: game.side, check: null, promote: null }
          const turn = this.simpleMove(this, move, HUMAN); 
          this.captureMove(turn, HUMAN, NOTMANUAL);
        }
     }

     async newGame(e, this_ = null) {
        e.preventDefault();
        if(!e.detail || e.detail == 1) {
          var this_ = (this_ != null) ? this_ : this.game_;
          var fen = wINITFEN_; 
   
          if (this_.GAME_STATE.status_ == STATUS.SET) return;
          // if (this_.GAME_STATE.playstatus_ != STATUS.STOPPED) return;
          if (this_.UCI_NEW_GAME_READY) {
             this_.opp_side_ = BLACK;  // no choice option for now.
             this_.resetBoard(fen, this_);
             this_.sideBoard(false);
             chess_reset.play();
             this_.GAME_STATE.status_ = STATUS.NEW;
             this_.GAME_STATE.playstatus_ = STATUS.PLAYING;
             this_.GAME_STATE.gameover_ = 0;
             this_.setEngine();
             // Play First Move 
             await pause(1000);
             this_.nextToPlay();
          }
       }
     }

     createButton(title, color, bgcolor, top = 200, left = 5, width = 120, height = 40) {
        var dv = document.createElement('div');
        dv.style="position: absolute; font-family: helvetica; font-weight: bold; font-size: 12pt; border-radius: 2px; cursor: pointer";
        dv.style.top = top + 'px'; dv.style.left = left + 'px';
        dv.style.width = width + 'px'; dv.style.height = height + 'px';
        dv.style.backgroundColor = bgcolor;
        dv.style.color = color;

        var sp = document.createElement('span');
        dv.appendChild(sp);
        sp.style="position: absolute; display: block; width: 100%; text-align: center; top: 10px;";
        sp.innerHTML = title;
        return dv;
     } 

     msgClean() {
          var this_ = this;
          var tbox = this_.tbox;
          var msgid  = tbox.msgid_;
          while (msgid.lastChild) {
             const child = msgid.lastChild;
             msgid.removeChild(child);
          } 
          msgid.innerHTML = '';
     }

     msgDone(this_, rating, ratesystem_) {
       if (this_.GAME_STATE.gameover_) {
          var go = this_.GAME_STATE.gameover_;
          var tbox = this_.tbox;
          var wicon   = ' (&#x2656;)';
          var bicon   = ' (&#x265C;)';
          var fplayer = this.ftr_player_;
          var hplayer = this.hdr_player_;
          var helo    = this.hdr_elo_;
          var felo    = this.ftr_elo_;
          var msgwin = tbox.msgwin_;
          var msgid  = tbox.msgid_;
          var winner = ( this_.GAME_STATE.gameoverside_ == WHITE ) ? 'Black' : 'White';
          var result = ( this_.GAME_STATE.gameoverside_ == WHITE ) ? '0-1' : '1-0';
          var bywhat = null, draw = false;
          this_.msgClean();

          if (go == GAMEOVER.ABORTED) bywhat = 'by mutual agreement'; else

          if (go == GAMEOVER.FORFEITED) bywhat = 'by forfeiting opponent'; else

          if (go == GAMEOVER.HORDE) bywhat = 'by capturing all pieces'; else
          if (go == GAMEOVER.ATOMIC) bywhat = 'by explosion'; else
          if (go == GAMEOVER.THREECHECKS) bywhat = 'by three checks'; else
          if (go == GAMEOVER.KINGOFTHEHILL) bywhat = 'by reaching the hill';

          if (go == GAMEOVER.CHECKMATE) bywhat = 'by checkmate'; else
          if (go == GAMEOVER.TIMEOUT) bywhat = 'on time'; else
          if (go == GAMEOVER.ABANDONED) bywhat = 'by opponent abandonment'; else
          if (go == GAMEOVER.RESIGNED) bywhat = 'by opponent resignation'; 

          if (go == GAMEOVER.STALEMATE) bywhat = 'by stalemate'; else
          if (go == GAMEOVER.INSUFFICIENT) bywhat = 'by insufficient material'; else
          if (go == GAMEOVER.REPETITION) bywhat = 'by repetition'; else
          if (go == GAMEOVER.DRAWACCEPTED) bywhat = 'by mutual agreement';
          draw = (go == GAMEOVER.INSUFFICIENT || go == GAMEOVER.REPETITION || go == GAMEOVER.DRAWACCEPTED || go == GAMEOVER.STALEMATE);
          result = (draw) ? '1/2 - 1/2' : result;


          // main message
          var main=document.createElement('span');
          main.style="position: absolute; left: 0px; top: 5px;  font-weight: bold; font-size: 12pt";
          main.style.width = msgid.style.width;
          if (go == GAMEOVER.ABORTED) {
            result = '0-0';
            main.innerHTML = 'Game Aborted';
          } else {
            main.innerHTML = (draw) ? 'Draw' : winner + ' Won';
          }
          msgid.appendChild(main);

          // reason
          var b = document.createElement('span'); b.innerHTML = bywhat;
          b.style="position: absolute; left: 0px; top: 26px; font-family: helvetica; font-weight: normal; font-size: 10pt;  white-space: nowrap; text-align: center";
          b.style.width = msgid.style.width;
          b.style.color = '#880000';
          msgid.appendChild(b);

          // display players
          var h = document.createElement('span'); h.innerHTML = hplayer.innerHTML + ((tbox.reversed_) ? wicon : bicon );
          var s = document.createElement('span'); s.innerHTML = '<br><span style="color: #800000">' + result + '</span><br>';
          var f = document.createElement('span'); f.innerHTML = fplayer.innerHTML + ((tbox.reversed_) ? bicon : wicon );
          var s1 = document.createElement('span');
          s1.style="position: absolute; display: block; top: 60px; font-weight: normal; font-size: 10pt";
          s1.style.width = msgid.style.width;
          s1.appendChild(h); s1.appendChild(s); s1.appendChild(f);
          msgid.appendChild(s1);
          msgid.style.textAlign = 'center';

          // Rating
          var srating = '', rate = 1500, points = 0;
          if (ratesystem_ == 'rmoo') {
              rate = (tbox.reversed_) ? rating.brating.rmoo : rating.wrating.rmoo;
              points = parseInt( (tbox.reversed_) ? rating.bpoints.rmoo_p : rating.wpoints.rmoo_p );
              srating = '(O)'; 
          } else
          if (ratesystem_ == 'elo') {
              rate = (tbox.reversed_) ? rating.brating.elo : rating.wrating.elo;
              points = parseInt( (tbox.reversed_) ? rating.bpoints.elo_p : rating.wpoints.elo_p );
              srating = '(E)'; 
          } else
          if (ratesystem_ == 'glicko2' || ratesystem_ == 'glicko') {
              rate = (tbox.reversed_) ? rating.brating.glicko : rating.wrating.glicko;
              points = parseInt( (tbox.reversed_) ? rating.bpoints.glicko_p : rating.wpoints.glicko_p );
              srating = '(G2)'; 
           }

          var r = document.createElement('span'); r.innerHTML = srating + ' ' + rate; 
          r.style="position: absolute; left: 0px; top: 130px; font-weight: bold; font-size: 18pt; color: #800000;";
          r.style.width = msgid.style.width;
          msgid.appendChild(r);

          // Earn
          var e = document.createElement('span'); e.innerHTML = 'You ' + ((points >=0) ? ' earned ' : ' lost ') + Math.abs(points) + ' points!';
          e.style="position: absolute; left: 0px; top: 160px; font-family: helvetica; font-weight: normal; font-size: 10pt;  white-space: nowrap; text-align: center";
          e.style.width = msgid.style.width;
          msgid.appendChild(e);

          // buttons
log("simultaneous or tourney ...");
log(this_.GAME_STATE.simul);
log(this_.GAME_STATE.tourney);
          if (this_.GAME_STATE.tourney) {
             var btn1 = this.createButton('Wait For Next Round', '#252525', '#81d765', 200, 5, 230, 40);
             btn1.onmousedown = function() { this.style.color = '#ffffff' }
             btn1.onmouseup = function() { this.style.color = '#252525' }
             btn1.onclick = nextRound;
             btn1.game_ = this_;
             msgid.appendChild(btn1);
          } else
          if (this_.GAME_STATE.simul) {
             var btn1 = this.createButton('New Game', '#252525', '#81d765', 200, 5, 230, 40);
             btn1.onmousedown = function() { this.style.color = '#ffffff' }
             btn1.onmouseup = function() { this.style.color = '#252525' }
             btn1.onclick = playGame;
             btn1.game_ = this_;
             msgid.appendChild(btn1);
          } else {
             var btn1 = this.createButton('Rematch', '#252525', '#81d765', 200, 5, 110, 40);
             var btn2 = this.createButton('New Game', '#252525', '#81d765', 200, 125, 110, 40);
             btn1.onmousedown = function() { this.style.color = '#ffffff' }
             btn1.onmouseup = function() { this.style.color = '#252525' }
             btn2.onmousedown = function() { this.style.color = '#ffffff' }
             btn2.onmouseup = function() { this.style.color = '#252525' }
             btn1.onclick = this_.rematchGame;
             btn2.onclick = playGame; 
             btn1.game_ = this_;
             btn2.game_ = this_;
             msgid.appendChild(btn1);
             msgid.appendChild(btn2);
          } 

          msgwin.style.visibility = 'visible';
          this.notice((go == GAMEOVER.ABORTED) ? "Game aborted ..." : "Game over ...");
          isActivePlay();
       }
     }

     doneGame(reason = null) {
          log("done Game ..."); 
          this.GAME_STATE.status_ = STATUS.DONE;
          this.sideBoard(true);
          this.stopTimer();
          this.recordResult(this, reason);
     }

     resignGame(e) {
       if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
          if (this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE) {
              if (this_.BPLAYER_ == HUMAN) {
                 this_.GAME_STATE.gameoverside_ = BLACK; // us
              } else {
                 this_.GAME_STATE.gameoverside_ = WHITE; // us
              }
              this_.GAME_STATE.gameover_ = GAMEOVER.RESIGNED;
              this_.checkGameOver();
          } else {
             // let the other party know.
              socket.emit("resign", { sessionid: SESSION_.sessionid, username: SESSION_.username, game: this_.rematch_ });
              this_.notice("Offer to Resign sent ...");
          }
       }
     }

     abortGame(e) {
       if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
log("offer to abort ...");
log(this_.rematch_);
          if (this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE) return;
          socket.emit("abortgame", { sessionid: SESSION_.sessionid, username: SESSION_.username, game: this_.rematch_ });
          this_.notice("Offer to abort game sent ...");
       }
     }

     acceptAbort(e) {
log("accepting draw ...");
          var this_ = this.game_;
          socket.emit("acceptabort", { sessionid: SESSION_.sessionid, username: SESSION_.username, game: this_.rematch_ });
          this_.notice(SESSION_.username + " accepts abort request ... ");
          this_.GAME_STATE.gameover_ = GAMEOVER.ABORTED;
          this_.checkGameOver();
          return true;
     }

     offerDraw(e) {
       if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
log("offer draw ...");
log(this_.rematch_);
          if (this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE) return;
          socket.emit("offerdraw", { sessionid: SESSION_.sessionid, username: SESSION_.username, game: this_.rematch_ });
          this_.notice("Offer to Draw sent ...");
       }
     }

     acceptDraw(e) {
log("accepting draw ...");
          var this_ = this.game_;
          socket.emit("acceptdraw", { sessionid: SESSION_.sessionid, username: SESSION_.username, game: this_.rematch_ });
          this_.notice(SESSION_.username + " accepts draw ... ");
          this_.GAME_STATE.gameover_ = GAMEOVER.DRAWACCEPTED;
          this_.checkGameOver();
          return true;
     }


     async takeBack(e) {
       if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
          if (this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE) {
               this_.takeitBack(); 
               if ( (this_.BPLAYER_ == MACHINE && this_.GAME_STATE.sidetomove_ == BLACK) ||          
                    (this_.WPLAYER_ == MACHINE && this_.GAME_STATE.sidetomove_ == WHITE) ) {
                    this_.pauseTimer();
                    this_.notice("Proceed game after takebacks ...", { label : "continueaftertakeback" });
               } else {
                    this_.notice("Your move ...");
               }
          } else {
             if (this_.GAME_STATE.simul) return; /* we do not support takebacks in simuls */
             socket.emit("takeback", { sessionid: SESSION_.sessionid, username: SESSION_.username, game: this_.rematch_ });
             this_.notice("Request to take back sent ...");
          }
       }
     }

     async acceptTakeback(e) {
       if(!e.detail || e.detail == 1){
          e.preventDefault();
          var this_ = this.game_;
          socket.emit("accepttakeback", { sessionid: SESSION_.sessionid, username: SESSION_.username, game: this_.rematch_ });
          await pause(200);
          this_.takeitBack();
          this_.notice(SESSION_.username + " grants takeback ... ");
       }
     }

     async continueEnginePlay(e) {
          var this_ = this.game_;
          if (this_.BPLAYER_ == MACHINE || this_.WPLAYER_ == MACHINE) {
log("continue ...");
log(this_);
             if ( (this_.BPLAYER_ == MACHINE && this_.GAME_STATE.sidetomove_ == BLACK) ||
                  (this_.WPLAYER_ == MACHINE && this_.GAME_STATE.sidetomove_ == WHITE) ) {
                this_.playEngine();
             }
          }
     }
     

     takeitBack() {
          var mtype = undoMove(this);
          this.sideBoard();
          if (mtype == 0) { /* do nothing */ } else
          if (mtype == GOODMOVE) {
             chess_move.currentTime = 0;
             chess_move.play();
          } else {
             chess_castle.currentTime = 0;
             chess_castle.play();
          }
     }

     playerChoice = false
     choosePlayer() {
         var this_ = this.game_;
         if (this_.engine_ == null) {
            this_.engine_ = machineid.cloneNode(true);
            this_.tbox.appendChild(this_.engine_);
            var inputs = this_.engine_.getElementsByClassName("engineclass");
            for (var p=0; p<inputs.length; p++) {
               if (inputs[p].id == "engineid") {
                  inputs[p].onclick = this_.engineGame;
                  inputs[p].game_ = this_;
                } else {
                  inputs[p].onclick = this_.enginePlayer;
                  inputs[p].game_ = this_;
                }
             }
         }
         this_.engine_.style.visibility = (this_.engine_.style.visibility == "visible") ? "hidden" : "visible";
         this_.playerChoice = (this_.engine_.style.visibility == "visible") ? true : false;
     }

     enginePlayer() {
         var this_ = this.game_;
         if (this.id == "whiteplayerid") this_.WPLAYER_ = this.value;
         if (this.id == "blackplayerid") this_.BPLAYER_ = this.value;
     }
 
     engineGame() {
         var this_ = this.game_;
         this_.engine_.style.visibility = (this_.engine_.style.visibility == "visible") ? "hidden" : "visible";
         this_.setEngine();
         message(this_, "Configuration takes effect in th next game!", false);
     }

     mouseDownForSet(e)  {
        e.preventDefault();
        if(!e.detail || e.detail == 1) {
           var this_ = this.game_;
           const contr  = getCSS(".chesscontainer");
           var cell = this.parentNode.parentNode;
           var img = this.cloneNode(false);
           var tbox = this_.tbox;
           var width = parseInt(tbox.style.width);
           var height = parseInt(tbox.style.height);
           var padL = parseInt(tbox.style.paddingLeft);
           var padR = parseInt(tbox.style.paddingRight);
           var padT = parseInt(tbox.style.paddingTop);
           var padB = parseInt(tbox.style.paddingBottom);
           var brd_ = parseInt(contr.style.borderWidth);
           var center_width = this_.cellwidth / 2;
           var center_height = this_.cellheight / 2;
           var cwidth = parseInt(this.style.width) / 2;
           var cheight = parseInt(this.style.height) / 2;
           var loffset = this.parentNode.offsetLeft + this.offsetLeft;
           var toffset = this.parentNode.offsetTop + this.offsetTop;
           var offsetLeft =  this_.container_.offsetLeft + this_.container_.clientWidth + brd_ * 2  + loffset;
           var offsetTop = this_.container_.offsetTop + this_.tbox.offsetTop + brd_ + toffset;
           img.style.position = 'absolute';
           img.style.width = this_.cellwidth + 'px';
           img.style.height = this_.cellheight + 'px';
           img.style.left = (offsetLeft + cwidth - center_width) + 'px';
           img.style.top  = (offsetTop + cheight - center_height) +  'px';
           img.startPosX = offsetLeft + cwidth;
           img.startPosY = offsetTop + cheight;
           img.style.zIndex = 500;
           img.piece = this.piece;
           img.role_ = this.role_;
           img.color_ = this.color_;
           chessdiv.appendChild(img);
           chessdiv.targetmove_ = img;
           chessdiv.addEventListener('mousemove', this_.mouseMoveForSet);
           document.setgame_ = this_;
           tbox.game_ = this_;
           this_.GAME_STATE.mousedu_ = true;
         }
     }

     mouseMoveForSet(e) {
           e.preventDefault();
           var this_ = this.game_;
           var tbox = this_.tbox;
           var container_ = this_.container_;
           var padding = parseInt(tbox.style.padding);
           var piece = this.targetmove_;
           var pos = scrollOffset(e), x = pos.x , y = pos.y;
           piece.newPosX   = piece.startPosX - x;
           piece.newPosY   = piece.startPosY - y;
           piece.startPosX = x;
           piece.startPosY = y;

           piece.style.top  = (piece.offsetTop - piece.newPosY) + "px";
           piece.style.left = (piece.offsetLeft - piece.newPosX) + "px";
           piece.style.zIndex = 500;
     }

     unsetPiece() {
          var this_ = this.game_;
          var Board = this_.ChessBoard.Board;
          var piece = this.piece; /* this_ vs this */
          var loc_ = piece.location; 
          var td_   = Board[loc_].td_;
          td_.removeChild(piece.img_);
          Board[loc_].piece = null;
          chess_capture.currentTime = 0;
          chess_capture.play();
     }

     setPiece() {
          var this_ = this;
          var Board = this_.ChessBoard.Board;
          var tbox = this_.tbox;
          var coffsetL = this_.container_.offsetLeft;
          var coffsetT = this_.container_.offsetTop;
          var hdr_height  = parseInt(this_.header_.style.height);
          var padL = parseInt(tbox.style.paddingLeft);
          var padT = parseInt(tbox.style.paddingTop);
          var img = chessdiv.targetmove_;
          var variant = this_.GAME_STATE.variant;
          this_.GAME_STATE.mousedu_ = false;
          var center_width  = (this_.cellwidth / 2);
          var center_height = (this_.cellheight / 2);
          var i_centerL = img.offsetLeft + center_width, i_centerT = img.offsetTop + center_height;
          var loc_ = null;
          chessdiv.removeChild(img);
          for (var h in horiz) {
                 for (var v=1; v<=8; v++) {
                    loc_ = horiz[h] + v;
                    const td_ = Board[loc_].td_;
                    const b_offsetL = coffsetL + td_.parentNode.offsetLeft + padL;
                    const b_offsetT = coffsetT + td_.parentNode.offsetTop + padT + hdr_height;
                    if (( i_centerL > b_offsetL && i_centerL < b_offsetL + this_.cellwidth ) &&
                        ( i_centerT > b_offsetT && i_centerT < b_offsetT + this_.cellheight )) {
                          const rank  = parseInt(loc_[1]);
                          var   rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_; // location is coming from ui input
                          const piece = Board[rloc_].piece;
                          // chessdiv.removeChild(img);
                          if ((rank == 1 || rank == 8) && img.role_ == 'P') break; // pawns cannot fall in rank 1 or 8.
                          if (variant == CRAZYHOUSE) { 
                               // cannot occupy an occupied square.
                               if (piece != null) break;
                               // cannot drop in piece of different color
                               if ( (this_.GAME_STATE.sidetomove_ == WHITE && img.color_.slice(1)  == 'dt') ||
                                    (this_.GAME_STATE.sidetomove_ == BLACK && img.color_.slice(1)  == 'lt') )  break;
                               var capturedset = this.availablePiece(img.color_);
                               if (capturedset == null) break; // no captured piece to use.
                               this.captureSetPieceMove(capturedset, img, rloc_, td_, MANUAL);
                          } else {
                             const img_  = td_.getElementsByClassName('chessimg')[0];
                             if (img_ != null) { td_.removeChild(img_); }
                             const new_piece = new this.Piece(this, img.role_, img.color_, rloc_, true);
                             Board[rloc_].piece = new_piece;
                             td_.appendChild(new_piece.img_);
                             chess_move.currentTime = 0;
                             chess_move.play();
                          }
                          return;
                    }
                 }
          }
   }

   captureSetPieceMove(capturedset, img, rloc_, td_, manual) { // For Crazy House Games
        const Board = this.ChessBoard.Board;
        const Undo = this.Undo_;
        const color = img.role_.toLowerCase() + img.color_.slice(1);
        const move = img.role_ + '@' + rloc_;
        const RES = DROPPED;

        const new_piece = new this.Piece(this, img.role_, color, rloc_, false);
        Board[rloc_].piece = new_piece;
        td_.appendChild(new_piece.img_);

        new_piece.restype_ = RES;

        Undo.push( { type: RES, color: new_piece.color_, piece: new_piece, 
                          oloc: new_piece.location_, nloc: rloc_, ooloc: new_piece.oldlocation_ } )

        this.minusPiece(capturedset);

        assertMobility(this, new_piece, RES);

        this.recordMove(move, null, (this.GAME_STATE.checkking_ ? '+' : ''), null, null, true);

        this.TurnToPlay(new_piece, null, false, manual, RES);
        this.checkGameOver(true);
   }

   captureRemotePieceMove(game) {
        const Board  = this.ChessBoard.Board;
        const tbox   = this.ChessBoard.tbox;
        const move   = game.move.split("@");
        const role_  = move[0];
        const loc_   = move[1];
        var   rloc_  = (tbox.reversed_) ? reverseLoc(loc_) : loc_; // for ui (td_);
        const color_ = (game.side == WHITE) ? 'lt' : 'dt';
        const piece_ = { role_: role_, color_: role_.toLowerCase() + color_ };
        const td_ = Board[rloc_].td_;
        if (td_ != null) {
           const piece = Board[loc_].piece;
           const rank  = parseInt(loc_[1]);
           if ((rank == 1 || rank == 8) && img.role_ == 'P') return; // pawns cannot fall in rank 1 or 8.

           // cannot occupy an occupied square.
           if (piece != null)  return;
           // cannot drop in piece of different color
           if ( (this.GAME_STATE.sidetomove_ == WHITE && piece_.color_.slice(1)  == 'dt') ||
                 (this.GAME_STATE.sidetomove_ == BLACK && piece_.color_.slice(1)  == 'lt') ) return;
           var capturedset = this.availablePiece(piece_.color_);
           if (capturedset == null) return; // no captured piece to use.
           this.captureSetPieceMove(capturedset, piece_, loc_, td_, NOTMANUAL);

        }
   }

   mouseDownForMove(e)  {
        e.preventDefault();
        if(!e.detail || e.detail == 1) {
           var this_ = this.game_;
           if (!(this_.GAME_STATE.status_ == STATUS.NEW || this_.GAME_STATE.status_ == STATUS.SET)) return;
           var cell = this.parentNode.parentNode; // td.tr.tbody.table
           var img = this.cloneNode(false); 
           var ctrl = this_.container_;
           var tbox = this_.tbox;
           const ccontr  = getCSS(".chesscontainer");
           const tpad    = getCSS(".chessbox");
           const brd_    = parseInt(ccontr.style.borderWidth);
           const padT    = parseInt(tpad.style.paddingTop);
           const padB    = parseInt(tpad.style.paddingBottom);
           const padL    = parseInt(tpad.style.paddingLeft);
           const padR    = parseInt(tpad.style.paddingRight);
           var center_width = this_.cellwidth / 2
           var center_height = this_.cellheight / 2

           var offsetLeft =  ctrl.offsetLeft + tbox.offsetLeft + cell.offsetLeft;
           var offsetTop = ctrl.offsetTop + tbox.offsetTop + cell.offsetTop;
           offsetLeft = ( offsetLeft + this.offsetLeft + padL + brd_ )
           offsetTop = ( offsetTop + this.offsetTop + padT + brd_)

           img.style.position = 'absolute';
           img.style.left = (offsetLeft) + 'px'; // starts from tbox offset = 0
           img.style.top  = (offsetTop) + 'px'; //  starts from tbox offset = 0
           img.startPosX = offsetLeft + center_width;
           img.startPosY = offsetTop + center_height;
           img.piece = this.piece;
           img.style.zIndex = 500;
           this_.initMoveX = img.startPosX;
           this_.initMoveY = img.startPosY;
           chessdiv.appendChild(img);
           chessdiv.targetmove_ = img;
           chessdiv.addEventListener('mousemove', this_.mouseMoveForMove);
           document.movegame_ = this_;
           tbox.game_ = this_;
           this.style.visibility = 'hidden'; // hide original piece
           this_.GAME_STATE.mousedu_ = true;
        }
        return true;
     }

     mouseMoveForMove(e) {
           e.preventDefault();
           var this_ = this.game_; 
           var tbox = this_.tbox;
           var container_ = this_.container_;
           // var padding = parseInt(tbox.style.padding);
           var piece = this.targetmove_;
           var pos = scrollOffset(e), x = pos.x , y = pos.y;
           piece.newPosX   = piece.startPosX - x;
           piece.newPosY   = piece.startPosY - y;
           piece.startPosX = x;
           piece.startPosY = y;

           this_.finalMoveY = (piece.offsetTop - piece.newPosY);
           this_.finalMoveX = (piece.offsetLeft - piece.newPosX);
           piece.style.top  =  this_.finalMoveY + "px";
           piece.style.left =  this_.finalMoveX + "px";
           piece.style.zIndex = 500;
           return true;
     }

     sideBoard( done = false ) {
          var state = this.GAME_STATE;
          this.ftr_side_.style.color = done ? '#7E3348' : '#000000';
          if (done) {
             this.ftr_side_.innerHTML = '&#9679;';
          }  else {
             this.ftr_side_.innerHTML = (state.sidetomove_ == WHITE) ? '&#9675;' : '&#9679;';
          }
     }

     nextToPlay() {
          var this_ = this;
          if (this_.GAME_STATE.status_ == STATUS.DONE || this.GAME_STATE.playcurrent_ == STATUS.STOPPED) return;
log("got here to play machine 1 ....");
          if ((this_.BPLAYER_ == MACHINE && this_.GAME_STATE.sidetomove_ == BLACK) ||
           (this_.WPLAYER_ == MACHINE && this_.GAME_STATE.sidetomove_ == WHITE)) {
log("got here to play machine  2 ....");
log(this_.BPLAYER_);
log(this_.GAME_STATE.variant);
            this_.playEngine();
          }
     }

     async slidePiece(this_, piece) {
          
          const Board = this.ChessBoard.Board;
          const tbox  = this.ChessBoard.tbox;
          var oloc_ = (tbox.reversed_) ? reverseLoc(piece.oldlocation_) : piece.oldlocation_;
          var nloc_ = (tbox.reversed_) ? reverseLoc(piece.location_) : piece.location_;
          const srcbd = Board[oloc_];
          const dstbd = Board[nloc_];
          const cctrl = getCSS(".chesscontainer");
          const tpad = getCSS(".chessbox");
          const brd_ = parseInt(cctrl.style.borderWidth);
          const padL = parseInt(tpad.style.paddingLeft);
          const padT = parseInt(tpad.style.paddingTop);
          const srcY = this_.container_.offsetTop + this_.tbox.offsetTop + srcbd.td_.parentNode.offsetTop + padT + brd_;
          const srcX = this_.container_.offsetLeft + this_.tbox.offsetLeft + srcbd.td_.parentNode.offsetLeft + padL + brd_;
          const dstY = this_.container_.offsetTop + this_.tbox.offsetTop + dstbd.td_.parentNode.offsetTop + padT + brd_;
          const dstX = this_.container_.offsetLeft + this_.tbox.offsetLeft + dstbd.td_.parentNode.offsetLeft + padL + brd_;
          var img = piece.img_.cloneNode(false);
          img.src = piece.img_.src;
          img.style = 'position: absolute; visibility: visible; z-index: 175000';
          img.style.width = piece.img_.style.width;
          img.style.height = piece.img_.style.height;
          chessdiv.append(img);

          const steps = 25;
          const incY = (dstY - srcY) / steps;
          const incX = (dstX - srcX) / steps;
          for (var i=0; i<=steps;i++) {
             img.style.top  = (srcY + incY * i) + 'px';
             img.style.left = (srcX + incX * i) + 'px';
             await pause(2);
          }
          chessdiv.removeChild(img);
     }

     TurnToPlay(piece, promote, reset_move = false, manual, dropped = null) {
          var state = this.GAME_STATE;
          var SIDETOMOVE_ = state.sidetomove_;
          var MOVECOUNT_ = state.movecount_;
          this.GAME_STATE.sidetomove_ = ( state.sidetomove_ == WHITE) ? BLACK: WHITE;
          this.GAME_STATE.movecount_ = state.movecount_ + ((state.sidetomove_ == WHITE ) ? 1 : 0);
          this.sideBoard();
          this.setTimer(true);

          if (manual == NOTMANUAL) {
                if (this.tbox.slidemove_) {
                  var sp = this.slidePiece(this, piece);
                  sp.then(() => { piece.img_.style.visibility = 'visible'; });
                } else {
                  piece.img_.style.visibility = 'visible';
                }
          } else {
                piece.img_.style.visibility = 'visible';
          }

          if (piece != null) {
             this.GAME_STATE.lastpiece_ = piece;
             this.setMoveHint(piece, dropped);
             if (!reset_move) {
                 if (piece.restype_ == CASTLELONG || piece.restype_ ==  CASTLESHORT) { 
		   chess_castle.currentTime = 0; chess_castle.play();
                 } else
                 if (piece.restype_ == EATPIECE || piece.restype_ == ENPASSANT) { 
                   chess_capture.currentTime = 0; chess_capture.play(); 
                 } else {
                   chess_move.currentTime = 0; chess_move.play(); 
                 }
             }
             if (manual == MANUAL) { // Mouse move is manual move - not move from engine, remotely sent, or auto-play.
                var move_ = null;
                if (dropped == null) {
                   move_ = piece.oldlocation_ + piece.location + ((promote != null) ? '=' + promote :  '');
                } else {
                   move_ = piece.role_ + '@' + piece.location; // crazy house games
                }
                socket.emit("move", { username: SESSION_.username, sessionid: SESSION_.sessionid, round: this.GAME_STATE.round,
                                      move: move_, elapsed: (SIDETOMOVE_ == WHITE) ? this.WTIMER_.elapsed : this.BTIMER_.elapsed,
                                      playtime: this.PLAYTIME_, gametoken: this.GAME_STATE.gametoken_, simul: this.GAME_STATE.simul, 
			     	      remoteplayer: this.GAME_STATE.remoteplayer_, dropped: dropped, tourney: this.GAME_STATE.tourney,
				      gameid: this.id } );
                this.notice(((this.GAME_STATE.sidetomove_ == WHITE) ? "Black" : "White" )  + " moves " + this.GAME_STATE.lastmove_ + " ...");
             } else {
              
             }
          } else chess_move.play();
     }

     enginetime = null
     async playEngine(enpassant = "-") {
          ENGINEMOVE_ = null;
          ANALYZE_ = [];
          this.int_engine = 0;
          var side_ = (this.GAME_STATE.sidetomove_ == WHITE) ? 'w' : 'b';
          var fen   = generateFEN(this, side_);
          const mach     = (CONFIG_.simul) ? CONFIG_.machinoid : CONFIG_.boards[this.id].machinoid;
          const depth    = possible_depth[mach.depth];
          const movetime = possible_movetime[mach.movetime];
          post("ucinewgame", this.id);
          post("position fen " + fen, this.id);
          await post("go movetime " + movetime + " depth " + depth, this.id);
          this.enginetime = setInterval(this.captureEngineMove, 100, this);
     }

     formMove(piece, src_, nloc_, promote) {
          var move_ = null;
          if (piece.restype_ == CASTLELONG) move_ = "O-O-O"; else
          if (piece.restype_ == CASTLESHORT) move_ = "O-O"; else
          if (piece.restype_ == EATPIECE || piece.restype_ == ENPASSANT) {
                if (promote != null || piece.role_ == 'P') 
                   move_ = piece.oldlocation_[0] + "x" + nloc_;
                else
                   move_ = piece.role_ + src_ + "x" + nloc_;
          } else {
             if (promote != null) 
               move_ = src_ + nloc_;
             else
               move_ = piece.role_.replace(/P/g,'') + src_ + nloc_;
          }
          return move_;
     }


     checkGameOver(moved = false) {
        if (this.GAME_STATE.gameover_ == GAMEOVER.ABORTED) {  // horde game
          this.doneGame('by mutual agreement');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.HORDE) {  // horde game
          this.doneGame('by capturing all pieces');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.ATOMIC) {  // three checks game
          this.doneGame('by explosion');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.THREECHECKS) {  // three checks game
          this.doneGame('by three checks');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.KINGOFTHEHILL) {  // for King of the Hill games
          this.doneGame('by reaching the hill');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.INSUFFICIENT) {
          this.doneGame('by insufficient material');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.CHECKMATE) {
          this.doneGame('by checkmate');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.STALEMATE) {
          this.doneGame('by stalemate');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.FORFEITED) {
          this.doneGame('by forfeit');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.ABANDONED) {
          this.doneGame('by abandonment');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.DRAWACCEPTED) {
          this.doneGame('by mutual agreement');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.RESIGNED) {
          this.doneGame('by resignation');
        } else
        if (this.GAME_STATE.gameover_ == GAMEOVER.TIMEOUT) {
          this.doneGame('on time');
        } else 
        if (moved && this.isRepeatDraw()) {
          this.doneGame('by repetition');
        } 
        
     }

     availablePiece(color) {
         var Board = this.ChessBoard.Board;
         var Bench = this.ChessBoard.Bench;
         if (this.GAME_STATE.variant == CRAZYHOUSE) {
              const tbox = this.tbox; 
              const cap = tbox.spancaptures_;
              const span = cap['pcaptureid_' + color]; 
              var cnt = parseInt(span.innerHTML);
              if (cnt > 0) return span;
         }
         return null;
     }

     minusPiece(span) {
         var cnt = parseInt(span.innerHTML);
         cnt -= 1;
         span.innerHTML = cnt;
         if (cnt == 0) span.style.visibility = 'hidden';
     }

     collectSetPiece(res, dropped_piece = null) {
         var Board = this.ChessBoard.Board;
         var Bench = this.ChessBoard.Bench;
log("collectSetPiece");
log(res);
log(this.GAME_STATE.variant);
         if (this.GAME_STATE.variant == CRAZYHOUSE) {
log("first 1 ...");
             if (res == DROPPED) {  // res=DROPPED during takeback
                if (dropped_piece != null) {
log("first 3 ...");
                   const tbox = this.tbox;
                   const cap = tbox.spancaptures_;
                   const color = dropped_piece.color_;
                   const span = cap['pcaptureid_' + color];
                   var cnt = parseInt(span.innerHTML);
                   cnt += 1;
                   span.innerHTML = cnt;
                   span.style.visibility = 'visible';
                }
             } else 
             if (res == EATPIECE || res == ENPASSANT || res == DROPPED) { 
log("first 2 ...");
                var lastpiece = Bench[Bench.length - 1];
                if (lastpiece != null) {
log("first 3 ...");
                   const tbox = this.tbox; 
                   const cap = tbox.spancaptures_;
                   const color = lastpiece.color_[0] + (lastpiece.color_.slice(1) == 'lt' ? 'dt' : 'lt');
                   const span = cap['pcaptureid_' + color]; 
                   var cnt = parseInt(span.innerHTML);
                   cnt += 1;
                   span.innerHTML = cnt;
                   span.style.visibility = 'visible';
                }
             }
         }
     }

     captureMove(turn, player, manual, record_move = true, stats = true, reset_move = false) {
log("entering capture move ...");
         var oloc_ = turn.src;
         var nloc_ = turn.dst;
         var promote = turn.promote;
         try {
            var Board = this.ChessBoard.Board;
            const variant = this.GAME_STATE.variant;
            if (typeof(oloc_) != "string" && oloc_.length != 1) illegal_move("No identified starting point ...");
            var move_ = null;
            var piece = Board[oloc_].piece;
            piece.img_.style.visibility = 'hidden';
            if (piece == null) illegal_move("No piece to move ...");
            this.GAME_STATE.checkking_ = false;
            this.GAME_STATE.draw_ = false;
            piece.move = { location: nloc_, promote: promote }
            const src_ = identifySource(Board, piece);
            move_ = this.formMove(piece, src_, nloc_, promote);
            if (record_move) this.recordMove(move_, promote, (this.GAME_STATE.checkking_ ? '+' : ''), null);
log("got here now 1 .......");
            this.collectSetPiece(piece.restype_);
log("got here now 2 .......");
            this.TurnToPlay(piece, promote, reset_move, manual);
log("got here now 3 .......");
            this.checkGameOver(true);
log("got here now 4 .......");
            // if move is not any of those listed below for computer move, then return.
            if (variant != STANDARD && variant != CHESS960 && 
                variant != THEMOLE && variant != THETRAITOR) return piece.restype_;
log("got here now 5 .......");
            if (player == HUMAN) {
log("got here now 6 .......");
                if (stats) this.checkState(piece);
            } else {
                if (stats) this.postScore();
log("got here now 7 .......");
                this.nextToPlay();
            }
            return piece.restype_; 

         } catch(e) {
              var msg = e.msg;
              if (piece != null) piece.img_.style.visibility = 'visible';
              // message(this, "Illegal move: " + e.msg, false);
                
              if (typeof(msg) != "undefined" && typeof(msg.lastIndexOf) != "undefined") {
                  var a = msg.lastIndexOf('endangering its own king'),
                      b = msg.lastIndexOf('Not able to find proper pieces'),
                      c = msg.lastIndexOf('no available king'),
                      d = msg.lastIndexOf("cannot explode owns king");
                  log(e);
                  if (a >= 0 || b >=0 || c >=0 || d >=0 ) { undoMove(this, false, false); };
              } else {
                  log(e);
              }
              this.GAME_STATE.playstatus_ = STATUS.ILLEGAL;
         }
     }

     int_engine = 0
     captureEngineMove(this_) {
           if (this_.int_engine > 150) { this_.int_engine = 0; clearInterval(this_.enginetime); log("timer expired ...");  }
           this_.int_engine ++;
           if (ENGINEMOVE_ != null) {
                clearInterval(this_.enginetime);
                this_.int_engine = 0;
                var Board = this_.ChessBoard.Board, piece;
                var oloc_ = null, nloc_ = null, promote = null;
                const move = { move: ENGINEMOVE_, side: this_.GAME_STATE.sidetomove_, check: null, promote: null }
                const turn = this_.simpleMove(this_, move, MACHINE);  //oloc_, nloc_, promote
                this_.captureMove(turn, MACHINE, NOTMANUAL);
                this_.notice(((this_.GAME_STATE.sidetomove_ == WHITE) ? "Black" : "White" )  +
                                " moves " + this_.GAME_STATE.lastmove_ + " ...");
          }
     }

     playHuman() {
          var this_ = this;
          var tbox = this_.tbox;
          var coffsetL = this_.container_.offsetLeft;
          var coffsetT = this_.container_.offsetTop;
          var hdr_height  = parseInt(this_.header_.style.height);
          var padL = parseInt(tbox.style.paddingLeft);
          var padT = parseInt(tbox.style.paddingTop);
          var img = chessdiv.targetmove_, piece = img.piece;
          var SIDETOMOVE_ = this_.GAME_STATE.sidetomove_;
          var MOVECOUNT_  = this_.GAME_STATE.movecount_;
          this_.GAME_STATE.mousedu_ = false;
          var center_width  = (this_.cellwidth / 2);
          var center_height = (this_.cellheight / 2);
          var i_centerL = img.offsetLeft + center_width, i_centerT = img.offsetTop + center_height;
          var loc_, oloc_ = null, nloc_;
          // remove cloned image  
          chessdiv.removeChild(img);             
          if ((SIDETOMOVE_ == WHITE && piece.color_.match(/dt$/)) ||
              (SIDETOMOVE_ == BLACK && piece.color_.match(/lt$/))) { 
                 piece.img_.style.visibility = 'visible';
                 log ("Illegal turn (playhuman)!");
                 return;
          }
          if (this_.GAME_STATE.remoteside_ == SIDETOMOVE_) {
                 piece.img_.style.visibility = 'visible';
                 log ("Illegal turn (playhuman)!");
                 return;
          }
          for (var h in horiz) {
                 for (var v=1; v<=8; v++) {
                    const loc_ = horiz[h] + v;
                    const td_ = this.ChessBoard.Board[loc_].td_;
                    const img_ = td_.getElementsByClassName('chessimg')[0];
                    const b_offsetL = coffsetL + td_.parentNode.offsetLeft + padL;
                    const b_offsetT = coffsetT + td_.parentNode.offsetTop + padT + hdr_height;
                    if (( i_centerL > b_offsetL && i_centerL < b_offsetL + this_.cellwidth ) &&
                        ( i_centerT > b_offsetT && i_centerT < b_offsetT + this_.cellheight )) {
                            var promote = null, move_ = null;
                            oloc_ = piece.location_;
                            nloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
                            if (piece.role == 'P') {
                               if (piece.color == 'plt' && nloc_[1] == 8) promote = 'lt';
                               if (piece.color == 'pdt' && nloc_[1] == 1) promote = 'dt';
                            }
                            if (promote == null) {
                               this_.captureHumanMove(piece, oloc_, nloc_, null);
                            } else {
                               this_.promoteChoice(piece, oloc_, nloc_, promote);
                            }
                            if (MOVECOUNT_ >= 0) this_.GAME_STATE.donegame_ = false;
                            return;
                     }
                 }
          }
          piece.img_.style.visibility = 'visible';
          return;
     }

     captureHumanMove(piece, oloc_, nloc_, promote) {
          var promote_ = (promote != null) ? '=' + promote : '';
          var turn = { move: oloc_ + nloc_ + promote_, side: piece.color, check: null};
          turn = this.simpleMove(this, turn, HUMAN);
          this.captureMove(turn, HUMAN, MANUAL);
     }

     promotetime = ''
     promoteChoice(piece, oloc_, nloc_, color) {

          this.GAME_STATE.onpromote_ = true;
          this.promo_.style.visibility = "visible";
          if (color == 'lt') {
             this.promowhite_.style.visibility = 'visible';
             this.promoblack_.style.visibility = 'hidden';
          } else {
             this.promowhite_.style.visibility = 'hidden';
             this.promoblack_.style.visibility = 'visible';
          }
          this.int_promote = 0;
          this.promotetime = setInterval(this.readyPromote, 50, this, piece, oloc_, nloc_);
     }

     int_promote = 0
     readyPromote(this_, piece, oloc_, nloc_) {
        var ONPROMOTE_ = this_.GAME_STATE.onpromote_;
        var PROMOTEPIECE_ = this_.GAME_STATE.promotepiece_;
        if (this_.int_promote > 200) {
           this_.int_promote = 0;
           clearInterval(this_.promotetime);
           this_.captureHumanMove(piece, oloc_, nloc_, 'Q'); // taking forever to decide, let's promote to Queen
           this_.promotePiece();
        }
        if (!ONPROMOTE_ && PROMOTEPIECE_ != null) {
           clearInterval(this_.promotetime);
           this_.captureHumanMove(piece, oloc_, nloc_, PROMOTEPIECE_);
           this_.promotePiece();
        }
        this_.int_promote ++;
     }

     promotePiece() {
         var this_ = null;
         if (typeof(this.nodeType) == "undefined") {
             this_  = this;
             this_.GAME_STATE.promotepiece_ = null;
         } else {
             this_  = this.game_;
             this_.GAME_STATE.promotepiece_ = this.id;
         }
         this_.GAME_STATE.onpromote_ = false;
         this_.promowhite_.style.visibility = 'hidden';
         this_.promoblack_.style.visibility = 'hidden';
         this_.promo_.style.visibility = "hidden";
     }

     recordMove(move, promote = null, check = null, comment = null, result = null, dropped = null) {
         var state_ = this.GAME_STATE;
         var SIDETOMOVE_ = state_.sidetomove_;
         var step_ = state_.movecount_ + 1;
         if (step_ == 1 && SIDETOMOVE_ == BLACK && this.Moves_.length == 0) { 
            this.GAME_STATE.sidetomove_ = WHITE;
 	    this.recordMove("(...)");
            this.GAME_STATE.sidetomove_ = BLACK;
         }
         if (promote == '') promote = null; 
         const notes = this.Notes_;
         const move_ = beautifyMove(move + ((promote !=null) ? '=' + promote : ''));
         const span   = document.createElement("span");
         const moves0 = document.createElement("span");  moves0.className = "chesspiecestep";
         const moves1 = document.createElement("span");  moves1.className = "chesspiecenomove";   moves1.innerHTML = move_;
         const moves2 = document.createElement("span");  
         const space1 = document.createTextNode(" ");
         const movec1 = document.createElement("span");  movec1.className = 'chesschk';         movec1.innerHTML = check; 
         const movec2 = document.createElement("span");  movec2.className = 'chesscmt';         movec2.innerHTML = comment;

         if (SIDETOMOVE_ == WHITE) { moves0.innerHTML = step_ + "."; }

         span.id = "moveid_" + step_ + '_' + ((SIDETOMOVE_ == WHITE) ? "w" : "b");
         movec1.id = "chk_" + step_ + "_" + move;

         span.onclick = function() { 
             this.game_.GAME_STATE.playcurrent_ = this.step_; 
 	     this.game_.jumpMove(null, this.step_, null, null);
             keyPress(false);
	 }
         span.game_ = this;

         span.step_ = (SIDETOMOVE_ == WHITE) ? (step_ * 2 - 1) : (step_ * 2);

         this.GAME_STATE.lastmove_ = move_;
         move = (this.GAME_STATE.variant != CRAZYHOUSE) ? move.replace(/P/g, '') : move;
         this.Moves_.push( { move: moves0.innerHTML + move,
			     side: (SIDETOMOVE_==WHITE) ? 'lt' : 'dt', promote: promote, check: check, comment: comment } );
        
         span.appendChild(moves0); span.appendChild(moves1);
         span.appendChild(moves2); span.appendChild(movec1); 
         span.appendChild(movec2); span.appendChild(space1);
         notes.appendChild(span);
     }

     recordScore(rs) {
         const notes = this.Notes_;
         const span   = document.createElement("span");
         const movesp = document.createTextNode("   ");
         const moves = document.createElement("span");
         moves.style = 'color: #DA5E5E; white-space: nowrap'; 
         moves.innerHTML = "&nbsp;&nbsp;&nbsp;" + rs;
         span.appendChild(movesp); 
         span.appendChild(moves); 
         notes.appendChild(span);
     }

     recordPlayers(current_) {
         var reversed = this.tbox.reversed_;
         var side_ = this.GAME_STATE.sidetomove_;
         this.hdr_player_.innerHTML  = (reversed) ? current_.wp : current_.bp;
         this.hdr_elo_.innerHTML     = (reversed) ? current_.we : current_.be;
         this.ftr_player_.innerHTML  = (reversed) ? current_.bp : current_.wp;
         this.ftr_elo_.innerHTML     = (reversed) ? current_.be : current_.we;
         this.opp_side_ = (reversed) ? WHITE : BLACK;
     }

     recordToDatabase(this_, result, reason) {
         var reversed = this_.tbox.reversed_;
         var chessls = this_.chessls_;
         var side_ = this_.opp_side_, eco = null;
         var notes = this_.Notes_;
         var moves = [];
         for (var p in this_.Moves_) {
            const move = this_.Moves_[p].move;
            moves.push(move);
         }
         eco = findECO(moves.join(' '))
         const game = {};
         const wp = (reversed) ? this_.hdr_player_.innerHTML : this_.ftr_player_.innerHTML;
         const bp = (reversed) ? this_.ftr_player_.innerHTML : this_.hdr_player_.innerHTML;
         const session_ = { username: SESSION_.username, sessionid: SESSION_.sessionid } 
         game.wp = wp;
         game.bp = bp;
         game.eco =  (eco != null) ? eco[0] : '';
         game.rt  = result;
         game.ct = Math.ceil( moves.length / 2 );
         game.ev = 'Chess Online';
         game.dt = Date.now();
         game.si = 'Online (simuchess.com)';
         game.reason = reason;
         game.moves = moves.join(' ') + '  ' + result + '  ';
         game.gametoken = this_.GAME_STATE.gametoken_;
         game.fen    = this_.GAME_STATE.fen_;
         game.status = this_.GAME_STATE.gameover_;
         game.simul  = this_.GAME_STATE.simul;
         game.tourney  = this_.GAME_STATE.tourney;
         game.gameid = this_.id;
         game.ratesystem = CONFIG_.ratesystem;
         const tr = recordGame(this_, game, this_.Games.length);
         chesstbodyid.appendChild(tr);
         this_.GAME_STATE.remoteside_ = null;
         if (this_.GAME_STATE.gameover_ == GAMEOVER.FORFEITED) {
            const nrating = getScore(this_.rematch_);
            this_.msgDone(this_, nrating, game.ratesystem);
         } else
         if (this_.GAME_STATE.gameover_ == GAMEOVER.ABORTED) {
            const nrating = getScore(this_.rematch_);
            this_.msgDone(this_, nrating, game.ratesystem);
         } else
         if (this_.BPLAYER_ == MACHINE || this.WPLAYER_ == MACHINE) {
             machineScore({ session: session_, game: game, tourney: this.rematch_ });
         } else {
             socket.emit("recordgame", { session: session_, game: game } );
         }
     }

     recordResult(this_, reason) {
         var notes = this_.Notes_;
         var go = this_.GAME_STATE.gameover_;
         var result = ( this_.GAME_STATE.gameoverside_ == WHITE ) ? '0-1' : '1-0';
         var draw = false;
         draw = (go == GAMEOVER.INSUFFICIENT || go == GAMEOVER.REPETITION || go == GAMEOVER.DRAWACCEPTED || go == GAMEOVER.STALEMATE);
         result = (draw) ? '1/2-1/2' : result;
         this_.recordScore(result);
         // Record game into database  
         this_.recordToDatabase(this_, result, reason);
     }

     unrecordMove() {
         const notes = this.Notes_;
         this.Moves_.pop();
         notes.removeChild(notes.lastChild);
     }

     async jumpMove(e = null, step = null, dir = null) {
        var this_ = (e != null) ? this.game_ : this;
        const notes = this_.Notes_;
        if (e != null && ( this_.GAME_STATE.playstatus_ != STATUS.STOPPED && this_.GAME_STATE.playstatus_ != STATUS.INTERRUPTED)) return;
        var p = step; // (step != null) ? step : this.step_;
        var value = this_.GAME_STATE.gamecurrent_;
        var mymoves = this_.PGNDB_[value];

        var fen = mymoves[p].fen;
        var rtype = mymoves[p].restype;
        var turn = mymoves[p].turn;
log("notes ...");
log(notes);

        this_.clearBoard(this_);
        this_.setFENonBoard(fen, this_);
        this_.whichSound(rtype);
        if (turn != null) {
           this_.resetHint(turn.src, false);
           this_.resetHint(turn.dst, false);
           if (this_.GAME_STATE.playcurrent_ != null) {
               var o = this_.GAME_STATE.playcurrent_;
               var sturn = mymoves[o].turn;
               if (!(turn.src == sturn.src && turn.dst == sturn.dst)) { 
                  this_.resetHint(sturn.src, true);
                  this_.resetHint(sturn.dst, true);
               }
           }
        }

        this_.highlightMove(notes, this_.GAME_STATE.playcurrent_);

        this_.GAME_STATE.playcurrent_ = p;
        var chessmoves = document.getElementById(this_.id + '_chessmoves');
        var chessmovestr = chessmoves.getElementsByTagName('tr');
        for (var n in chessmovestr) {
            var trow = chessmovestr[n];
            if (trow.nodeType == 1 && trow.id != null) {
               for (var m in trow.children) {
                 var tcol = trow.children[m];
                 if (tcol.nodeType == 1) {
                    tcol.style.backgroundColor = '';
                 }
               }
            }
        }
        if (turn != null) {
          var SCORES_ = this_.enginescore_.SCORES_;
          var step = Math.ceil(p / 2), col = (p % 2);
          var tr = document.getElementById(this_.id + "_chessmoves_" + step);
          if (step >=15)  tr.scrollIntoView(false);
          if (col)  tr.firstChild.nextSibling.nextSibling.nextSibling.style.backgroundColor = "#35642E";
          if (!col) tr.firstChild.nextSibling.nextSibling.nextSibling.nextSibling.style.backgroundColor = "#35642E";
          var side = fen.split(' ')[1];
          // acquireMoveScore(this_, fen, (side == 'w') ? 'b' : 'w');
        }
        return p;
     }

     isRepeatDraw() {  // Three-fold repetition of the same Position in the board.
        var draw = false;
        var fen = generateFEN(this, "w").split(' ')[0];
        this.RepeatDraw_.push(fen);
        if (this.RepeatDraw_.length >= 15) { // though rule says repetition could be anywhere in the whole game.
           this.RepeatDraw_.shift(); // chops off the first element to manage length of array
        }
        var dupfen = {};
        this.RepeatDraw_.forEach((i) => { dupfen[i] = ++dupfen[i] || 1} );
        for (p in dupfen) {
            var repeat = dupfen[p];
            if (repeat >= 3) {
               draw = true;
               break;
            }
        }
        if (draw) this.GAME_STATE.gameover_ = GAMEOVER.REPETITION;
        return draw;
     }

     evaluateScore() {
        var ponder_ = (typeof(PONDER_) == "undefined") ? "" : " " + PONDER_;
        var move_ = ENGINEMOVE_ + ponder_;
        var analyze = 50, score = 0, found = 0, load_ = null;
        if (ANALYZE_.length)
        for (var p in ANALYZE_) {
          const l_ = ANALYZE_[p];
          found = l_.moves.lastIndexOf(move_);
          if (found == 0) {
            if (l_.srate > score ) {
              load_ = l_;
              score = load_.wscore // load_.srate
            }
          }
        }
        return score == 0 ? 0.50 : score;
     }

     postScore() {
        const score = this.evaluateScore();
        var reversed = this.tbox.reversed_;
        var ctrl_ = this.container_;
        // var cbr_ = parseInt(this.tbox.style.padding);
        var padL = parseInt(this.tbox.style.paddingLeft);
        var padR = parseInt(this.tbox.style.paddingRight);
        var padT = parseInt(this.tbox.style.paddingTop);
        var padB = parseInt(this.tbox.style.paddingBottom);

        var hdr_ = parseInt(this.header_.style.height);
        var width = parseInt(this.tbox.style.width);
        var height = parseInt(this.tbox.style.height);
        var white = this.tbox.boardcolor_.sd; // '#eeeeee';
        var black = this.tbox.boardcolor_.dt; // '#444444';
        if (typeof(this.tbox.rating) == "undefined") { 
           const cover = document.createElement('span');
           const rating = document.createElement('span');
           cover.appendChild(rating);

           cover.style.position = 'absolute';
           cover.style.display = 'block';

           rating.style.position = 'absolute';
           cover.style.display = 'block';

           cover.style.border = '0px';
           rating.style.border = '0px';
 
           this.tbox.appendChild(cover);
           this.tbox.rating = rating;
        }

        const rating = this.tbox.rating;
        const cover  = rating.parentNode;
     
 /*
        cover.style.width = '3px'
        cover.style.height = height + 'px';
        cover.style.top = (padT) + 'px';
        cover.style.left = (width + (padR + padL))  + 'px';
        cover.style.backgroundColor = white;
        cover.style.zIndex = 3;

        rating.style.width = '3px';
        rating.style.height = (height * score) + 'px';
        rating.style.top = '0px';
        rating.style.left = '0px';
        rating.style.backgroundColor = black;
        rating.style.zIndex = 3;
           
        this.tbox.rating.style.backgroundColor = (reversed) ? white : black;
        this.tbox.rating.parentNode.style.backgroundColor = (reversed) ? black : white;
        this.tbox.rating.style.height = (height * ((reversed) ? score : 1 - score)) + 'px';
  */
     }

     readyNextPlay(this_, move_) { 
        if (this_.check_timer_[move_].int_timer > 120) { 
             this_.check_timer_[move_].int_timer = 0; 
             clearInterval(this_.check_timer_[move_].timer); 
        }
        this_.check_timer_[move_].int_timer++;
        if (ENGINE_NEXT_RESPONSE_ != null) {
            this_.check_timer_[move_].int_timer = 0;
            clearInterval(this_.check_timer_[move_].timer);
            delete this_.check_timer_[move_]; 
            this_.postScore();
            this_.nextToPlay();
        }
     }

     // checkstatetime = null
     check_timer_ = {};
     async checkState(piece) {
         var side_ = (this.GAME_STATE.sidetomove_ == WHITE) ? 'w' : 'b';
         var fen = generateFEN(this, side_);
log("this fen??");
log(fen);
log(this.ChessBoard.Board);
         var move_ = piece.oldlocation_ + piece.location_;
         ENGINE_NEXT_RESPONSE_ = null;
         ENGINE_STATE_REQ_ = true;
         post("position fen " + fen, this.id);
         await post("go movetime 500 depth 10");
         this.check_timer_[ move_ ] = { timer: null, int_timer: 0 } 
         this.check_timer_[ move_ ].timer  = setInterval(this.readyNextPlay, 100, this, move_);
     }

     resetHint(loc_, reset = true) {
         var Board = this.ChessBoard.Board;
         var tbox  = this.tbox;
         var color = tbox.boardcolor_;
         var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
         var board = Board[rloc_];
         var td    = board.td_.parentNode;
         var mod = (td.cellIndex +td.parentNode.rowIndex ) % 2;
         if (reset) {
              td.style.backgroundColor = (mod) ? color.dt : color.lt;
         } else {
              td.style.backgroundColor = (mod) ? color.hdt : color.hlt;
         }
     }

     isEnpassant() {
         var piece = this.GAME_STATE.lastpiece_;
         if (piece == null) return '-';
         var WHITETOMOVE_ = (piece.color_.match(/lt$/)) != null;
         if (piece.oldlocation_ == null) return '-';
         var oh = piece.oldlocation_[0], nh = piece.location_[0];
         var ov = piece.oldlocation_[1], nv = piece.location_[1];
         if (oh == nh) {
               if (WHITETOMOVE_ && ov == 2 && nv == 4) return oh + 3;
               if (!WHITETOMOVE_ && ov == 7 && nv == 5) return oh + 6;
         }
         return '-'
     }

     setMoveHint(piece, dropped) { // called from TurnToPlay()
         var hints = this.MoveHint_;
         if (hints.length > 0) {
               const last_ = hints[hints.length  - 1];
               if (last_.dropped == DROPPED) {
                 this.resetHint(last_.dst);
               } else {
                  this.resetHint(last_.src);
                  this.resetHint(last_.dst);
               }
         } 
         if (piece.oldlocation_ == null) {
             if (dropped == DROPPED) { // for CrazyHouse games
                this.resetHint(piece.location_, false);
             } else {
                this.resetHint(piece.location_, true);
             }
         } else {
           this.resetHint(piece.location_, false);
           this.resetHint(piece.oldlocation_, false);
         }
         this.MoveHint_.push({ src: piece.oldlocation_, dst: piece.location_, dropped: dropped });
     }

     unsetMoveHint(takeback_) {
          var Board = this.ChessBoard.Board;
          var hints = this.MoveHint_;
          var curr_ = null, last_ = null;

          if (takeback_) {
             curr_ = this.MoveHint_.pop();
             if (curr_.dropped == DROPPED) { // crazyhouse games
               this.resetHint(curr_.dst);
             } else {
               this.resetHint(curr_.src);
               this.resetHint(curr_.dst);
             }
             if (hints.length > 0) {
                 last_ = hints[hints.length  - 1];
                 if (last_.dropped == DROPPED) { // crazyhouse games
                   this.resetHint(last_.dst, false);
                 } else {
                   this.resetHint(last_.src, false);
                   this.resetHint(last_.dst, false);
                 }
             }
          } 
       }

     stopTimer() {
         if (this.GAME_STATE.ptimer_ != null) { 
               clearInterval(this.GAME_STATE.ptimer_); 
               this.GAME_STATE.ptimer_ = null;
               this.int_PCOUNT_ = 0;
               this.WTIMER_  = 0;
               this.BTIMER_  = 0;
         }
     }

     pauseTimer() {
         if (this.GAME_STATE.ptimer_ != null) { 
               clearInterval(this.GAME_STATE.ptimer_); 
               this.GAME_STATE.ptimer_ = null;
         }
     }

     int_PCOUNT_ = 0
     checkTimer(this_) {
         if (this_.GAME_STATE.ptimer_ != null) {
            var this_time  = Date.now();
            var side_      = this_.GAME_STATE.sidetomove_;
            var who_       = (side_ == WHITE) ? this_.WTIMER_ : this_.BTIMER_;
            var elapsed    = null, watch = null, ui_timer = null;
            who_.elapsed  += (this_time - who_.last_time); // add up all elapsed time
            elapsed        = (this_.PLAYTIME_ - who_.elapsed);  
            watch          = padTime(elapsed);
            if ((side_ == WHITE && this_.tbox.reversed_) || 
                (side_ != WHITE && !this_.tbox.reversed_))  ui_timer = this_.hdr_timer_; 
            if ((side_ == WHITE && !this_.tbox.reversed_) ||
                (side_ != WHITE && this_.tbox.reversed_))   ui_timer = this_.ftr_timer_; 
            ui_timer.innerHTML = watch;
            if (elapsed <= 0) {
                this_.stopTimer();
                this_.GAME_STATE.gameover_     = GAMEOVER.TIMEOUT;
                this_.GAME_STATE.gameoverside_ = side_;
                this_.checkGameOver();
                return;
            }
            who_.last_time = this_time;
         }
     }

     setTimer(timeron = true) {
          var last_time_ = Date.now();
          // catch error asynchronously when other process is clearing the board
          try {
            if (this.GAME_STATE.status_ == STATUS.SET) return;
            if (this.GAME_STATE.sidetomove_ == BLACK && this.GAME_STATE.movecount_ == 0) {
               this.ftr_timer_.innerHTML = padTime(this.PLAYTIME_);
               this.hdr_timer_.innerHTML = padTime(this.PLAYTIME_);
            }
            if (this.GAME_STATE.sidetomove_ == WHITE) {
                this.WTIMER_.last_time = last_time_; 
            } else {
               this.BTIMER_.last_time = last_time_; 
            }
            this.int_PCOUNT = 0;
            if (timeron) if (this.GAME_STATE.ptimer_ == null) this.GAME_STATE.ptimer_ = setInterval(this.checkTimer, 50, this);
          } catch(e) {}
     }

    } // end Game class

    function undoCrazyHouse(game, undo) {
        if (game.GAME_STATE.variant != CRAZYHOUSE) return;

        if (undo.type == DROPPED) {
           game.collectSetPiece(undo.type, undo.piece)
        } else
        if (undo.type == EATPIECE || undo.type == ENPASSANT) {
           var benched = undo.benched;
           var switch_color = benched.color_[0] + (benched.color_.slice(1) == 'lt' ? 'dt' : 'lt');
           var capturedset = game.availablePiece(switch_color);
log("undoo crazy house ...");
log(benched);
log(capturedset);
           game.minusPiece(capturedset); 
        }
    }

    function undoThreeChecks(game, undo) {
        if (game.GAME_STATE.variant != THREECHECKS) return;
        if (typeof(undo.threespan) != "undefined") {
           var color = undo.color.slice(1);
           if (color == 'lt') game.GAME_STATE.bchecks --;
           if (color == 'dt') game.GAME_STATE.wchecks --;
           undo.threespan.style.visibility = 'hidden';
        }
    }

    function undoAtomic(game, Undo, undo) {
log("undo atomic ...");
log(undo);
       var Board = game.ChessBoard.Board;
       var tbox = game.tbox;
       var pieces = undo.explodedpieces;
       if (game.GAME_STATE.variant != ATOMIC) return;
       if (typeof(pieces) != "undefined") {
          for (var p in pieces) {
            var piece = pieces[p];
            placePiece(game, piece.location_, piece);
          }
          if (undo.piece.img_.expsrc != null) {  // center of explosion
                undo.piece.img_.src = undo.piece.img_.expsrc;
		delete undo.piece.img_.expsrc;
          }
       } else { // if this is normal move, see if need to undo center
           if (Undo.length) {
              var undo = Undo[Undo.length - 1];
              var pieces = undo.explodedpieces;
              if (typeof(pieces) != "undefined") {
                  var loc_ = undo.piece.location_;
                  var rloc_ = (tbox.reversed_) ? reverseLoc(loc_) : loc_;
                  var board_ui = Board[rloc_];
                  img = restoreBoardPiece(board_ui, ATOMIC_IMG, game.cellwidth, game.cellheight);
                  img.expsrc = undo.piece.img_.expsrc;
              } 
            }
         }
    }

    function undoMove(game, takeback_ = true, switchside = true) {
       var Board = game.ChessBoard.Board;
       var Benched = game.ChessBoard.Bench;
       var Undo = game.Undo_;
       var MoveHint_ = game.MoveHint_;
       var RepeatDraw_ = game.RepeatDraw_;
       var SIDETOMOVE_ = game.GAME_STATE.sidetomove_;
       var BOARDSIZE_ = game.BOARDSIZE_;
       if (Undo.length ==0 ) return 0;
       var move = Undo[Undo.length - 1], undone = false, piece = null, bpiece = null; 
       if (move.type == DROPPED) { // for crazyhouse takebacks.
            emptyCell(game, move.nloc);
            game.unsetMoveHint(takeback_);
            undone = true; 
       } else
       if (move.type == GOODMOVE) {
            piece = move.piece;
            placePiece(game, move.oloc, piece);
            nullPiece(game, move.nloc);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            if (move.promote) { const color = piece.color_.match(/lt$/);
                                piece.role_ = 'P'; 
                                piece.color_ = (color) ? 'plt' : 'pdt' ;
                                piece.img_.src = getImgSrc(piece.color_);
                              }
            game.unsetMoveHint(takeback_);
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == EATPIECE) {
            piece = move.piece;
            bpiece = Benched.pop();
            placePiece(game, move.oloc, piece);
            placePiece(game, bpiece.location_, bpiece);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            if (move.promote) { const color = piece.color_.match(/lt$/);
                                piece.role_ = 'P'; 
                                piece.color_ = (color) ? 'plt' : 'pdt';
                                piece.img_.src = getImgSrc(piece.color_);
                              }
            game.unsetMoveHint(takeback_);
            sortBenchedPieces();
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == ENPASSANT) {
            piece = move.piece;
            bpiece = Benched.pop();
            placePiece(game, move.oloc, piece);
            nullPiece(game, move.nloc);
            placePiece(game, bpiece.location_, bpiece);
            piece.oldlocation_ = move.ooloc;
            piece.location_ = move.oloc;
            game.GAME_STATE.lastpiece_ = bpiece;
            game.unsetMoveHint(takeback_);
            sortBenchedPieces();
            if (!takeback_) return move.type;
            undone = true; 
       } else
       if (move.type == CASTLELONG || move.type == CASTLESHORT) {
            var king = move.piece;
            // king
            if (move.oloc != move.nloc) { // nloc equal to oloc happens only in chess960
                placePiece(game, move.oloc, king);
                nullPiece(game, move.nloc);
            }
            king.oldlocation_ = move.ooloc;
            king.location_ = move.oloc;
            // rook
            var rook = move.rook;
            var sloc_ = rook.oldlocation_, dloc_ = rook.location_;
            rook.location_ = sloc_; 
            rook.oldlocation_ = null; 
            placePiece(game, sloc_, rook);
            if (king.location_ != dloc_) {
                nullPiece(game, dloc_);
            }
            game.unsetMoveHint(takeback_);
            undone = true; 
       }
       if (undone) {
            Undo.pop();
            if (takeback_) { // repeatdraw and recordmove are not committed during error.
                RepeatDraw_.pop();
                game.unrecordMove();
                undoThreeChecks(game, move);
                undoCrazyHouse(game, move);
                undoAtomic(game, Undo, move);
            }
            if (switchside) {
               var state = game.GAME_STATE;
               game.GAME_STATE.sidetomove_ = (state.sidetomove_ == WHITE) ? BLACK: WHITE;
               game.GAME_STATE.movecount_ = game.GAME_STATE.movecount_ - ((state.sidetomove_ == WHITE ) ? 0 : 1);
               game.sideBoard();
               game.setTimer(true)
            }
       }
       return move.type;
    }


    // find the source location of bishop. there could be multiple bishops. 
    function find_bishop(game, Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       for (var i = 1; i <= diff_nh; i++) {
          const h = (oh < nh) ? String.fromCharCode(oh + i) : String.fromCharCode(oh - i);
          const v = (ov < nv) ? (ov + i) : (ov - i);
          if (v < 1 || v > 8) continue;
          const apiece = Board[h + v].piece;
          if ( i == diff_nh ) {  // same destination
              if (apiece != null && apiece.color_.slice(-2) == color) {
                    blocked = 1; _loc = null;
              } else { // eat or move
                    if (h + v == location)  { // found the target
                        if (src != null) { // now select piece, assuming multiple sources
                          if (loc == src || _oh == src || ov == src) { _loc = loc }
                        } else { _loc = loc } // otherwise, choose the only one source
                    }
             }
          } else { if (apiece != null)   { blocked = 1; _loc = null; } }
       }
       var  isthreat = isMobile(game, bpiece, location); // check if moving this piece threatens own king.
       if (!blocked && !isthreat) {return _loc; }
       return null;
    }

    // find the source location of rook. there could be multiple rooks.
    function find_rook(game, Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       if (diff_nv == 0 && diff_nh > 0) {
            for (var i = 1; i <= diff_nh; i++) {
                const h = (oh < nh) ? String.fromCharCode(oh + i) : String.fromCharCode(oh - i);
                const apiece = Board[h + nv].piece;
                  if ( i == diff_nh ) {  // same destination
                      if (apiece != null && apiece.color_.slice(-2) == color) {
                          blocked = 1; _loc = loc;
                      } else { // eat or move
                        if (h + nv == location)  { 
                           if (src != null) { // now select piece, assuming multiple sources
                              if (loc == src || _oh == src || ov == src) { _loc = loc }
                           } else { _loc = loc } // otherwise, choose the only one source
                        }
                      }
                  } else {
                      if (apiece != null) { blocked = 1; _loc = null; } 
                  }
            }
            var  isthreat = isMobile(game, bpiece, location); // check if moving this piece threatens own king.
            if (!blocked && !isthreat) {return _loc; }
       } else
       if (diff_nh == 0 && diff_nv > 0) {
            const h = String.fromCharCode(nh);
            for (var i = 1; i <= diff_nv; i++) {
                const v = (ov < nv) ? (ov + i) : (ov - i);
                const apiece = Board[_oh + v].piece;
                if ( i == diff_nv ) {  // same destination
                      if (apiece != null && apiece.color_.slice(-2) == color) {
                          blocked = 1; _loc = null;
                      } else { // eat or move
                        if (h + v == location)  { 
                           if (src != null) { // now select piece, assuming multiple sources
                              if (loc == src || _oh == src || ov == src) { _loc = loc }
                           } else { _loc = loc } // otherwise, choose the only one source
                        }
                      }
                } else { if (apiece != null) { blocked = 1; _loc = null; } }
            }
            var  isthreat = isMobile(game, bpiece, location); // check if moving this piece threatens own king.
            if (!blocked && !isthreat) {return _loc; }
       }
       return null;
    }

    // find the source location of knight. there could be multiple knight.
    function find_knight(game, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv) {
       const loc = bpiece.location;
       var blocked = 0, _loc = null, _oh = String.fromCharCode(oh);
       if ((diff_nh == 1 && diff_nv == 2) || 
           (diff_nh == 2 && diff_nv == 1)) {
         if (bpiece.color_.slice(-2) != color) {
            blocked = 1;
         } else {
            if (src != null) { // now select piece, assuming multiple sources
              if (loc == src || _oh == src || ov == src) { _loc = loc }
            } else { _loc = loc } // otherwise, choose the only one source
         } 
       }
       var  isthreat = isMobile(game, bpiece, location); // check if moving this piece threatens own king.
       if (!blocked && !isthreat) { return _loc; }
       return null;
    }

    function find_location(this_, color, role, location, hint = null, src = null) {
      var Board = this_.ChessBoard.Board;
      const locs = [];
      for (var p in Board) {
        const bpiece = Board[p].piece;
        if (bpiece != null) {
            const loc = bpiece.location;
            const oh    = loc[0].charCodeAt(0), ov = parseInt(loc[1]);
            const nh    = location[0].charCodeAt(0), nv = parseInt(location[1]);
            diff_nh = Math.abs(nh - oh); diff_nv = Math.abs(nv - ov);
            if ((color == 'lt' && bpiece.color.match(/lt$/)) || (color == 'dt' && bpiece.color.match(/dt$/)))  {
                if (bpiece.role == "K" && role == "K") {
                  locs.push(loc);
                } else 
                if (bpiece.role == "N" && role == "N") {
                  const floc = find_knight(this_, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "B" && role == "B") {
                  const floc = find_bishop(this_, Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "R" && role == "R") {
                  const floc = find_rook(this_, Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc != null) locs.push(floc);
                } else
                if (bpiece.role == "Q" && role == "Q") {
                  const floc1 = find_bishop(this_, Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc1 != null) locs.push(floc1);
                  const floc2 = find_rook(this_, Board, bpiece, color, location, hint, src, diff_nh, diff_nv, oh, nh, ov, nv);
                  if (floc2 != null) locs.push(floc2);
                } else 
                if (bpiece.role == "P" && role.match(/[a-h]/) != null) {
                  var  isthreat = isMobile(this_, bpiece, location); // check if moving this piece threatens own king.
                  if (isthreat) continue;
                  if (diff_nh == 0 && (diff_nv == 1 || diff_nv == 2)) {
                     const bpiece1 = Board[String.fromCharCode(oh) + ((color == 'lt') ? (ov + 1) : (ov - 1))].piece;
                     if (bpiece1 != null) { continue }; // there is a block.
                     if (hint == null) { // moving
                       if (color == 'dt' && ov > nv) { locs.push(loc); }
                       if (color == 'lt' && ov < nv) { locs.push(loc); }
                    }
                  } else
                  if (diff_nh == 1 && diff_nv == 1) {
                     if (hint != null && hint == "x") { // eating
                        const loc1 = loc[0];
                        if (loc[0] == role) {
                           if (color == 'dt' && ov > nv) { locs.push(loc); }
                           if (color == 'lt' && ov < nv) { locs.push(loc); }
                        }
                     }
                  } 
                }
            }
        }
      }
      return locs;
    }

    // Audio
    function playawalker() {
       // const audio = new Audio("/audio/AlanWalker.mp3");
       const audio = new Audio("/audio/shortawalker.mp3");
       audio.volume = 0.5;
       return audio;
    }

    function chessreset() {
       const audio = new Audio("/audio/chessreset.mp3");
       audio.volume = 1.0;
       return audio;
    }

    function chesscastle() {
       const audio = new Audio("/audio/chesscastle.mp3");
       audio.volume = 1.0;
       return audio;
    }

    function chessmove() {
       const audio = new Audio("/audio/chessmove.mp3");
       audio.volume = 1.0;
       return audio;
    }

    function chesscapture() {
       const audio = new Audio("/audio/chess_eat.mp3");
       audio.volume = 1.0;
       return audio;
    }

    function chesswhistle() {
       const audio = new Audio("/audio/chess_whistle.mp3");
       audio.volume = 1.00;
       return audio;
    }

    function chesstweet() {
       const audio = new Audio("/audio/chess_tweet.mp3");
       audio.volume = 0.50;
       return audio;
    }

    // audio objects
    const chess_awalker = playawalker();
    const chess_move = chessmove();
    const chess_capture = chesscapture();
    const chess_castle = chesscastle();
    const chess_reset = chessreset();
    const chess_tweet = chesstweet();
    const chess_whistle = chesswhistle();


    var PLAY_AW_ = false;
    function playAW() {
        PLAY_AW_ = (PLAY_AW_) ? false: true;
        const music_ = document.getElementById("musicid");
        if (PLAY_AW_) { 
            music_.innerHTML = "&#9834;";
            chess_awalker.playbackRate = 1.0;
         } else  { 
            music_.innerHTML = "&#9632;";
            chess_awalker.pause(); chess_awalker.currentTime = 0 
         };
    } 

    var parser = null;
    async function loadParser() {
        const res = await fetch('/jscripts/pgngrammar.pegjs');
        const grammer = await res.text();
        parser = PEG.buildParser(grammer);
    }

    const pause = time => new Promise(resolve => setTimeout(resolve, time))

    

    var ECO_ = null;
    async function loadECO() {
        const res = await fetch('/jscripts/eco2.pgn');
        var eco = await res.text();
        eco = eco.split(/\n/);
        const eco_ = []
        for (var p in eco) {
            const variation = eco[p].replace(/"/g,"").replace(/[ ]+/g, " ").split("~");
            variation[variation.length-1] = variation[variation.length-1].replace(/([0-9]+\.) /g, "$1");
            eco_.push(variation);
        }
        ECO_ = eco_;
    }

    function findECO(moves_) {
        var open = moves_.split(' ');
        var moves = [];
        var maxcnt = 0, myeco = null;
        for (p in ECO_) {
          var peco = ECO_[p];
          if (peco.length < 3) break;
          if (peco[2] == null || peco[2] == '') break;
          var eco_open = peco[2].split(' ');
          var cnt = 0;
          for (var i=0; i<=200; i++) {
            if (eco_open[i] == open[i]) { moves.push(open[i]); cnt++; } else break;
          }
          if (cnt > maxcnt) { maxcnt = cnt;  myeco = peco };
        }
        return myeco;
    }
    

    function closeGameSettings() {
        var settingsid = settingsdivid;
        humanid.style.visibility = 'hidden';
        computerid.style.visibility = 'hidden';
        blanket.style.visibility = 'hidden';
        settingsid.style.visibility = 'hidden';
    }

    function clearBoards() {
       var ids = [];
       while (BOARDS_.length) {
          var board = BOARDS_.pop();
          ids.push(board.id);
          if (board.GAME_STATE != null && board.GAME_STATE.ptimer_ != null) {
              clearInterval(board.GAME_STATE.ptimer_);
          }
          board.container_.remove();
          if (CONFIG_.boards[board.id]) { delete CONFIG_.boards[board.id]; }
          delete board;
       }
       return ids;
    }

    function playSimulHuman(e) {
        closeGameSettings();
        const gsettings = captureGameSettings(settingsdivid, true)
        const simul_ = parseInt(gsettings.humanoid_.simul);
        const boardcnt = possible_simul[simul_];
        const variant = recvariants[parseInt(gsettings.humanoid_.variant) - 1];
        clearBoards();
        if (boardcnt == 1) {
           const game = newBoard(e, hide = true, width = 480, height = 480, variant); 
           game.maxSize(e, game);
           const match = { sessionid: SESSION_.sessionid, username: SESSION_.username, config: CONFIG_.humanoid,  simul: false, 
                           room: 'Single Game', gameid: game.id, gametoken: null, rematch: false, utype: SESSION_.utype }
log("offering match ...");
log(variant);
log(match);
           socket.emit("match", match); // ready for a match
           SESSION_.status = STATUS.SEEKMATCH;
        } else {
           CONFIG_.layout.free = false;
           const boards_ = [];
           for (var i=1; i<=boardcnt;i++) {
               const game = newBoard(e, hide = true, width = 480, height = 480, variant); 
               game.rematch_ = null;
               boards_.push({ gameid: game.id, istaken: false } );
               adjustAllLayout(game);
           }
           const simul = { sessionid: SESSION_.sessionid, username: SESSION_.username, config: CONFIG_.humanoid, simul: true,
		           utype: SESSION_.utype, total: BOARDS_.length, boards: boards_ }
           socket.emit("simul",  simul );
           SESSION_.status = STATUS.SEEKSIMUL;
        }
        notice('Waiting for match ...');
    }

   async function runEngine(this_) {
     await pause(1000);
     this_.playEngine();
   }

   async function playSimulComputer(e) {
        closeGameSettings();
        const gsettings = captureGameSettings(settingsdivid, true)
        setEngine(gsettings);
        const simul_ = parseInt(gsettings.machinoid_.simul);
        const boardcnt = possible_simul[simul_];
        const rating = possible_rating[gsettings.machinoid_.ucielo];
        const gametype = gameType(gsettings.machinoid_.gamemin);
        const color = gameColor(gsettings.machinoid_.piece);
        var variant = gsettings.machinoid_.variant - 1;
        var variant = compvariants[variant].item;
        if (boardcnt > 1) CONFIG_.layout.free = false;
        clearBoards();
        for (var i=1; i<=boardcnt;i++) {
            const board = newBoard(e, hide = true, width = 480, height = 480, variant);
            var game = {};
            if (boardcnt == 1) board.maxSize(e, board);
            board.GAME_STATE.simul = (boardcnt == 1) ? false : true;
            // if (SESSION_.machine_rating == null) 
            SESSION_.machine_rating = initRating(rating);
            if (color == WHITE) {
               board.BPLAYER_ = MACHINE;
               board.WPLAYER_ = HUMAN;
               game.bgame = { player: MACHINE, rating: SESSION_.machine_rating };
               game.wgame = { player: SESSION_.username, rating: SESSION_.rating };
            } else {
               board.BPLAYER_ = HUMAN;
               board.WPLAYER_ = MACHINE;
               game.bgame = { player: SESSION_.username, rating: SESSION_.rating };
               game.wgame = { player: MACHINE, rating: SESSION_.machine_rating };
            }
            adjustAllLayout(board);
            game.simul = (boardcnt == 1) ? false : true;
            game.settings  = gsettings.machinoid_;
            game.gametype  = gametype;
            game.fen       = (variant == CHESS960) ? randomFENchess960() : wINITFEN_;
            if (variant == THEMOLE || variant == THETRAITOR) { 
               game.mole = Math.round(Math.random() * 14)  /* 0-9=P, 10-12=N, 13-14=R */
            }
            await board.startGame(game, (game.wgame.player == SESSION_.username) ? true : false, null );
            if (color == BLACK) { runEngine(board); }
        }
        SESSION_.status = (boardcnt == 1) ? STATUS.PLAYING: STATUS.SIMULPLAYING;
        notice('Playing ' + variant + ' with Computer ...');
     }

     function joinedSimul(simul) {
           const game = simul.game;
           const newlyjoined = simul.newlyjoined;
           log("joined: " + newlyjoined);
log("joined simul ...");
log(simul);
           if (simul.declined != null && simul.declined) {
                notice("Sign up to join registered games."); 
                return;
           } else {
               var gameid = null, this_ = null;
               if (newlyjoined == SESSION_.username || game.host == SESSION_.username) {
                  gameid = (game.wgame.player == SESSION_.username) ? game.wgame.gameid : game.bgame.gameid;
                  this_ = getGame(gameid);
                  this_.rematch_ = game;
                  this_.notice(newlyjoined + " joins ... ");
               }
               // notice(newlyjoined + " joins ... (" + game.joined + " / " + game.total + ')');
               if (game.complete) {
                  closenotice();

                  var boards = simul.boards;
                  if (boards != null) {
                       if (game.host == SESSION_.username) { // host
                          for (var p in boards) {
                             var board = boards[p];
                             var this_ = getGame(board.host_gameid);
                             this_.startGame(this_.rematch_, (game.host_color == WHITE) ? true : false);
                          }
                       } else { // players
                          for (var p in boards) {
                             var board = boards[p];
                             if (board.player == SESSION_.username) {
                                var this_ = getGame(board.gameid);
                                this_.startGame(this_.rematch_, (game.host_color == WHITE) ? false : true );
                                break;
                             }
                          }
                       }
                  }
               }
           }
     }

     var setenginetime = null;
     var UCI_NEW_GAME_READY = false;
     function setEngine(config = null) {
log('set engine ...');
          UCI_NEW_GAME_READY = false;
          post("uci");
          ENGINE_UCI_RESPONSE_ = null
          setenginetime = setInterval(captureEngineSettings, 100, config);
     }


     var int_setengine = 0;
     function captureEngineSettings(config) {
           if (int_setengine > 20) { int_setengine = 0; clearInterval(setenginetime)  }
           int_setengine ++;
           if (ENGINE_UCI_RESPONSE_ != null) {
                int_setengine  = 0;
                clearInterval(setenginetime);
                if (ENGINE_UCI_RESPONSE_ == 'uciok') {
                    log("UCI set OK  ...");
                    setEngineOptions(config);
                }
           }
     }

     var optionenginetime = null;
     var ENGINE_READY_RESPONSE_ = null;
     function setEngineOptions(config) {
          var ucielo = 2850, islimstrength = null,  isnnue = true, variant = STANDARD;
          if (config != null) {
             ucielo = possible_rating[config.machinoid_.ucielo];  
             islimstrength = config.machinoid_.islimstrength;  isnnue = config.machinoid_.isnnue;
             variant = variants[config.machinoid_.variant - 1].item;
          }
          ENGINE_READY_RESPONSE_ = null;
          ucielo = ((ucielo != null) ? ucielo : '2850');
log("UCI elo ");
log(ucielo);
          post("setoption name MultiPV value 20");
          post("setoption name UCI_ShowWDL value true");
          post("setoption name UCI_AnalyseMode value true");
          post("setoption name UCI_Elo value " + ucielo);  // ( min 1350 max 2850 )
          post("setoption name UCI_LimitStrength value " + ((islimstrength != null) ? islimstrength : 'true')); /* required by UCI_Elo */
          post('setoption name Skill Level value 20');  // (min 0 max 20)
          post("setoption name Slow Mover value 84");  // (min 10 max 1000)
         
          const chess960 = (variant == CHESS960);
          if (chess960) post("setoption name UCI_Chess960 value true");  else post("setoption name UCI_Chess960 value false"); 

          if (isnnue != null && isnnue == true) {
             post("setoption name Use NNUE value true");
            //  post("setoption name EvalFile value nn-bc24c101ada0.nnue"); // 23-01-20
             post("setoption name EvalFile value nn-6877cd24400e.nnue");
          } else
          if (isnnue != null && isnnue == true) {
             post("setoption name Use NNUE value false");
          }
          post("isready");
          this.optionenginetime = setInterval(this.captureEngineOptions, 100);
    }

    var int_optionengine = 0;
    function captureEngineOptions() {
           if (int_optionengine > 20) { int_optionengine = 0; clearInterval(optionenginetime)  }
           int_optionengine ++;
           if (ENGINE_READY_RESPONSE_ != null) {
                int_optionengine  = 0;
                clearInterval(optionenginetime);
                if (ENGINE_READY_RESPONSE_ == 'readyok') {
                   log("Engine is ready ...");
                   UCI_NEW_GAME_READY = true;
                   newEngineGame();
                }
           }
    }

    var newenginetime = null;
    var ENGINE_NEW_RESPONSE_ = null;
    function newEngineGame() {
          ENGINE_NEW_RESPONSE_ = null;
          post("uci");
          post("ucinewgame");
          newenginetime = setInterval(captureNewEngineGame, 100);
    }

    var int_newengine = 0;
    function captureNewEngineGame() {
           if (int_newengine > 20) { int_newengine = 0; clearInterval(newenginetime)  }
           int_newengine ++;
           if (ENGINE_NEW_RESPONSE_ != null) {
                int_newengine  = 0;
                clearInterval(newenginetime);
                if (ENGINE_NEW_RESPONSE_ == 'readyok') {
                   log("UCI new Game ready ...");
                   post("ucinewgame");
                }
           }
    }

    function isActivePlay() {
       var playing = false;
       for (var p in BOARDS_) {
           var board = BOARDS_[p];
           if (board.GAME_STATE.status_ == STATUS.NEW) {
              playing = true;
              break;
           }
       }
log("done is it???");
log(playing);
log(BOARDS_);
       if (!playing) { 
           SESSION_.status = STATUS.NOTPLAYING; 
           notice("Game(s) completed ...");
       }
    }

    function startGame(match) {
        if (match.wgame.player == SESSION_.username) {
           var this_ = getGame(match.wgame.gameid);
           if (this_ != null) {
              this_.startGame(match, true);
           }
        } else
        if (match.bgame.player == SESSION_.username) {
           var this_ = getGame(match.bgame.gameid);
           if (this_ != null) {
              this_.startGame(match, false);
           }
        }
    }

    function moveGame(game) {
        if (game.username == SESSION_.username && game.sessionid == SESSION_.sessionid) {
           var this_ = getGame(game.gameid);
           if (this_ != null) {
              if (game.dropped == DROPPED) { // for Crazy House
                  this_.captureRemotePieceMove(game);
              } else {
                  this_.capturePlayerMove(game);
              }
           }
log("move hints ...");
log(this_.MoveHint_);
           this_.notice(((this_.GAME_STATE.sidetomove_ == WHITE) ? "Black" : "White" )  + 
				" moves " + this_.GAME_STATE.lastmove_ + " ...");
           // this_.notice(game.player + " moves " + this_.GAME_STATE.lastmove_ + " ...");
           // this_.notice(game.player + " moves " + game.move + " ...");
        } 
    }

    function keyPress(dialog = true) { 
      if (dialog) {
         document.onkeydown = keyDefault;
      } else {
         document.onkeydown = keyPlay; 
      }
    }

    async function keyDefault(e) {
        e = e || window.event;
    }

    async function keyPlay(e) {
        e = e || window.event;
log("ok 2 ...");
       if (e.keyCode == '38') { // up
         e.preventDefault();
         backwardPlay(chessdiv);
         // jumpToStart(chessdiv);
       }
       else if (e.keyCode == '40') { // down
         e.preventDefault();
         // jumpToEnd(chessdiv, e.target);
         forwardPlay(chessdiv);
       }
       else if (e.keyCode == '37') { // left
         e.preventDefault();
         backwardPlay(chessdiv);
       }
       else if (e.keyCode == '39') {  // right
         e.preventDefault();
         forwardPlay(chessdiv);
       }
    }

    // calculate time
    function calcTime(timer, start) {
        const sec = ( Date.now() - start ) / 1000;
        const hr = Math.floor(sec / 3600);
        const min = (sec % 3600) / 60;
        timer.innerHTML = hr + ":" + min.toFixed(1);
    }

    function emptyBench() {
       while (Benched.length) Benched.pop();
       wcapture.innerHTML = '';
       bcapture.innerHTML = '';
    }

    async function forwardPlay(this_) {
log("forward play");
        var this_ = this_.game_;
        if (this_ == null) return;
        if (this_.GAME_STATE.playstatus_ == STATUS.PLAYING) return;
        var current_ = parseInt(this_.GAME_STATE.playcurrent_);
        if (isNaN(current_)) return;
        var last_ = this_.Moves_.length; 
        current_ = (current_ == last_) ? current_ : current_ + 1;
        this_.GAME_STATE.playcurrent_ = current_;
        await this_.jumpMove(null, current_);
    }

    async function backwardPlay(this_) {
log("backward play");
        var this_ = this_.game_;
        if (this_ == null) return;
        if (this_.GAME_STATE.playstatus_ == STATUS.PLAYING) return;
        var current_ = parseInt(this_.GAME_STATE.playcurrent_);
        if (isNaN(current_)) return;
        current_ = (current_ == 0) ? current_ : current_ - 1;
        this_.GAME_STATE.playcurrent_ = current_;
        await this_.jumpMove(null, current_);
        if (current_ == 0) chess_reset.play();
    }


    async function jumpToStart(this_) {
        var this_ = this_.game_;
        if (this_ == null) return;
        if (this_.GAME_STATE.playstatus_ == STATUS.PLAYING) return;
        this_.GAME_STATE.playcurrent_ = 0;
        await this_.jumpMove(null,  0);
        chess_reset.play();
    }

    async function jumpToEnd(this_) {
        var this_ = this_.game_;
        if (this_ == null) return;
        if (this_.GAME_STATE.playstatus_ == STATUS.PLAYING) return;
        var current_ = parseInt(this_.GAME_STATE.playcurrent_);
        if (isNaN(current_)) return;
        var last_ = this_.Moves_.length; 
        this_.GAME_STATE.playcurrent_ = last_;
        await this_.jumpMove(null, last_, true);
    }

    async function jumpToLocation(this_, where_) {
        var this_ = this_.game_;
        if (this_ == null) return;
        if (this_.GAME_STATE.playstatus_ == STATUS.PLAYING) return;
        this_.GAME_STATE.playcurrent_ = where_;
        await this_.jumpMove(null, where_);
    }

    function evalFilter(game) {
       var filter_ = true ;
       var moves_ = game.moves.split(' ').length - 4; moves_ = Math.floor(moves_ / 2); 
       if (F_WELO_OPS_ == "=") if (parseInt(game.we) != parseInt(F_WELO_)) filter_ = false;
       if (F_WELO_OPS_ == ">=") if (parseInt(game.we) < parseInt(F_WELO_)) filter_ = false;
       if (F_WELO_OPS_ == "<=") if (parseInt(game.we) > parseInt(F_WELO_)) filter_ = false;

       if (F_BELO_OPS_ == "=") if (parseInt(game.we) != parseInt(F_BELO_)) filter_ = false ;
       if (F_BELO_OPS_ == ">=") if(parseInt(game.we) < parseInt(F_BELO_))  filter_ = false;
       if (F_BELO_OPS_ == "<=") if(parseInt(game.we) > parseInt(F_BELO_))  filter_ = false;

       if (F_MOVES_OPS_ == "=") if (moves_ != parseInt(F_MOVES_))  filter_ = false;
       if (F_MOVES_OPS_ == ">=") if (moves_ < parseInt(F_MOVES_)) filter_ = false;
       if (F_MOVES_OPS_ == "<=") if (moves_ > parseInt(F_MOVES_))  filter_ = false;

       if (F_RES1_ == null) if (game.rt == "1-0")  filter_ = false;
       if (F_RES2_ == null) if (game.rt == "0-1")  filter_ = false;
       if (F_RES3_ == null) if (game.rt == "1/2-1/2")  filter_ = false;

       return filter_;
    }


    function sortGames(g1, g2) {
         var res = 0, ORDER = 0;
         for (var i=1; i<=6; i++) {
           ORDER = ORDERS_[i-1];
           if (ORDER != 0) {
              if (ORDER == 1) {
                  if (i == 1)  res =  ((g2.wp) > (g1.wp)) ? 1 : -1;
                  if (i == 2)  res =  ((g2.we) > (g1.we)) ? 1 : -1;
                  if (i == 3)  res =  ((g2.bp) > (g1.bp)) ? 1 : -1;
                  if (i == 4)  res =  ((g2.be) > (g1.be)) ? 1 : -1;
                  if (i == 5)  res =  ((g2.rt) > (g1.rt)) ? 1 : -1;
                  if (i == 6)  res =  ((g2.ct) > (g1.ct)) ? 1 : -1;
              } else
              if (ORDER == 2) {
                  if (i == 1)  res =  ((g2.wp) < (g1.wp)) ? 1 : -1;
                  if (i == 2)  res =  ((g2.we) < (g1.we)) ? 1 : -1;
                  if (i == 3)  res =  ((g2.bp) < (g1.bp)) ? 1 : -1;
                  if (i == 4)  res =  ((g2.be) < (g1.be)) ? 1 : -1;
                  if (i == 5)  res =  ((g2.rt) < (g1.rt)) ? 1 : -1;
                  if (i == 6)  res =  ((g2.ct) < (g1.ct)) ? 1 : -1;
              }
          }
         }
         return res;
    }

    // order List // &#8593; up // &#8595; down // &#8597; neutral
    // 0 = no order, 1 = descending, 2 = ascending

    const ORDERS_ = [0,0,0,0,0,0];
    // 0 = no order, 1 = descending, 2 = ascending
    function orderGame(title, id, elem) {
        const tbody = document.getElementById('tbodylistingid');
        if (tbody == null) { message(this_, "No database loaded ...", false); return; }
        const this_ = tbody.ordergame_;
        if (ORDERS_[id] == 0) {
            elem.innerHTML = title + ' &#8593;';
            ORDERS_[id] = 1;
        } else
        if (ORDERS_[id] == 1) {
            elem.innerHTML = title + ' &#8595;';
            ORDERS_[id] = 2;
        } else
        if (ORDERS_[id] == 2) {
            elem.innerHTML = title + ' &#8597;';
            ORDERS_[id] = 0;
        } 

        const games = this_.Games.sort(sortGames)
        refreshListing(this_, games);
    }

    function orderWhite(elem) {
        orderGame('White', 0, elem);
    }

    function orderBlack(elem) {
        orderGame('Black', 2, elem);
    }

    function orderWhiteElo(elem) {
        orderGame('ELO', 1, elem);
    }

    function orderBlackElo(elem) {
        orderGame('ELO', 3, elem);
    }

    function orderResult(elem) {
        orderGame('Result', 4, elem);
    }

    function orderCount(elem) {
        orderGame('Result', 5, elem);
    }

    function recordGame(this_, game, p) {
            const tr = document.createElement("tr");
            tr.style.backgroundColor = (parseInt(p) % 2 ? '#2a2a2a' : '#3a3a3a' );
            const tdcnt = document.createElement("td"); const cnt = document.createTextNode(parseInt(p) + 1);
            const tdev = document.createElement("td"); const ev = document.createTextNode(game.ev.slice(0,20));
            const tdwp = document.createElement("td"); const wp = document.createTextNode(game.wp.slice(0,20));
            const tdbp = document.createElement("td"); const bp = document.createTextNode(game.bp.slice(0,20));
            const tdwe = document.createElement("td"); const we = document.createTextNode(game.we);
            const tdbe = document.createElement("td"); const be = document.createTextNode(game.be);
            const tdrt = document.createElement("td"); const rt = document.createTextNode(game.rt);
            const tdbt = document.createElement("td"); const bt = document.createElement("button");
            const tdec = document.createElement("td");
            const ec = document.createTextNode(typeof game.eco === "undefined" ? "" : game.eco);

            const tdct = document.createElement("td"); const ct = document.createTextNode(game.ct);
            tdev.appendChild(ev); tdcnt.appendChild(cnt);
            tdwp.appendChild(wp); tdbp.appendChild(bp); tdwe.appendChild(we);
            tdbe.appendChild(be); tdrt.appendChild(rt); tdbt.appendChild(bt);
            tdct.appendChild(ct); tdec.appendChild(ec);

            tr.id = "gametrid" + p;
            tr.appendChild(tdbt); tr.appendChild(tdcnt); tr.appendChild(tdct);
            tr.appendChild(tdwp); tr.appendChild(tdwe);
            tr.appendChild(tdbp); tr.appendChild(tdbe); tr.appendChild(tdrt);
            tr.appendChild(tdec); tr.appendChild(tdev); tr.appendChild(tdct);
            tr.className = "chesstr";
            tdcnt.className = "chesstdb"; tdev.className = "chesstde";  tdec.className = "chesstce";
            tdwp.className = "chesstdp"; tdbp.className = "chesstdp"; tdwe.className = "chesstdl";
            tdbe.className = "chesstdl"; tdrt.className = "chesstdr";  tdbt.className = "chesstdb";
            tdct.className = "chesstdb";

            bt.game_ = this_;
            bt.innerHTML = "&#8594;";
            bt.onclick = this_.playNext;
            bt.value = p;
            bt.id = "gameid_" + p;
            bt.style.backgroundColor = '#4a4a4a';
            bt.style.color = '#afafaf';
            tr.className = "chesstr";

        return tr;
    }

    async function refreshListing(this_, Games) {
        var chessls = this_.chessls_;
        const chesstable = chesstableid; 
        const tbody = chesstbodyid;
        tbody.ordergame_ = this_;
        if (chesstable.firstChild != null) {
            chesstable.replaceChild(tbody, chesstable.firstChild);
        } else {
            chesstable.appendChild(tbody);
        }
        var td = null, txtnode;
        var game_cnt = 0;
        for (var p in Games) {
           const game = Games[p]
           if (game.we != "" && game.be != "") {
            const tr = await recordGame(this_, game, p);
            tbody.appendChild(tr);
           }
        }
        this_.tbox.prevgame_ = null;
  /*
        var current_ = document.getElementById("currentgameid");
        current_.innerHTML = Games.length + '. ';
  */
        chessls.style.visibility = 'visible';
    }

   function findEmptyCube() {
       const cubes = cubicle.getElementsByClassName('cubelet');
       for (var p in cubes) {
         const cube = cubes[p];
         if (cube.firstChild) continue;
         return cube;
       }
       return null;
   }


   async function unpinCube() {
     var container_ = this.container_;
     if (typeof(container_) != "undefined") {

        var img = this, gameid = img.gameid_;
        var cube = img.parentNode;
        const wind = cube.cloneNode(false);
        wind.style.border = '2px solid #ff0000';
        wind.style.backgroundColor = '';
        wind.style.margin = '0px 0px 0px 0px';
        wind.style.zIndex = 200000;
        var top = parseInt(wind.style.top);
        var left = parseInt(wind.style.left);
        var width = parseInt(wind.style.width);
        var height = parseInt(wind.style.height);
        chessdiv.appendChild(wind);

        img.style.visibility = 'hidden';

        var top1 = parseInt(container_.style.top);
        var left1 = parseInt(container_.style.left);
        var width1 = parseInt(container_.style.width);
        var height1 = parseInt(container_.style.height);
        const size = '36';
        var mw = width1 / 10;
        var mh = height1 / 10;
        var offsetL = 0, offsetT = 0;
        var osetL = parseInt(container_.style.left), osetT = parseInt(container_.style.top);
        var topc = 0, leftc = 0;
        var ml = 0, mt = 0;

       var offsetL1 = img.parentNode.offsetLeft, offsetT1 = img.parentNode.offsetTop;
       var offsetL2 = img.parentNode.parentNode.offsetLeft, offsetT2 = img.parentNode.parentNode.offsetTop;
       var topc = parseInt(img.parentNode.offsetTop), leftc = parseInt(img.parentNode.offsetLeft);
       offsetL = offsetL1 + offsetL2, offsetT = offsetT1 + offsetT2;

       wind.style.top = offsetT + 'px';
       wind.style.left = offsetL + 'px';
       wind.style.width = size + 'px';
       wind.style.height = size + 'px';

       ml = (osetL - offsetL) / 10; mt = (osetT - offsetT ) / 10;
       var mwidth = size - 0; mheight = size - 0;
       top = offsetT; left = offsetL;


       var next = cube.parentNode.firstChild;
       while (next) {
           if (next.nodeType == 1) {
              if (next.gameid_ != null && next.gameid_ == gameid) {
                 cube.parentNode.removeChild(next); break;
              }
           }
           next = next.nextSibling;
        }

       for (var i=1; i <= 10; i++) {
          mwidth = mwidth + mw;
          mheight = mheight + mh;
          left = left + ml;
          top = top + mt;
          wind.style.width = ( mwidth > width1 ? width1 : mwidth ) + 'px';
          wind.style.height = (mheight > height1 ? height1 : mheight) + 'px';
          wind.style.top = top + 'px';
          wind.style.left = left + 'px';
          await pause(10);
       }
       wind.style.width =  width1 + 'px';
       wind.style.height = height1 + 'px';
       wind.style.top = osetT  + 'px';
       wind.style.left = osetL  + 'px';
       wind.parentNode.removeChild(wind); 
       while (cube.firstChild) cube.removeChild(cube.firstChild);

/*
       const con_ = document.getElementById('contr_' + gameid);
       if (con_ != null) {
          ZINDEX_ ++;
          con_.style.zIndex = ZINDEX_;
          con_.chesscontrol_.style.zIndex = ZINDEX_;
       }
        container_.chesscontrol_.style.display = '';
*/
        container_.style.display = '';

        CONFIG_.boards[gameid].pinned = false;
        CONFIG_.boards[gameid].cubeid = null;
     }
   }

   async function pinCube(gameid) {
       const img = document.createElement('img');
       const cubes = cubicle.getElementsByClassName('cubelet');
       const container_ = document.getElementById('contr_' + gameid);
       const cube = findEmptyCube();
       const size = '36';
       img.src = '/images/chesscubes.svg';
       img.style = 'position: absolute; left: 0px; top: 0px; width: ' + size + 'px; height: ' + size + 'px; border: 2px solid #4a4a4a';
       img.onclick = unpinCube;
       img.container_ = container_;
       img.gameid_ = gameid;
       img.style.visibility = 'hidden';
       cube.appendChild(img);
       const wind = container_.cloneNode(false);
       const pin = document.createElement('span'); 

       chessdiv.appendChild(wind);
       container_.style.display = 'none';
       // container_.chesscontrol_.style.display = 'none';
       pin.innerHTML = '&#x1F4CD'; // '&#x1F4CC';
       pin.gameid_ = gameid;
       wind.style.border = '2px solid #ff0000';
       wind.style.backgroundColor = '#24262A';
       wind.style.zIndex = 200000;
       var top = parseInt(wind.style.top);
       var left = parseInt(wind.style.left);
       var width = parseInt(wind.style.width);
       var height = parseInt(wind.style.height);
       var mw = width / 10;
       var mh = height / 10;
       var offsetL = 0, offsetT = 0;
       var osetL = parseInt(wind.style.left), osetT = parseInt(wind.style.top);
       var topc = 0, leftc = 0;
       var ml = 0, mt = 0;

       var offsetL1 = img.parentNode.offsetLeft, offsetT1 = img.parentNode.offsetTop;
       var offsetL2 = img.parentNode.parentNode.offsetLeft, offsetT2 = img.parentNode.parentNode.offsetTop;
       var topc = parseInt(img.parentNode.offsetTop), leftc = parseInt(img.parentNode.offsetLeft);
       offsetL = offsetL1 + offsetL2, offsetT = offsetT1 + offsetT2;

       ml = (osetL - offsetL) / 10; mt = (osetT - offsetT ) / 10;
       for (var i=1; i <= 10; i++) {
          width = width - mw; 
          height = height - mh; 
          left = left - ml; 
          top = top - mt; 
          wind.style.width = width + 'px';
          wind.style.height = height + 'px';
          wind.style.top = top + 'px';
          wind.style.left = left + 'px';
           
          await pause(10); 
       }
       wind.style.width =  size + 'px';
       wind.style.height = size + 'px';
       wind.style.top = offsetT + 'px';
       wind.style.left = offsetL + 'px';
       wind.parentNode.removeChild(wind); 
       cube.parentNode.appendChild(pin);
       pin.style = 'position: absolute; top: ' + (cube.offsetTop - 8 ) + 'px; left: 35px; z-index: 10';
       img.style.visibility = 'visible';

       CONFIG_.boards[gameid].pinned = true;
       CONFIG_.boards[gameid].cubeid = cube.id;

   }

   function randomFENchess960() {
       const position = { a:'',b:'',c:'',d:'',e:'',f:'',g:'',h:'' };
       // generate random position of bishops
       const B1 = ['a','c','e','g'], bB = Math.round(Math.random() * 3);
       const B2 = ['b','d','f','h'], wB = Math.round(Math.random() * 3);
       const b1 = B1[wB], b2 = B2[bB];
       position[b1] = 'B'; position[b2] = 'B';
       B1[wB] = ''; B2[bB] = '';

       // generate random position of queen using B1 and B2 arrays
       const Q1 = ([].concat(B1,B2)).join('').split(''), Q = Math.round(Math.random() * 5);
       const q1 = Q1[Q];
       position[q1] = 'Q';
       Q1[Q] = '';

       // generate random position of the first knights using Q1 array
       const N1 = Q1.join('').split(''), Na = Math.round(Math.random() * 4);
       const n1 = N1[Na];
       position[n1] = 'N';
       N1[Na] = '';

       // generate random position of the first knights using N1 array
       const N2 = N1.join('').split(''), Nb = Math.round(Math.random() * 3);
       const n2 = N2[Nb];
       position[n2] = 'N';
       N2[Nb] = '';

       // generate random position of the rooks and Queens using N2 array
       const KR = N2.join('').split('').sort();
       position[KR[0]] = 'R';
       position[KR[1]] = 'K';
       position[KR[2]] = 'R';

       var parr = [];
       for (var p in position) { parr.push(position[p]); }

       var wrank = parr.join(''), brank = wrank.toLowerCase();

       const fen_ = brank + "/pppppppp/8/8/8/8/PPPPPPPP/" + wrank + " w KQKq - 0 1";
     
       return fen_;
   }

   function evaluatePosition(e) {
       const variant = CHESS960;
        var fen = 'rqk3br/p1b2ppp/2ppnn2/1p212P/6P1/1PPQ4/P2PPP2/R1KBNNBR w KQkq 0 1';
       // var fen = 'rqk5/1ppb1prp/3bn3/pP6/P1Q5/5N2/2PPP1PP/R1KN1B1R b KQkq 0 1';
       // var fen = 'qnbnrbkr/pp1p1ppp/4p3/8/1P6/P7/2P1PPPP/QNBNRBKR b KQkq 0 1';
       // var fen = 'rqk5/1pp5/8/8/P1Q5/8/3PP3/R1K4R b KQkq 0 1';
       var game = newBoard(e, hide = true, width = 480, height = 480, variant, fen);

       // game.tbox.reversed_ = true;
       // game.reverseBoard(null, game);
       game.maxSize(e, game) ;
       game.GAME_STATE.sidetomove_ = WHITE;
       game.sideBoard(false);
       game.GAME_STATE.status_ = STATUS.NEW;
       game.GAME_STATE.playstatus_ = STATUS.PLAYING;
       game.GAME_STATE.gameover_ = 0;
       notice("Evaluating Position ...");
       SESSION_.status = STATUS.EVALUATING;
       chess_reset.play();
   }

   BOARDTOP_ = 50;
   DEFAULTCOLOR_ = 'Cyan 1';
   function newBoard(e, hide = true, width = 480, height = 480, variant, fen ) {  // hide controls
       e.preventDefault();
       if (!CONFIG_.layout.free) {
          var len = CONFIG_.layout.coor.col * CONFIG_.layout.coor.row;
          if (BOARDS_.length >= len) return;
          width = CONFIG_.layout.coor.width;
          height = CONFIG_.layout.coor.height;
       }
       const rnd = Math.round(Math.random() * 100);
       const BOARD_COUNTER_ = Date.now() + rnd;
       var cnt = BOARDS_.length + 1;
       var id = 'game' + BOARD_COUNTER_, top = 40 + BOARDTOP_ * cnt, left = 145 + BOARDTOP_ * cnt ;
       var game = new Game(id, chessdiv, top=top, left=left, width=width, height=height, 
                           color=DEFAULTCOLOR_, control = _CONTROLON_, variant = variant, fen = fen);
       BOARDS_.push(game);
       CONFIG_.boards[id] = { top:top, left:left, width:width, height:height, zIndex: parseInt(game.container_.style.zIndex), 
                              color:DEFAULTCOLOR_, control:hide, pinned:false, cubeid: null };
        if (!CONFIG_.layout.free)  {
           const contr = game.container_;
           CONFIG_.layout.coor.width = parseInt(game.tbox.style.width);
           CONFIG_.layout.coor.height = parseInt(game.tbox.style.height);
            adjustLayout(false);
        }
        return game;
   }

   function sortBoard(b1, b2) {
      if (b1.zIndex < b2.zIndex) return -1;
      if (b1.zIndex > b2.zIndex) return 1;
      return 0;
   }

   function setBoardConfiguration() {
log(CONFIG_.boards);
       var boards = [];
       for (var p in CONFIG_.boards) {
          const board = CONFIG_.boards[p];
log(p + ':' + board.zIndex);
          var game = new Game(p, chessdiv, top=board.top, left=board.left, width=board.width, height=board.height, 
				color=board.color, padding=14, control=board.hide);
          if (board.humanoid != null) {
             game.tbox.humanoid_  = board.humanoid;
             game.tbox.machinoid_ = board.machinoid;
          }
          BOARDS_.push(game);
          boards.push({ id: p, cont: game.container_, zIndex: board.zIndex });
       }
       const sortedboards = boards.sort(sortBoard);
log(sortedboards);
       for (var p in sortedboards) {
         const board = sortedboards[p];
         ZINDEX_++;
         board.cont.style.zIndex = ZINDEX_;
         CONFIG_.boards[board.id].zIndex = ZINDEX_;
         log(board.cont.id);
         log(board.cont.style.zIndex);
         if (CONFIG_.boards[board.id].pinned) pinCube(board.id);
       }
log(CONFIG_.boards);
   }

   function setConfiguration() {
log("setting configuration ...");
log(CONFIG_);
      if (CONFIG_.ratesystem == 'rmoo') {
          ratingid.innerHTML = '(O)';
      } else
      if (CONFIG_.ratesystem == 'elo') {
          ratingid.innerHTML = '(E)';
      } else
      if (CONFIG_.ratesystem == 'glicko2' || CONFIG_.ratesystem == 'glicko') {
          ratingid.innerHTML = '(G2)';
      }
      // setBoardConfiguration();
   }

   function menuEvent(this_, hcolor, dcolor, ncolor) {
       this_.onmousedown = function() { this.style.color = dcolor; }
       this_.onmouseup   = function() { this.style.color = ncolor; }
       this_.onmouseover = function() { this.style.color = hcolor; }
       this_.onmouseout  = function() { this.style.color = ncolor; }
   }

   function useMenu(icons, func, title, hcolor = '#3CC187', dcolor = '#8C4E10', ncolor = '#000000') {
         const condiv = document.createElement('div');
         condiv.className = 'geartoolsclass';

         for (var i=0; i< icons.length; i++) {
            const ctrl = document.createElement('span');
            const tt = '<span style="font-size: 12px; font-weight: normal; font-family: helvetica">' + title[i] + '</span>';
            if (icons[i] == '-') {
              ctrl.innerHTML = '<hr>'; 
              ctrl.style = "position: absolute; display: inline-block; width: 85%; left: 10px; top: " + (5 + i * 28) + 'px';
            } else {
              ctrl.style = 'position: absolute; cursor: pointer; left: 10px; top: ' + (5 + i * 28) +  'px';
              ctrl.innerHTML = icons[i] + '&nbsp;&nbsp;&nbsp;' + tt;
              ctrl.onclick = func[i];
              ctrl.title = title[i];
              menuEvent(ctrl, hcolor, dcolor, ncolor);
            }
            condiv.appendChild(ctrl);
         }
         condiv.style.visibility = 'hidden';
         this.sidecontrol_ = condiv;
         condiv.addEventListener('mouseleave', function() { this.style.visibility = 'hidden'; return true} , false);
         return condiv;
     }

   function  createPGNWindow() {
        const height = parseInt(chessls.style.height);
        const width = parseInt(chessls.style.width);
        const pos = pageSize();
        chessls.style.visibility = 'visible';
        chessls.style.position = 'fixed';
        chessls.style.left = '5px';
        chessls.style.top =  pos.height + 'px';
        window.onresize = onWindowResize;
        chessdiv.appendChild(chessls);
        chessdiv.PGNWindow_ = false;
        setPGNControl(chesscv);

        var next = chessor.firstChild;
        while (next) {
           if (next.nodeType == 1) next.order
          next = next.nextSibling;
        }
    }

    function setPGNControl(chesscv) {
         if (typeof(chesscv.filled_) != "undefined") return;
         const icons = ['&#x21A5;', '&#x25B6;', '&#x266C;' ];
         const func  = [ showPGNWindow, prepareContinuousPlay, playAW ];
         const title = [ 'Show/Hide PGN Window', 'Play Continuously', 'Enable Music' ];
         for (var i=0; i<3; i++) {
            const ctrl = document.createElement('span');
            ctrl.style = 'position: absolute; cursor: pointer; top: 2px; left: ' + (5 + i * 28) +  'px';  // above the board
            ctrl.innerHTML = icons[i];
            ctrl.onclick = func[i];
            ctrl.title = title[i];
            chesscv.appendChild(ctrl);
         }
          chesscv.filled_ = true;
     }

     function prepareContinuousPlay(e) {
        var this_ = chessdiv.loadedgame_;
        if (this_ != null) {
            this_.continuousPlay(e, this);
        }
     }

     async function showPGNWindow(e, show = false) {
         const pos = pageSize();
         const height = parseInt(chessls.style.height);
         const width = parseInt(chessls.style.width);
         const left = '5px'
         const top = ( pos.height);
         chessls.style.left = left + 'px';
         if (show && chessdiv.PGNWindow_) return;
         chessdiv.PGNWindow_ = (chessdiv.PGNWindow_) ? false : true;
        
         if (chessdiv.PGNWindow_) {
           for (var i=top; i >= (top - height); i-=10) {
              chessls.style.top = i + 'px';
              await pause(1);
           }
           chessls.style.top = (top - height) + 'px';
           chesscv.firstChild.innerHTML = '&#x21A7;';
         } else {
           for (var i=(top - height); i <= top; i+=10) {
              chessls.style.top = i + 'px';
              await pause(1);
           }
           chessls.style.top = (top) + 'px';
           chesscv.firstChild.innerHTML = '&#x21A5;';
         }
     }

     function onWindowResize() {
         const pos = pageSize();
         const chessls = document.getElementById('chesslisting');
         const chessid = document.getElementById('chesslistid');
         const condiv = document.getElementById('playcontrolid');
         var width = parseInt(chessls.style.width);
         var height = parseInt(chessls.style.height);
         const left = '5px';
         const top = ( pos.height - height);
         chessls.style.left = left + 'px';
        if (chessdiv.PGNWindow_) {
           chessls.style.top = top + 'px';
        } else {
           chessls.style.top = pos.height + 'px';
        }

        width = parseInt(signupdivid.style.width);
        height = parseInt(signupdivid.style.height);
        signupdivid.style.left = ((pos.width - width)/2) + 'px'
        signupdivid.style.top = ((pos.height - 50 - height)/2) + 'px'
        var btn = signupdivid.getElementsByTagName('button')[0]; 
        btn.onmousedown = function() { this.style.color = '#ffffff' }
        btn.onmouseup = function() { this.style.color = '#252525' }

        width = parseInt(signindivid.style.width);
        height = parseInt(signindivid.style.height);
        signindivid.style.left = ((pos.width - width)/2) + 'px'
        signindivid.style.top = ((pos.height - 50 - height)/2) + 'px'
        btn = signindivid.getElementsByTagName('button')[0]; 
        btn.onmousedown = function() { this.style.color = '#ffffff' }
        btn.onmouseup = function() { this.style.color = '#252525' }
        
        searchid.onclick = showSearchTools;
        gearid.onclick = showGearTools;
/*
        if (SESSION_.sessionid == null)  {
           signinid.style.visibility = 'visible';      
           registerid.style.visibility = 'visible';      
        }
*/

        if (pos.width > 1200) {
           othertoolsid.style.left = (pos.width - 60) + 'px'
           signinid.style.left = (pos.width - 160) + 'px'
           registerid.style.left = (pos.width - 80) + 'px'
           profileid.style.left = (parseInt(othertoolsid.style.left) - 460) + 'px';
           tourneyid.style.left = (parseInt(othertoolsid.style.left) - 460) + 'px';
        }


        const windows = [waitingmatchid, settingsdivid ];

        for (var p in windows) {
          const window = windows[p];
          width = parseInt(window.style.width);
          height = parseInt(window.style.height);
          window.style.left = ((pos.width - width)/2)  + 'px';
          window.style.top = ((pos.height - height)/2)  + 'px';
        }
 
        /* hide error messages while resizing */
        const err = document.getElementById("errordivid");
        err.style.visibility = 'hidden'

     }

     function mouseDownForSlide(e) {
         const settingsid = document; // settingsdivid;
         var   dwidth = this.parentNode.clientWidth;
         const pos = scrollOffset(e);
         this.startPosX = pos.x;
         this.maxlim_ = dwidth;
         settingsid.addEventListener('mousemove', mouseMoveForSlide, false);
         settingsid.targetmove_ = this;
     }
 
     function mouseMoveForSlide(e) {
         const settingsid = document; // settingsdivid;
         var this_ = settingsid.targetmove_;
         var left = parseInt(this_.style.left);
         var pos = scrollOffset(e);
         var np = this_.startPosX - pos.x;
         var fin_np = left - np;
         var maxd = this_.maxlim_ - this_.clientWidth;
         if (fin_np <= 0) { fin_np  = 0; pos.x = this_.startPosX };
         if (fin_np > maxd) { fin_np = maxd; pos.x = this_.startPosX };
         this_.startPosX = pos.x;
         this_.style.left = fin_np + 'px';

         var perc = fin_np / maxd;
         var diff = Math.round((this_.range_.possible.length) * perc);
         this_.value_ = (diff >= this_.range_.possible.length) ? this_.range_.possible.length - 1 : diff;
         this_.fin_np_ = fin_np;
         if (this_.range_) {
            if (this_.range_.csimulid) {
                this_.range_.csimulid.innerHTML = this_.range_.possible[this_.value_];
                this_.range_.csimulabelid.innerHTML = (this_.value_ == 0) ? '': 'simul';
            } else
            if (this_.range_.cucieloid) {
                this_.range_.cucieloid.innerHTML = this_.range_.possible[this_.value_];
            } else
            if (this_.range_.cmovetimeid) {
                this_.range_.cmovetimeid.innerHTML = this_.range_.possible[this_.value_];
            } else
            if (this_.range_.cdepthid) {
                this_.range_.cdepthid.innerHTML = this_.range_.possible[this_.value_];
            } else
            if (this_.range_.cgameminid) {
                this_.range_.cgameminid.innerHTML = this_.range_.possible[this_.value_];
            } else
            if (this_.range_.cgameincid) {
                this_.range_.cgameincid.innerHTML = this_.range_.possible[this_.value_];
            } else
            if (this_.range_.simulid) {
                this_.range_.simulid.innerHTML = this_.range_.possible[this_.value_];
                this_.range_.simulabelid.innerHTML = (this_.value_ == 0) ? '': 'simul';
            } else
            if (this_.range_.gameminid) {
                this_.range_.gameminid.innerHTML = this_.range_.possible[this_.value_];
            } else
            if (this_.range_.gameincid) {
                this_.range_.gameincid.innerHTML = this_.range_.possible[this_.value_];
            } else
            if (this_.range_.minrateid) {
                this_.range_.minrateid.innerHTML = this_.range_.possible[this_.value_].mi;
                this_.range_.maxrateid.innerHTML = this_.range_.possible[this_.value_].ma;
            }
         }
         return true;
     }

     function mouseUpForSlide(e) {
         const settingsid = document; // settingsdivid;
         settingsid.removeEventListener('mousemove', mouseMoveForSlide);
         return true;
     }

     function switchCheckBox(name, this_) {
        var vis_ = true;
        const chk = '&#x2714'; unchk = '&#x2716';
        this_.checked_ = vis_ = typeof(this_.checked_) == "undefined" ? false : !this_.checked_;
        this_.innerHTML = name + '&nbsp; &nbsp; ' + ((vis_) ? chk : unchk);
        return vis_;
     }

     function showGameSettings(this_, simul = false) {
         const pos = pageSize();
         const tbox = (simul) ? null : this_.tbox; 
         const settingsid = settingsdivid;
         const width = parseInt(settingsid.style.width);
         const height = parseInt(settingsid.style.height);
         const left = (pos.width - width) / 2;
         const top = (pos.height - height) / 2;

         blanket.style.visibility = 'hidden';
         signindivid.style.visibility = 'hidden';
         signupdivid.style.visibility = 'hidden';

         if (SESSION_.status == STATUS.JOINING) {
            notice("In Joined mode ...");
            return;
         } else
         if (SESSION_.status == STATUS.PLAYING) {
            notice("In Playing  mode ...");
            return;
         } else
         if (SESSION_.status == STATUS.SIMULPLAYING) {
            notice("In Simul Playing  mode ...");
            return;
         } else
         if (SESSION_.status == STATUS.SEEKMATCH) {
            notice("In Game-Match mode ...");
            return;
         } else
         if (SESSION_.status == STATUS.SEEKSIMUL) {
            notice("In Simul-Match mode ...");
            return;
         }

         updateUIGameSettings((simul) ? settingsid : tbox, simul);

         // settings
         const btns = settingsid.getElementsByTagName('button');
         for (var p in btns) {
           const btn = btns[p];
           if (btn.nodeType == 1) {
                btn.onmousedown = function() { this.style.color = '#ffffff' }
                btn.onmouseup = function() { this.style.color = '#252525' }
                btn.settings_ = settingsid;
                if (btn.id == 'humanbtnid') {
                    btn.onclick = switchPlayer;
                    settingsid.humanbtnid_ = btn;
                } else
                if (btn.id == 'computerbtnid') {
                    btn.onclick = switchPlayer;
                    settingsid.computerbtnid_ = btn;
                } else
                if (btn.id == 'seekbtnid') {
                    if (this_ != null) {
                       btn.game_ = this_;
                       btn.onclick = this_.seekMatch; 
                       settingsid.seekbtnid_ = btn;
                    } else {
                       btn.onclick = playSimulHuman; 
                    }
                } else
                if (btn.id == 'playcompbtnid') {
                    if (this_ != null) {
                       btn.game_ = this_;
                       btn.onclick = this_.playComputer; 
                       settingsid.playcompbtnid_ = btn;
                    } else {
                       btn.onclick = playSimulComputer; 
                    }
                }
           }
         }

         const closeid = settingsid.getElementsByClassName('settingscloseid')[0];
         closeid.gsettings = (simul) ? settingsid : this_;
         closeid.simul_ = simul;
         closeid.onclick = function() {
                closeGameSettings(); captureGameSettings(this.gsettings, this.simul_); 
            } 

         const humanid = settingsid.getElementsByClassName('humanid')[0];
         const computerid = settingsid.getElementsByClassName('computerid')[0];
         settingsid.humanid_ = humanid;
         settingsid.computerid_ = computerid;

         settingsid.style.left = left + 'px';
         settingsid.style.top = top + 'px';

       
         blanket.style.visibility = 'visible';
         settingsid.style.visibility = 'visible';
         if (settingsid.whichbtn_  ==  null) settingsid.whichbtn_ = 'humanbtnid';
         humanid.style.visibility = (settingsid.whichbtn_ == 'humanbtnid') ? 'visible' : 'hidden';
         computerid.style.visibility = (settingsid.whichbtn_ == 'computerbtnid') ? 'visible' : 'hidden';
    }


    function updateUIGameSettings(tbox, simul = false) {
         const settingsid = settingsdivid;
         const gsettings  = (simul) ? settingsid : tbox;
         const slides     = settingsid.getElementsByClassName('slidecon');
         const spn        = settingsid.getElementsByTagName('span');
         if (gsettings.humanoid_ == null) {
              gsettings.humanoid_  = { israted: true, istitled: false, simul: 0, gamerange: 17, gamemin: 5, gameinc: 0, variant: 1, piece: 3,  player: 1 }
              gsettings.machinoid_ = { isnnue: true, islimstrength: true, depth: 9, movetime: 4, ucielo: 7, gamemin: 5, gameinc: 0, 
	                               variant: 1, piece: 3, simul: 0 }
         }
         for (var p in slides) {
               var slide = slides[p];
               if (slide.nodeType == 1) {
                  const range = slide.parentNode.clientWidth - slide.clientWidth;
                  slide.gsettings_ = gsettings;
                  if (slide.id == "chesssimulid") {
                       const simulabelid = document.getElementById('simulabelid');
                       const simulid = document.getElementById('simulid');
                       slide.value_ = gsettings.humanoid_.simul;
                       simulid.innerHTML = possible_simul[slide.value_];
                       simulabelid.innerHTML = (slide.value_ == 0) ? '': 'simul';
                       slide.range_ = { possible: possible_simul, simulid: simulid, simulabelid: simulabelid };
                       const fin_np = ( slide.value_ * range ) / (possible_simul.length - 1);
                       slide.style.left = fin_np + 'px';
                  } else
                  if (slide.id == "chessrangeid") {
                       const minrateid = document.getElementById('minratingid');
                       const maxrateid = document.getElementById('maxratingid');
                       slide.value_ = gsettings.humanoid_.gamerange;
                       minratingid.innerHTML = possible_ranges[slide.value_].mi;
                       maxratingid.innerHTML = possible_ranges[slide.value_].ma;
                       slide.range_ = { possible: possible_ranges, minrateid: minrateid, maxrateid: maxrateid };
                       const fin_np = (slide.value_ * range ) / (possible_ranges.length - 1);
                       slide.style.left = fin_np + 'px';
                  } else
                  if (slide.id == "chesstimerid") {
                       const gameminid = document.getElementById('gameminid');
                       slide.value_ = gsettings.humanoid_.gamemin;
                       gameminid.innerHTML = possible_timer[slide.value_];
                       slide.range_ = { possible: possible_timer, gameminid: gameminid };
                       const fin_np = ( slide.value_ * range ) / (possible_timer.length - 1);
                       slide.style.left = fin_np + 'px';
                  } else
                  if (slide.id == "chessincid") {
                       const gameincid = document.getElementById('gameincid');
                       slide.value_ = gsettings.humanoid_.gameinc;
                       gameincid.innerHTML = possible_inc[slide.value_];
                       slide.range_ = { possible: possible_inc, gameincid: gameincid };
                       const fin_np = ( slide.value_ * range ) / (possible_inc.length - 1);
                       slide.style.left = fin_np + 'px';
                  } else
                  if (slide.id == "chessucieloid") {
                       const cucieloid = document.getElementById('cucieloid');
                       slide.value_ = gsettings.machinoid_.ucielo;
                       cucieloid.innerHTML = possible_rating[slide.value_];
                       slide.range_ = { possible: possible_rating,  cucieloid: cucieloid };
                       const fin_np = ( slide.value_ * range ) / (possible_rating.length - 1);
                       slide.style.left = fin_np + 'px';
                  } else
                  if (slide.id == "chessmovetimeid") {
                       const cmovetimeid = document.getElementById('cmovetimeid');
                       slide.value_ = gsettings.machinoid_.movetime;
                       cmovetimeid.innerHTML = possible_movetime[slide.value_];
                       slide.range_ = { possible: possible_movetime, cmovetimeid: cmovetimeid };
                       const fin_np = ( slide.value_ * range ) / (possible_movetime.length - 1);
                       slide.style.left = fin_np + 'px';
                  } else
                  if (slide.id == "chessdepthid") {
                       const cdepthid = document.getElementById('cdepthid');
                       slide.value_ = gsettings.machinoid_.depth;
                       cdepthid.innerHTML = possible_depth[slide.value_];
                       slide.range_ = { possible: possible_depth, cdepthid: cdepthid };
                       const fin_np = ( slide.value_ * range ) / (possible_depth.length - 1);
                       slide.style.left = fin_np + 'px';
                  } else
                  if (slide.id == "chesscompminid") {
                       const cgameminid = document.getElementById('cgameminid');
                       slide.value_ = gsettings.machinoid_.gamemin;
                       cgameminid.innerHTML = possible_timer[slide.value_];
                       slide.range_ = { possible: possible_timer, cgameminid: cgameminid };
                       const fin_np = ( slide.value_ * range ) / (possible_timer.length - 1);
                       slide.style.left = fin_np + 'px';
                  } else
                  if (slide.id == "chesscompincid") {
                       const cgameincid = document.getElementById('cgameincid');
                       slide.value_ = gsettings.machinoid_.gameinc;
                       cgameincid.innerHTML = possible_inc[slide.value_];
                       slide.range_ = { possible: possible_inc, cgameincid: cgameincid };
                       const fin_np = ( slide.value_ * range ) / (possible_inc.length - 1);
                       slide.style.left = fin_np + 'px';
                  } else
                  if (slide.id == "chesscompsimulid") {
                       const csimulabelid = document.getElementById('csimulabelid');
                       const csimulid = document.getElementById('csimulid');
                       slide.value_ = gsettings.machinoid_.simul;
                       csimulid.innerHTML = possible_csimul[slide.value_];
                       csimulabelid.innerHTML = (slide.value_ == 0) ? '': 'simul';
                       slide.range_ = { possible: possible_csimul, csimulid: csimulid, csimulabelid: csimulabelid };
                       const fin_np = ( slide.value_ * range ) / (possible_csimul.length - 1);
                       slide.style.left = fin_np + 'px';
                  }
                  slide.onmousedown = mouseDownForSlide;
                  document.onmouseup = mouseUpForSlide;
               }
         }

         for (var p in spn) {
               var spn_ = spn[p];
               if (spn_.nodeType == 1) {
                  spn_.gsettings_ = gsettings;
                  if (spn_.id == "isratedid") {
                     spn_.onclick = function() { this.gsettings_.humanoid_.israted = switchCheckBox("Rated", this); }
                     spn_.checked_ = !gsettings.humanoid_.israted;
                     switchCheckBox("Rated", spn_);
                  } else
                  if (spn_.id == "istitledid") {
                     spn_.onclick = function() { this.gsettings_.humanoid_.istitled = switchCheckBox("Titled", this); }
                     spn_.checked_ = !gsettings.humanoid_.istitled;
                     switchCheckBox("Titled", spn_);
                  } else
                  if (spn_.id == "isnnueid") {
                     spn_.onclick = function() { this.gsettings_.machinoid_.isnnue = switchCheckBox("NNUE", this); }
                     spn_.checked_ = !gsettings.machinoid_.isnnue;
                     switchCheckBox("NNUE", spn_);
                  } else
                  if (spn_.id == "islimstrengthid") {
                     spn_.onclick = function() { this.gsettings_.machinoid_.islimstrength = switchCheckBox("Limit Strength", this); }
                     spn_.checked_ = !gsettings.machinoid_.islimstrength;
                     switchCheckBox("Limit Strength", spn_);
                  }
               }
         }

         const func = function(item, span, p, list) {
            const value = list[p - 1].item;
            span.innerHTML = (value.length > 35) ? value.slice(0,35) + ' ...' : value;
            item.value_ = p;
         }

         func(chessselectvariantid, chessspanvariantid, gsettings.humanoid_.variant, variants);
         func(chessselectpieceid, chessspanpieceid, gsettings.humanoid_.piece, pieces);
         func(chessselectplayerid, chessspanplayerid, gsettings.humanoid_.player, players);

         func(chesscompselectvariantid, chesscompspanvariantid, gsettings.machinoid_.variant, variants);
         func(chesscompselectpieceid, chesscompspanpieceid, gsettings.machinoid_.piece, pieces);

     }

     function captureGameSettings(this_, simul = false) {
         const settingsid = settingsdivid;
         const gsettings  = (simul) ? settingsid : this_.tbox;

         const slides = settingsid.getElementsByClassName('slidecon');
         for (var p in slides) {
               var slide = slides[p];
               if (slide.nodeType == 1) {
                  if (slide.id == "chesssimulid") {
                       gsettings.humanoid_.simul = parseInt(slide.value_);
                  } else
                  if (slide.id == "chessrangeid") {
                       gsettings.humanoid_.gamerange = parseInt(slide.value_);
                  } else
                  if (slide.id == "chesstimerid") {
                       gsettings.humanoid_.gamemin = parseInt(slide.value_);
                  } else
                  if (slide.id == "chessincid") {
                       gsettings.humanoid_.gameinc = parseInt(slide.value_);
                  } else
                  if (slide.id == "chessdepthid") {
                       gsettings.machinoid_.depth = parseInt(slide.value_);
                  } else
                  if (slide.id == "chessmovetimeid") {
                       gsettings.machinoid_.movetime = parseInt(slide.value_);
                  } else
                  if (slide.id == "chessucieloid") {
                       gsettings.machinoid_.ucielo = parseInt(slide.value_);
                  } else
                  if (slide.id == "chesscompminid") {
                       gsettings.machinoid_.gamemin = parseInt(slide.value_);
                  } else
                  if (slide.id == "chesscompincid") {
                       gsettings.machinoid_.gameinc = parseInt(slide.value_);
                  }else
                  if (slide.id == "chesscompsimulid") {
                       gsettings.machinoid_.simul = parseInt(slide.value_);
                  } 
               }
         }
         const spn = settingsid.getElementsByTagName('span');
         for (var p in spn) {
               var spn_ = spn[p];
               if (spn_.nodeType == 1) {
                  if (spn_.id == "isratedid") {
                        gsettings.humanoid_.israted = (spn_.checked_ == null) ? true : spn_.checked_;
                  } else
                  if (spn_.id == "istitledid") {
                        gsettings.humanoid_.istitled = (spn_.checked_ == null) ? true : spn_.checked_;
                  } else
                  if (spn_.id == "isnnueid") {
                       gsettings.machinoid_.isnnue =  (spn_.checked_ == null) ? true : spn_.checked_;
                  } else
                  if (spn_.id == "islimstrengthid") {
                       gsettings.machinoid_.islimstrength = (spn_.checked_ == null) ? true : spn_.checked_;
                  }
               }
         }

         gsettings.humanoid_.variant = (chessselectvariantid.value_ != null) ? chessselectvariantid.value_ : 1;
         gsettings.humanoid_.piece   = (chessselectpieceid.value_ != null) ? chessselectpieceid.value_ : 3 ;
         gsettings.humanoid_.player  = (chessselectplayerid.value_ != null) ? chessselectplayerid.value_: 1;

         gsettings.machinoid_.variant = (chesscompselectvariantid.value_ != null) ? chesscompselectvariantid.value_ : 1;
         gsettings.machinoid_.piece = (chesscompselectpieceid.value_ != null) ? chesscompselectpieceid.value_ : 1;

log("suppose to pick up changes ...");
log(gsettings.humanoid_);
log(gsettings.machinoid_);
        CONFIG_.simul = simul;
        if (simul) {
          CONFIG_.humanoid  = gsettings.humanoid_;
          CONFIG_.machinoid = gsettings.machinoid_;
        } else {
          CONFIG_.boards[this_.id].humanoid = gsettings.humanoid_;
          CONFIG_.boards[this_.id].machinoid = gsettings.machinoid_;
        }
log(CONFIG_);
        return gsettings;
     }

     function showSearchTools() {
     }

     function showGearTools(e) {
        e.preventDefault();
        if (SESSION_.sessionid == null) return;
        var left = parseInt(this.parentNode.style.left) - 110;
        geartoolsid.style.left = left + 'px';
        var spn = geartoolsid.getElementsByClassName('gearitems');
        for (var p in spn) {
           const s = spn[p];
           if (s.nodeType == 1) {
             if (s.id != 'skipid') {
	       s.onmousedown = function() { 
	           this.style.backgroundColor = '#afafaf';
                   if (this.id != 'profileupdateid') { profileid.style.visibility = 'hidden'; }
               }
               s.onmouseup   = function() { this.style.backgroundColor = '' }
               s.onmouseover = function() { this.style.backgroundColor = '#ffffff' }
               s.onmouseout = function() { this.style.backgroundColor = '' }
               if (s.id == 'ratesystemid') s.onclick = changeRateSystem;
               if (s.id == 'saveconfigid') s.onclick = saveConfig;
               if (s.id == 'signout') s.onclick = signout;
             }
           }
        }

        const signin = signindivid;
        const signup = signupdivid;

        signup.style.visibility = 'hidden';
        signin.style.visibility = 'hidden';

        const vis = geartoolsid.style.visibility;
        geartoolsid.style.visibility = (vis == 'hidden') ? 'visible' : 'hidden';
        addLeaveEvent(geartoolsid);
     }

     function addLeaveEvent(item, childs) {
        const leavemouse = function() { 
		   this.leftroad_ = true; 
                   for (var p in this.childs_) { this.childs_[p].leftroad_ = true; }
                   return true;
               }
        const entermouse = function() { 
		   this.leftroad_ = false; 
                   for (var p in this.childs_) { this.childs_[p].leftroad_ = false; }
                   return true;
               }
        item.addEventListener("mouseleave", leavemouse, false);
        item.addEventListener("mouseenter", entermouse, false);
        item.childs_  = childs
       
     }

     function saveConfig() {
log("emitting save config ...");
        socket.emit("saveconfig", { username: SESSION_.username, sessionid: SESSION_.sessionid, config: CONFIG_ });
     }

     function changeRateSystem() {
log('before');
log(CONFIG_);
         if (CONFIG_.ratesystem == 'our') {
             CONFIG_.ratesystem = 'elo';
             ratingid.innerHTML = '(E)';
         } else
         if (CONFIG_.ratesystem == 'elo') {
             CONFIG_.ratesystem = 'glicko2'; 
             ratingid.innerHTML = '(G2)';
         } else
         if (CONFIG_.ratesystem == 'glicko2') {
             CONFIG_.ratesystem = 'rmoo';
             ratingid.innerHTML = '(O)';
         }
log('after');
log(CONFIG_);
         socket.emit("changeratesystem", { username: SESSION_.username, sessionid: SESSION_.sessionid, ratesystem: CONFIG_.ratesystem });
     }

/*
    function closeGameSettings(e, game_ = null) {
      const this_ = (game_ == null) ? this.game_ : game_;
      const tbox  = this_.tbox;
      const settingsid = settingsdivid;
      const humanid = settingsid.humanid_;
      const computerid = settingsid.computerid_;
      hideErrors();
      humanid.style.visibility = 'hidden';
      computerid.style.visibility = 'hidden';
      settingsid.style.visibility = 'hidden';
      CONFIG_.boards[this_.id].humanoid = tbox.humanoid_;
      CONFIG_.boards[this_.id].machinoid = tbox.machinoid_;
    }
*/

    function switchPlayer() {
        const humanid = this.settings_.humanid_;
        const computerid = this.settings_.computerid_;
        const humanbtnid = this.settings_.humanbtnid_;
        const computerbtnid = this.settings_.computerbtnid_;
        if (this.id == 'humanbtnid') {
           humanid.style.visibility = 'visible';
           computerid.style.visibility = 'hidden';
           humanbtnid.style.backgroundColor = '#81d765';
           computerbtnid.style.backgroundColor = '#AED8CF';
           this.settings_.whichbtn_ = 'humanbtnid';
        } else
        if (this.id == 'computerbtnid') {
           humanid.style.visibility = 'hidden';
           computerid.style.visibility = 'visible';
           humanbtnid.style.backgroundColor = '#AED8CF';
           computerbtnid.style.backgroundColor = '#81d765';
           this.settings_.whichbtn_ = 'computerbtnid';
        }
    }

    function setFEN(input_) {
      var fen = clearFEN(input_);
      var this_ = input_.parentNode.game_;
      this_.setFENonBoard(fen, this_, true);
      chess_reset.currentTime = 0;
      chess_reset.play();
      this_.GAME_STATE.status_ = STATUS.SET;
    }

    function clearFEN(input_) {
      var input = input_.parentNode.getElementsByTagName('input')[0];
      var this_ = input_.parentNode.game_;
      this_.quiesce_system(this_, false);
      this_.clearBoard(this_);
      chess_reset.currentTime = 0;
      chess_reset.play();
      this_.GAME_STATE.status_ = STATUS.SET;
      return input.value;
    }

    function saveFEN(this_) {
      var fenid = this_.parentNode.getElementsByTagName('input')[0];
      log(fenid.value);
    }

    function askMatch(this_) {
    }

    function showPwdReset(this_) {
    }


    function hideError(this_) {
       ERRLOC_ = null;
       this_.style.visibility = 'hidden';
    }

    ERRMSG_ = '';
    ERRLOC_ = null;
    function showError(this_) {
        const err = document.getElementById("errordivid");
        const offsetL = this_.parentNode.offsetLeft + this_.parentNode.parentNode.offsetLeft ;
        const offsetT = this_.parentNode.offsetTop + this_.parentNode.parentNode.offsetTop ;
        const left = parseInt(this_.style.left);
        const top = parseInt(this_.style.top);
        const vis = err.style.visibility;
        const errloc = (offsetL + left + 50) + 'px' + (offsetT + top) + 'px';
        if (vis == 'hidden' || ERRLOC_ != errloc) {
            err.style.left = (offsetL + left + 50) + 'px';
            err.style.top = (offsetT + top) + 'px';
            err.innerHTML = ERRMSG_;
            err.style.visibility = 'visible';
            ERRLOC_ = errloc; 
            setTimeout(hideError, 3000, err);
            return;
        } 
        ERRLOC_ = null;
        err.style.visibility = 'hidden';
     }
 
     function hideErrors() {
        /* hide error messages while resizing */
        const err = document.getElementById("errordivid");
        err.style.visibility = 'hidden';
        const errs = document.getElementsByClassName("defaulterr");
        for(var p in errs) {
          if (errs[p].nodeType == 1) {
              errs[p].style.visibility = 'hidden';
          }
        }
     }

     function signup() {
      const su_unid = document.getElementById("su_usernameid");
      const su_fnid = document.getElementById("su_firstnameid");
      const su_lnid = document.getElementById("su_lastnameid");
      const su_mlid = document.getElementById("su_emailid");
      const su_pwid = document.getElementById("su_passwdid");
      hideErrors();
      socket.emit("signup", { unid: su_unid.value, fnid: su_fnid.value, lnid: su_lnid.value, 
                              mlid: su_mlid.value, pwid: su_pwid.value, sessionid: SESSION_.sessionid });
      su_unid.value = ''; su_fnid.value = '';
      su_lnid.value = ''; su_mlid.value = ''; su_pwid.value = '';
     }

     function signin() {
      const si_unid = document.getElementById("si_usernameid");
      const si_pwid = document.getElementById("si_passwdid");
      hideErrors();
      socket.emit("signin", { unid: si_unid.value, pwid: si_pwid.value, sessionid: SESSION_.sessionid, guest: SESSION_.username });
      si_unid.value = ''; si_pwid.value = '';
     }

     function signout() {
      hideErrors();
      socket.emit("signout", { unid: SESSION_.username, sessionid: SESSION_.sessionid });
      this.parentNode.style.visibility = 'hidden';
     }

     function showSignIn(id) {
        const signin = signindivid;
        const signup = signupdivid;

        const si_unid = document.getElementById("si_usernameid"); si_unid.value = '';
        const si_pwid = document.getElementById("si_passwdid"); si_pwid.value = '';

        closeGameSettings();
        blanket.style.visibility = 'visible';
        signin.style.visibility = 'visible';
        signup.style.visibility = 'hidden';
        geartoolsid.style.visibility = 'hidden';
        schedtourneyid.style.visibility = 'hidden';

        hideErrors();
        keyPress(true);
     }

     function showSignUp(id) {
        const signin = signindivid;
        const signup = signupdivid;

        const su_unid = document.getElementById("su_usernameid"); su_unid.value = '';
        const su_fnid = document.getElementById("su_firstnameid");  su_fnid.value = '';
        const su_lnid = document.getElementById("su_lastnameid"); su_lnid.value = '';
        const su_mlid = document.getElementById("su_emailid"); su_mlid.value = '';
        const su_pwid = document.getElementById("su_passwdid"); su_pwid.vlaue = '';

        closeGameSettings();
        blanket.style.visibility = 'visible';
        signup.style.visibility = 'visible';
        signin.style.visibility = 'hidden';
        geartoolsid.style.visibility = 'hidden';
        schedtourneyid.style.visibility = 'hidden';

        hideErrors();
        keyPress(true);
     }

     function signedinPlayer(session) {
        const res = session;
        if (res.sessionid && res.restype == 'signin') {
                 SESSION_ = {  username: res.username, country: res.country, sessionid: res.sessionid, title: res.fide_title,  status: STATUS.NOTPLAYING,
                               rating: res.rating, photo: res.photo, ratesystem: res.ratesystem, disconnected: false, utype: REGISTERED }
log("checking config ....");
log(res);
log(SESSION_);
log(CONFIG_);
                 document.cookie = "chess_=" + JSON.stringify({ sessionid: res.sessionid, username: res.username, utype: REGISTERED});
                 if (res.config != null) CONFIG_ = JSON.parse(res.config);
log(CONFIG_);
              }
              if (res.restype != null) {
                 if (res.restype == 'signup' || res.restype == 'signin') {
                    authorizeView();
                    if (res.restype == 'signin') {
                        const usernameid = document.getElementById('usernameid');
                        usernameid.innerHTML = res.username;
                        const pr_username  = document.getElementById('pr_username');
/* remove personal information
                        const pr_firstname = document.getElementById('pr_firstname');
                        const pr_lastname  = document.getElementById('pr_lastname');
                        const pr_email     = document.getElementById('pr_email');
                        const pr_phone     = document.getElementById('pr_phone');
                        const pr_desc      = document.getElementById('pr_desc');
*/
                        const pr_rating    = document.getElementById('pr_rating');
                        pr_username.value = res.username;
/* remove personal information
                        pr_firstname.value = res.firstname;
                        pr_lastname.value = res.lastname;
                        pr_email.value = res.email;
                        pr_phone.value = res.phone;
                        pr_desc.value = res.desc;
*/
                        pr_rating.value = res.fide_rating;
                        if (res.config == null)  ratingid.innerHTML = '(E)'; else
                        if (res.config.ratesystem == 'rmoo') ratingid.innerHTML = '(O)'; else
                        if (res.config.ratesystem == 'elo') ratingid.innerHTML = '(E)'; else
                        if (res.config.ratesystem == 'glicko2' ||
                            res.config.ratesystem == 'glicko') ratingid.innerHTML = '(G2)';
                        if (res.country != null && res.countr > 0) {
                          flagsoptionspanid.innerHTML  = flags[parseInt(res.country) - 1].item;
                          flagsoptionid.value_  = parseInt(res.country);
                        }
                        if (res.fide_title != null && res.fide_title > 0) {
                          titleoptionspanid.innerHTML  = titles[parseInt(res.fide_title) - 1].item;
                          titleoptionid.value_  = parseInt(res.fide_title);
                        }
                        if (res.photo != null) {
                           photoimageid.src = "/images/photo/" + res.photo;
                        }

                        // welcome back!
                        notice("Welcome back! Self-Promotions");
                        // set configuration
                        setConfiguration();
                    }
                 }
        }
     }

     async function uploadPhoto() {
         const req  = new XMLHttpRequest();
         const form = new FormData();
         req.open("POST", "/upload/photo", true);
         req.onreadystatechange = () => {
            if (req.readyState === 4 && req.status === 200) {
                var response = JSON.parse(req.responseText);
                log(response);
log(response.code);
                if (response.code != null && parseInt(response.code) == 0) {
log("change image");
log(photoimageid);
log(response.image);
                  photoimageid.src = "/images/photo/" + response.image;
                }
            }
         }
         form.append("sessionid", SESSION_.sessionid);
         form.append("username", SESSION_.username);
         form.append("file", pr_file.files[0]);
         req.send(form);

     }

     function getGame(gameid) {
        const container_ = document.getElementById('contr_' + gameid);
        return container_.game_;
     }

     function notice(msg) {
        noticeid.innerHTML = msg;
     }

     function closenotice() {
        waitingmatchid.style.visibility = 'hidden';
     }

     /**************** LET'S HANDLE SOCKET.IO **************************************/

     const socket = io("http://localhost:3000", {
          transports: ["websocket", "polling"] // use WebSocket first, if available
     });

     ERRCONNECT_ = 0;
     socket.onclose = function(event) {
          log("Error occurred.");
          // Inform the user about the error.
     }

     socket.on("disconnect", (reason) => {
        if (reason === "io server disconnect") {
 log("receiving disconnect ...");
 log("let us try to reconnect ...");
            socket.connect();
        }
     });

     socket.on("connect_error", (err) => {
        // revert to classic upgrade
        log(err);
        ERRCONNECT_ ++;
        log('Error connecting to server ... ');
        if (ERRCONNECT_ > 1) {
            socket.disconnect();
            SESSION_.disconnected = true;
            notice('System is in maintenance mode!');
        }
     });

     socket.on("connect", () => {

        ERRCONNECT_ = 0;
        guestSession(socket.id);
        log('Connected to server ...');

         socket.on("signedup", function(res) {
           if (res.code || typeof(res.code) == "undefined") {
              ERRMSG_ = res.msg;
              if (res.errid) {
                  const errhint = document.getElementById("err" + res.errid);
                  errhint.style.visibility = 'visible';
              } else {
                  ERRMSG_ = "Server error!";
                  const errhint = document.getElementById("err1001");
                  errhint.style.visibility = 'visible';
              }
           } else {
               // message to pick up registration confirmation through email. to be done ...
             const signin = signindivid;
             const signup = signupdivid;
             blanket.style.visibility = 'hidden';          
             signin.style.visibility = 'hidden';          
             signup.style.visibility = 'hidden';          
           }
         });

         socket.on("profileupdated", function(res) {
              ERRMSG_ = res.msg;
              if (res.errid) {
log("with errid");
              } else {
                 uploadPhoto(); 
log("no errid");
              }
         });


         socket.on("signedin", function(res) {
           if (res.code || typeof(res.code) == "undefined") {
              ERRMSG_ = res.msg;
              if (res.errid) {
                  const errhint = document.getElementById("err" + res.errid);
                  errhint.style.visibility = 'visible';
              } else {
                  ERRMSG_ = "Server error!";
                  const errhint = document.getElementById("err1004");
                  errhint.style.visibility = 'visible';
             }
           } else {
              signedinPlayer(res);
           }
         });

         socket.on("signedout", function(res) {
           if (res.code || typeof(res.code) == "undefined") {
              ERRMSG_ = res.msg;
              notice(res.msg);
           } else {
              unauthorizeView();
              document.cookie = "chess_=";
              guestSession(socket.id);
              notice("Please come back again!");
           }
           return true;
         });

         socket.on("readytohost", (game) => {
            log("ready to host");
            document.cookie = "hosting_=" + game.token;
            log(game);
            log(document.cookie);
         });

         socket.on("alreadyhostingsimul", (token) => {
            log("already hosting ...");
            log(token);
         });

         socket.on("takeback", (req) => {
log("offer draw received ...");
log(req);
           var game = req.game;
           if (game != null) {
               if (req.username == SESSION_.username) {
                  var wgame = game.wgame;
                  var bgame = game.bgame;
                  var gameid = (wgame.player == SESSION_.username) ? wgame.gameid : bgame.gameid;
                  var this_ = getGame(gameid);
                  chess_whistle.play();
                  this_.notice(req.requestor + " requests for takeback ...", { label: "granttakeback" } );
               }
           }
           return true;
         });

         socket.on("accepttakeback", (req) => {
log("takeback granted ...");
log(req);
           var game = req.game;
           if (game != null) {
               if (req.username == SESSION_.username) {
                  var wgame = game.wgame;
                  var bgame = game.bgame;
                  var gameid = (wgame.player == SESSION_.username) ? wgame.gameid : bgame.gameid;
                  var this_ = getGame(gameid);
                  this_.notice(req.requestor + " grants takeback ..." );
                  this_.takeitBack();
                 // this_.GAME_STATE.gameover_ = GAMEOVER.DRAWACCEPTED;
                 // this_.checkGameOver();
               }
           }
           return true;
         });

         socket.on("abortgame", (req) => {
log("offer abort received ...");
log(req);
           var game = req.game;
           if (game != null) {
               if (req.username == SESSION_.username) {
                  var wgame = game.wgame;
                  var bgame = game.bgame;
                  var gameid = (wgame.player == SESSION_.username) ? wgame.gameid : bgame.gameid;
                  var this_ = getGame(gameid);
                  chess_whistle.play();
                  this_.notice(req.requestor + " offers to abort game ...", { label: "acceptabort" } );
               }
           }
           return true;
         });

         socket.on("acceptabort", (req) => {
log("abort accepted ...");
log(req);
           var game = req.game;
           if (game != null) {
               if (req.username == SESSION_.username) {
                  var wgame = game.wgame;
                  var bgame = game.bgame;
                  var gameid = (wgame.player == SESSION_.username) ? wgame.gameid : bgame.gameid;
                  var this_ = getGame(gameid);
                  this_.notice(req.requestor + " accepts abort request ..." );
                  this_.GAME_STATE.gameover_ = GAMEOVER.ABORTED;
                  this_.checkGameOver();
               }
           }
           return true;
         });

         socket.on("offerdraw", (req) => {
log("offer draw received ...");
log(req);
           var game = req.game;
           if (game != null) {
               if (req.username == SESSION_.username) {
                  var wgame = game.wgame;
                  var bgame = game.bgame;
                  var gameid = (wgame.player == SESSION_.username) ? wgame.gameid : bgame.gameid;
                  var this_ = getGame(gameid);
                  chess_whistle.play();
                  this_.notice(req.requestor + " offers a draw ...", { label: "acceptdraw" } );
               }
           }
           return true;
         });

         socket.on("acceptdraw", (req) => {
log("draw accepted ...");
log(req);
           var game = req.game;
           if (game != null) {
               if (req.username == SESSION_.username) {
                  var wgame = game.wgame;
                  var bgame = game.bgame;
                  var gameid = (wgame.player == SESSION_.username) ? wgame.gameid : bgame.gameid;
                  var this_ = getGame(gameid);
                  this_.notice(req.requestor + " accepts draw ..." );
                  this_.GAME_STATE.gameover_ = GAMEOVER.DRAWACCEPTED;
                  this_.checkGameOver();
               }
           }
           return true;
         });

         socket.on("resign", (req) => {
log("offer to resign received ...");
log(req);
           var game = req.game;
           if (game != null) {
               var wgame = game.wgame;
               var bgame = game.bgame;
               var this_ = null;
               if (req.username == SESSION_.username) {
                  notice(req.requestor + " is resigning ...");
                  if (wgame.player == SESSION_.username) {
                      this_ = getGame(wgame.gameid);
                      this_.GAME_STATE.gameoverside_ = BLACK; // opponent
                  } else {
                      this_ = getGame(bgame.gameid);
                      this_.GAME_STATE.gameoverside_ = WHITE; // opponent
                  }
                  this_.GAME_STATE.gameover_ = GAMEOVER.RESIGNED;
                  this_.checkGameOver();
               } else 
               if (req.username == SESSION_.username) {
                  if (wgame.player == SESSION_.username) {
                      this_ = getGame(wgame.gameid);
                      this_.GAME_STATE.gameoverside_ = WHITE; // us
                  } else {
                      this_ = getGame(bgame.gameid);
                      this_.GAME_STATE.gameoverside_ = BLACK; // us
                  }
                  this_.GAME_STATE.gameover_ = GAMEOVER.RESIGNED;
                  this_.checkGameOver();
               }
           }
           return true;
         });

         socket.on("joinedsimul", (simul) => {
           joinedSimul(simul);
           return true;
         });

         socket.on("recordedgame", (req) => {
log("recorded game ...");
log(req);
            if (req.username == SESSION_.username && req.sessionid == SESSION_.sessionid) {
                 var this_ = getGame(req.gameid);
                 this_.GAME_STATE.status_ = STATUS.DONE;
                 this_.GAME_STATE.gameover_ = req.status;
                 this_.GAME_STATE.gameoverside_ = (req.rt == "0-1") ? WHITE : BLACK;
                 this_.msgDone(this_, req.rating, req.ratesystem);
            }
            return true;
         });

         socket.on("savedconfig", (result) => {
log("saved config ...");
            return true;
         });

         socket.on("rejointournament", (result) => {
log("ongoing tournament ...");
log(result);
            return true;
         });

         socket.on("showgame", (result) => {
log("show game  ...");
            if (result.username == SESSION_.username && result.sessionid == SESSION_.sessionid) {
               var game = result.game;
log("game 1 ...");
               if (game != null) {
log("game 2 ...");
log(game);
                  showGame(game);
               } else {
                 notice("Game is not available ...");
               }
            }
            return;
         });

         socket.on("watchtourney", (result) => {
log("watch tourney ...");
            if (result.username == SESSION_.username && result.sessionid == SESSION_.sessionid) {
               var tourney = result.tourney;
               if (tourney != null) {
                   showTournament(tourney);
               }
            }
            return;
         });

         socket.on("forfeitintournament", (tourney) => {
log("forfeit in tournament ...");
log(tourney);
            if (tourney.username == SESSION_.username && tourney.sessionid == SESSION_.sessionid) {
                 var this_ = null, missing_player = null;
                 if (tourney.username == tourney.wgame.player) {
                     this_ = getGame(tourney.wgame.gameid);
                 } else
                 if (tourney.username == tourney.bgame.player) {
                     this_ = getGame(tourney.bgame.gameid);
                 }
                  
                 if (tourney.wgame.missing != null && tourney.wgame.missing) {
                      missing_player = tourney.wgame.player;
                      this_.GAME_STATE.gameoverside_ = WHITE;
                 }
                 if (tourney.bgame.missing != null && tourney.bgame.missing) {
                      missing_player = tourney.bgame.player;
                      this_.GAME_STATE.gameoverside_ = BLACK;
                 }
                 if (this_ != null) {
                     this_.GAME_STATE.gameover_ = GAMEOVER.FORFEITED;
                     this_.checkGameOver();
                     this_.notice("Game over ... " + missing_player + " is forfeited!" );
                 }
            }
            return true;
         });

         socket.on("ongoingtournament", (tourney) => {
log("ongoing tournament ...");
log(tourney);
            if (tourney.username == SESSION_.username && tourney.sessionid == SESSION_.sessionid) {
               const game = tourney;
               closeApps();
               blanket.style.visibility = 'hidden';

               var variant = tourney.settings.variant - 1;
               var gametype = tourney.gametype;
               var fen = wINITFEN_;
               var e = { preventDefault: function() {} };

               var missing_player = null;
               if (tourney.wgame.missing != null && tourney.wgame.missing) missing_player = tourney.wgame.player;
               if (tourney.bgame.missing != null && tourney.bgame.missing) missing_player = tourney.bgame.player;

               const pvariant = (variant == null) ? STANDARD : variants[variant].item;
               if (pvariant == CHESS960) { fen = randomFENchess960(); };
               if (pvariant == HORDE) { fen = wINITFENHORDE_; };
log(fen); 
               clearBoards();
               const board = newBoard(e, hide = true, width = 480, height = 480, pvariant, fen);
               board.maxSize(e, board);
               if (missing_player != null) {
log("yes, missing player ... ");
log(missing_player);
                 if (tourney.wgame.missing != null && tourney.wgame.missing) {
log("here 1 ...");
                     board.startGame(game, false, missing_player );
                 } else 
                 if (tourney.bgame.missing != null && tourney.bgame.missing) {
log("here 2 ...");
                     board.startGame(game, true, missing_player );
                 }
               } else {
                 board.startGame(game, (game.wgame.player == SESSION_.username) ? true : false );
               }
               board.GAME_STATE.tourney = true;
               board.GAME_STATE.round = tourney.round;

               SESSION_.status = STATUS.ONGOINGTOURNEY;

/*
               if (missing_player != null) {
                  notice("Waiting for player before forfeiting ...");
               } 
*/
               socket.emit("acktournament", { sessionid: SESSION_.sessionid, username: SESSION_.username, round: tourney.round, 
                                           socketid: socket.id, gametoken: tourney.gametoken, gameid: board.id });
            }
            return true;
         });

         socket.on("starttournament", (tourney) => {
log("start tournament ...");
log(tourney);
            if (tourney.username == SESSION_.username && tourney.sessionid == SESSION_.sessionid) {
               chess_whistle.play();
               notice("Game is about to start ... Please be ready ...");
            }
            return true;
         });

         socket.on("donetournament", (result) => {
log("done tournament ...");
log(result);
            chess_whistle.play();
            notice("Tournament over ...");
            return true;
         });

         socket.on("savedtournament", (result) => {
            if (result.code == 0) {
                 notice("Tournament submitted.");
            } else 
            if (result.code == 2) {
                 notice("Tournament not allowed to change if ongoing.");
            } else
            if (result.code == 23505) {
                 notice("Tournament already exists. Change date.");
            } else {
                 notice("Failed to register tournament.");
            }
            return true;
         });

         socket.on("joinedtourney", (result) => {

            log(LOCALdate(result.joined_date));

            watchGame(null);
            notice(result.msg); 
            return true;
         });

         socket.on("lefttourney", (result) => {
log("left tournament ...");
log(result);
            watchGame(null);
            notice(result.msg);
            return true;
         });

         socket.on("canceledsimul", (result) => {
log("canceled simul ...");
             clearBoards();
             SESSION_.status = STATUS.CANCELED;
             notice("Simul has been cancelled ..."); 
             log(result);
         });

         socket.on("rematch", (req) => {
log("server says rematch ...");
log(req);
            var wgame = req.wgame;
            var bgame = req.bgame;
            var this_ = null, color = false;
            if (wgame.player == SESSION_.username && wgame.sessionid == SESSION_.sessionid) {
                 this_ = getGame(wgame.gameid);
                 color = true;
            } else
            if (bgame.player == SESSION_.username && bgame.sessionid == SESSION_.sessionid) {
                 this_ = getGame(bgame.gameid);
            }
            var wgame_ = this_.rematch_.wgame;
            var bgame_ = this_.rematch_.bgame;

            wgame_.rating = wgame.rating;
            bgame_.rating = bgame.rating;

            // switch colors ...
            this_.rematch_.wgame = bgame_;
            this_.rematch_.bgame = wgame_;
            this_.rematch_.fen   = req.fen;
            startGame(this_.rematch_, color);
            return true;
         });

         socket.on("play", (game) => {
log("receiving play start ...");
log("mole ...");
log(game);
            startGame(game);
            return true;
         });

         socket.on("move", (game) => {
log("server says movement ...");
log(game);
            moveGame(game);
            return true;
         });

         socket.on("revealmole", (game) => {
            if (game.username == SESSION_.username && game.sessionid == SESSION_.sessionid) {
               var this_ = getGame(game.gameid);
               var board = this_.ChessBoard.Board;
               var piece = board[game.mole].piece;
               if (piece != null) {
log("we got the mole/traitor ...");
                  if (piece.role_ == 'P') {
                        var p_ = (piece.color == 'plt') ? 'pdt' : 'plt';
                        piece.img_.src = getImgSrc(p_);
                        piece.color_ = p_;
                  } else
                  if (piece.role_ == 'N') {
                        var p_ = (piece.color == 'nlt') ? 'ndt' : 'nlt';
                        piece.img_.src = getImgSrc(p_);
                        piece.color_ = p_;
                  } else
                  if (piece.role_ == 'R') {
                        var p_ = (piece.color == 'rlt') ? 'rdt' : 'rlt';
                        piece.img_.src = getImgSrc(p_);
                        piece.color_ = p_;
                  }
                  if (game.ismole) {
                    notice("Mole is revealed on " + game.mole + " ...");
                  } else
                  if (game.istraitor) {
                    notice("Traitor is revealed on " + game.mole + " ...");
                  }
               }
            }
            return true;
         });

         socket.on("ping", (ses) => {
log("checking latency ...");
log(ses);
            socket.emit("pong", ses);
         });

         socket.on("AuthError", function(res) {
            log("Error Authenticating: " + res);
            return true;
         });
     });

     window.onunload = window.onbeforeunload = () => {
          socket.close();
     };


   log("Load Parser ...");
   loadParser();
   log("Load ECO ...");
   loadECO();
   log("Load Stockfish ...");
   loadStockfish();
   log("Enable Key Event Capture ...");
   keyPress(true);

   log("Create PGN Window ...");
   createPGNWindow();
 
   onWindowResize();
  
   t0 = performance.now();
   t1 = performance.now();
   log(t1 - t0);
</script>
</body>
</html>
